---
data:
  _extendedDependsOn:
  - icon: ':warning:'
    path: Java/extension/AVLTree.java
    title: Java/extension/AVLTree.java
  - icon: ':warning:'
    path: Java/extension/Deque.java
    title: Java/extension/Deque.java
  - icon: ':warning:'
    path: Java/extension/DoubleEndedPriorityQueue.java
    title: Java/extension/DoubleEndedPriorityQueue.java
  - icon: ':warning:'
    path: Java/extension/EulerPhiTable.java
    title: Java/extension/EulerPhiTable.java
  - icon: ':warning:'
    path: Java/extension/FenwickTree.java
    title: Java/extension/FenwickTree.java
  - icon: ':warning:'
    path: Java/extension/Graph.java
    title: Java/extension/Graph.java
  - icon: ':warning:'
    path: Java/extension/Huitloxopetl.java
    title: Java/extension/Huitloxopetl.java
  - icon: ':warning:'
    path: Java/extension/LargePrime.java
    title: Java/extension/LargePrime.java
  - icon: ':warning:'
    path: Java/extension/LowestCommonAncestor.java
    title: Java/extension/LowestCommonAncestor.java
  - icon: ':warning:'
    path: Java/extension/PrefixSum.java
    title: Java/extension/PrefixSum.java
  - icon: ':warning:'
    path: Java/extension/PrimeCounter.java
    title: Java/extension/PrimeCounter.java
  - icon: ':warning:'
    path: Java/extension/PrimeFactor.java
    title: Java/extension/PrimeFactor.java
  - icon: ':warning:'
    path: Java/extension/PrimeTable.java
    title: Java/extension/PrimeTable.java
  - icon: ':warning:'
    path: Java/extension/SegmentTree.java
    title: Java/extension/SegmentTree.java
  - icon: ':warning:'
    path: Java/extension/SparseTable.java
    title: Java/extension/SparseTable.java
  - icon: ':warning:'
    path: Java/extension/SuffixArray.java
    title: Java/extension/SuffixArray.java
  - icon: ':warning:'
    path: Java/extension/Template.java
    title: Java/extension/Template.java
  - icon: ':warning:'
    path: Java/extension/UndoUnionFind.java
    title: Java/extension/UndoUnionFind.java
  - icon: ':warning:'
    path: Java/extension/UnionFind.java
    title: Java/extension/UnionFind.java
  - icon: ':warning:'
    path: Java/extension/WaveletMatrix.java
    title: Java/extension/WaveletMatrix.java
  - icon: ':warning:'
    path: Java/extension/WeightedGraph.java
    title: Java/extension/WeightedGraph.java
  - icon: ':warning:'
    path: Java/extension/WeightedUnionFind.java
    title: Java/extension/WeightedUnionFind.java
  _extendedRequiredBy:
  - icon: ':warning:'
    path: Java/extension/AVLTree.java
    title: Java/extension/AVLTree.java
  - icon: ':warning:'
    path: Java/extension/Deque.java
    title: Java/extension/Deque.java
  - icon: ':warning:'
    path: Java/extension/DoubleEndedPriorityQueue.java
    title: Java/extension/DoubleEndedPriorityQueue.java
  - icon: ':warning:'
    path: Java/extension/EulerPhiTable.java
    title: Java/extension/EulerPhiTable.java
  - icon: ':warning:'
    path: Java/extension/FenwickTree.java
    title: Java/extension/FenwickTree.java
  - icon: ':warning:'
    path: Java/extension/Graph.java
    title: Java/extension/Graph.java
  - icon: ':warning:'
    path: Java/extension/Huitloxopetl.java
    title: Java/extension/Huitloxopetl.java
  - icon: ':warning:'
    path: Java/extension/LargePrime.java
    title: Java/extension/LargePrime.java
  - icon: ':warning:'
    path: Java/extension/LowestCommonAncestor.java
    title: Java/extension/LowestCommonAncestor.java
  - icon: ':warning:'
    path: Java/extension/PrefixSum.java
    title: Java/extension/PrefixSum.java
  - icon: ':warning:'
    path: Java/extension/PrimeCounter.java
    title: Java/extension/PrimeCounter.java
  - icon: ':warning:'
    path: Java/extension/PrimeFactor.java
    title: Java/extension/PrimeFactor.java
  - icon: ':warning:'
    path: Java/extension/PrimeTable.java
    title: Java/extension/PrimeTable.java
  - icon: ':warning:'
    path: Java/extension/SegmentTree.java
    title: Java/extension/SegmentTree.java
  - icon: ':warning:'
    path: Java/extension/SparseTable.java
    title: Java/extension/SparseTable.java
  - icon: ':warning:'
    path: Java/extension/SuffixArray.java
    title: Java/extension/SuffixArray.java
  - icon: ':warning:'
    path: Java/extension/Template.java
    title: Java/extension/Template.java
  - icon: ':warning:'
    path: Java/extension/UndoUnionFind.java
    title: Java/extension/UndoUnionFind.java
  - icon: ':warning:'
    path: Java/extension/UnionFind.java
    title: Java/extension/UnionFind.java
  - icon: ':warning:'
    path: Java/extension/WaveletMatrix.java
    title: Java/extension/WaveletMatrix.java
  - icon: ':warning:'
    path: Java/extension/WeightedGraph.java
    title: Java/extension/WeightedGraph.java
  - icon: ':warning:'
    path: Java/extension/WeightedUnionFind.java
    title: Java/extension/WeightedUnionFind.java
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: java
  _verificationStatusIcon: ':warning:'
  attributes: {}
  bundledCode: "Traceback (most recent call last):\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/languages/user_defined.py\"\
    , line 68, in bundle\n    raise RuntimeError('bundler is not specified: {}'.format(str(path)))\n\
    RuntimeError: bundler is not specified: Java/all.java\n"
  code: "import java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\
    import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\
    import java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\n\
    import java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\
    import java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\nimport\
    \ java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport\
    \ java.util.TreeMap;\nimport java.util.function.BiFunction;\nimport java.util.function.BiPredicate;\n\
    import java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\n\
    import java.util.function.DoublePredicate;\nimport java.util.function.Function;\n\
    import java.util.function.IntPredicate;\nimport java.util.function.LongBinaryOperator;\n\
    import java.util.function.LongPredicate;\nimport java.util.function.Predicate;\n\
    import java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nfinal\
    \ class Main {\n\tpublic static void main(final String[] args) {\n\t\tIntStream.range(0,\
    \ VvyLw.multi ? VvyLw.sc.ni() : 1).forEach(i -> VvyLw.solve());\n\t\tVvyLw.o.flush();\n\
    \t\tVvyLw.sc.close();\n\t\tVvyLw.o.close();\n\t\tVvyLw.dbg.close();\n\t}\n}\n\n\
    final class VvyLw extends Utility {\n\tstatic final MyScanner sc = new MyScanner();\n\
    \tstatic final MyPrinter o = new MyPrinter(System.out, false);\n\tstatic final\
    \ MyPrinter dbg = new MyPrinter(System.err, true);\n\tstatic final Huitloxopetl\
    \ why = new Huitloxopetl();\n\tstatic final boolean multi = false;\n\tstatic final\
    \ int inf = 1 << 30;\n\tstatic final long linf = (1L << 61) - 1;\n\tstatic final\
    \ double eps = 1e-18;\n\t@SuppressWarnings(\"unused\")\n\tprivate static final\
    \ int[] dx = {0, -1, 1, 0, 0, -1, -1, 1, 1};\n\t@SuppressWarnings(\"unused\")\n\
    \tprivate static final int[] dy = {0, 0, 0, -1, 1, -1, 1, -1, 1};\n\t@SuppressWarnings(\"\
    unused\")\n\tprivate static final int mod998 = 998244353;\n\t@SuppressWarnings(\"\
    unused\")\n\tprivate static final int mod107 = (int)1e9 + 7;\n\tstatic final void\
    \ solve() {\n\t\tfinal int n = sc.ni();\n\t\tfinal var s = sc.ns().toCharArray();\n\
    \t\tfinal char c = sc.nc();\n\t}\n}\nclass Utility {\n\tprotected static final\
    \ String yes(final boolean ok){ return ok ? \"Yes\" : \"No\"; }\n\tprotected static\
    \ final String no(final boolean ok){ return yes(!ok); }\n\tprotected static final\
    \ long sqr(final long x){ return x * x; }\n\tprotected static final long mod(final\
    \ long n, final long m){ return (n + m) % m; }\n\tprotected static final long\
    \ ceil(final long a, final long b){ return (a - 1) / b + 1; }\n\tprotected static\
    \ final double round(final double a, final long b, final int c) {\n\t\tfinal long\
    \ d = pow(10, c);\n\t\treturn Math.rint((a * d) / b) / d;\n\t}\n\tprotected static\
    \ final long pow(long a, int b) {\n\t\tlong res = 1;\n\t\twhile(b > 0) {\n\t\t\
    \tif(b % 2 == 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tb >>= 1;\n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final long pow(long a, long b,\
    \ final long m) {\n\t\tlong res = 1;\n\t\twhile(b > 0) {\n\t\t\tif(b % 2 == 1)\
    \ {\n\t\t\t\tres *= a;\n\t\t\t\tres = mod(res, m);\n\t\t\t}\n\t\t\ta *= a;\n\t\
    \t\ta = mod(a, m);\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static\
    \ final long lcm(final long a, final long b){ return a * b / gcd(a, b); }\n\t\
    protected static final long lcm(final int... a){ return Arrays.stream(a).mapToLong(i\
    \ -> i).reduce(1, (x, y) -> lcm(x, y)); }\n\tprotected static final long lcm(final\
    \ long... a){ return Arrays.stream(a).reduce(1, (x, y) -> lcm(x, y)); }\n\tprotected\
    \ static final long gcd(final long a, final long b){ return b > 0 ? gcd(b, a %\
    \ b) : a; }\n\tprotected static final int gcd(final int... a){ return Arrays.stream(a).reduce(0,\
    \ (x, y) -> (int) gcd(x, y)); }\n\tprotected static final long gcd(final long...\
    \ a){ return Arrays.stream(a).reduce(0, (x, y) -> gcd(x, y)); }\n\tprotected static\
    \ final int min(final int... a){ return Arrays.stream(a).reduce(Integer.MAX_VALUE,\
    \ (x, y) -> Math.min(x, y)); }\n\tprotected static final long min(final long...\
    \ a){ return Arrays.stream(a).reduce(Long.MAX_VALUE, (x, y) -> Math.min(x, y));\
    \ }\n\tprotected static final int max(final int... a){ return Arrays.stream(a).reduce(Integer.MIN_VALUE,\
    \ (x, y) -> Math.max(x, y)); }\n\tprotected static final long max(final long...\
    \ a){ return Arrays.stream(a).reduce(Long.MIN_VALUE, (x, y) -> Math.max(x, y));\
    \ }\n\tprotected static final ArrayList<Long> div(final long n) {\n\t\tfinal ArrayList<Long>\
    \ d = new ArrayList<>();\n\t\tfor(long i = 1; i * i <= n; ++i) {\n\t\t\tif(n %\
    \ i == 0) {\n\t\t\t\td.add(i);\n\t\t\t\tif(i * i != n) {\n\t\t\t\t\td.add(n /\
    \ i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCollections.sort(d);\n\t\treturn d;\n\t\
    }\n\tprotected static final ArrayList<Pair<Long, Integer>> primeFactor(long n)\
    \ {\n\t\tfinal ArrayList<Pair<Long, Integer>> pf = new ArrayList<>();\n\t\tfor(long\
    \ i = 2; i * i <= n; ++i) {\n\t\t\tif(n % i != 0) {\n\t\t\t\tcontinue;\n\t\t\t\
    }\n\t\t\tint cnt = 0;\n\t\t\twhile(n % i == 0) {\n\t\t\t\tcnt++;\n\t\t\t\tn /=\
    \ i;\n\t\t\t}\n\t\t\tpf.add(Pair.of(i, cnt));\n\t\t}\n\t\tif(n != 1) {\n\t\t\t\
    pf.add(Pair.of(n, 1));\n\t\t}\n\t\treturn pf;\n\t}\n\tprotected static final long\
    \ eulerPhi(long n) {\n\t\tlong res = n;\n\t\tfor(long i = 2; i * i <= n; ++i)\
    \ {\n\t\t\tif(n % i == 0) {\n\t\t\t\tres -= res / i;\n\t\t\t\twhile(n % i == 0)\
    \ {\n\t\t\t\t\tn /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n > 1) {\n\t\t\tres\
    \ -= res / n;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static final long factor(int\
    \ n) {\n\t\tlong res = 1;\n\t\twhile(n > 0) {\n\t\t\tres *= n--;\n\t\t}\n\t\t\
    return res;\n\t}\n\tprotected static final long factor(int n, final long mod)\
    \ {\n\t\tlong res = 1;\n\t\twhile(n > 0) {\n\t\t\tres *= n--;\n\t\t\tres %= mod;\n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final long perm(int n, final int\
    \ r) {\n\t\tfinal int og = n;\n\t\tlong res = 1;\n\t\twhile(n > og - r) {\n\t\t\
    \tres *= n--;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static final long perm(int\
    \ n, final int r, final long mod) {\n\t\tfinal int og = n;\n\t\tlong res = 1;\n\
    \t\twhile(n > og - r) {\n\t\t\tres *= n--;\n\t\t\tres %= mod; \n\t\t}\n\t\treturn\
    \ res;\n\t}\n\tprotected static final long binom(int n, final int r) {\n\t\tif(r\
    \ < 0 || n < r) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 1;\n\t\tfor(int i =\
    \ 1; i <= r; ++i) {\n\t\t\tres *= n--;\n\t\t\tres /= i;\n\t\t}\n\t\treturn res;\n\
    \t}\n\tprotected static final long binom(int n, final int r, final long mod) {\n\
    \t\tif(r < 0 || n < r) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 1;\n\t\tfor(int\
    \ i = 1; i <= r; ++i) {\n\t\t\tres *= n--;\n\t\t\tres %= mod;\n\t\t\tres /= i;\n\
    \t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static final boolean\
    \ isInt(final double n){ long r = (long) Math.floor(n); return r == n; }\n\tprotected\
    \ static final boolean isSqr(final long n){ return isInt(Math.sqrt(n)); }\n\t\
    protected static final boolean isPrime(final long n) {\n\t\tif(n == 1) {\n\t\t\
    \treturn false;\n\t\t}\n\t\tfor(long i = 2; i * i <= n; ++i) {\n\t\t\tif(n % i\
    \ == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprotected\
    \ static final boolean scope(final int l, final int x, final int r){ return l\
    \ <= x && x <= r; }\n\tprotected static final boolean scope(final long l, final\
    \ long x, final long r){ return l <= x && x <= r; }\n\tprotected static final\
    \ boolean scope(final double l, final double x, final double r){ return l <= x\
    \ && x <= r; }\n\tprotected static final int clamp(final int l, final int x, final\
    \ int r){ return x < l ? l : x > r ? r : x; }\n\tprotected static final long clamp(final\
    \ long l, final long x, final long r){ return x < l ? l : x > r ? r : x; }\n\t\
    protected static final double clamp(final double l, final double x, final double\
    \ r){ return x < l ? l : x > r ? r : x; }\n\tprotected static final int[] nextPerm(final\
    \ int[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i])\
    \ {\n\t\t\t\tfinal int j = find(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a,\
    \ i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treturn a;\n\t\t\t\
    }\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final long[] nextPerm(final\
    \ long[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i])\
    \ {\n\t\t\t\tfinal int j = find(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a,\
    \ i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treturn a;\n\t\t\t\
    }\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final double[] nextPerm(final\
    \ double[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i])\
    \ {\n\t\t\t\tfinal int j = find(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a,\
    \ i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treturn a;\n\t\t\t\
    }\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final String nextPerm(final\
    \ String s) {\n\t\tfinal var a = s.chars().mapToObj(i -> (char) i).collect(Collectors.toList());\n\
    \t\tfor(int i = a.size(); --i > 0;) {\n\t\t\tif(a.get(i - 1).compareTo(a.get(i))\
    \ < 0) {\n\t\t\t\tfinal int j = find(a.get(i - 1), a, i, a.size() - 1);\n\t\t\t\
    \tCollections.swap(a, i - 1, j);\n\t\t\t\tCollections.sort(a.subList(i, a.size()));\n\
    \t\t\t\treturn a.stream().map(String::valueOf).collect(Collectors.joining());\n\
    \t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final int[] prevPerm(final\
    \ int[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] > a[i])\
    \ {\n\t\t\t\tfinal int j = findRev(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a,\
    \ i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treturn reverse(a);\n\
    \t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final long[] prevPerm(final\
    \ long[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] > a[i])\
    \ {\n\t\t\t\tfinal int j = findRev(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a,\
    \ i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treturn reverse(a);\n\
    \t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final double[] prevPerm(final\
    \ double[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] > a[i])\
    \ {\n\t\t\t\tfinal int j = findRev(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a,\
    \ i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treturn reverse(a);\n\
    \t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprotected static final String prevPerm(final\
    \ String s) {\n\t\tvar a = s.chars().mapToObj(i -> (char)i).collect(Collectors.toList());\n\
    \t\tfor(int i = a.size(); --i > 0;) {\n\t\t\tif(a.get(i - 1).compareTo(a.get(i))\
    \ > 0) {\n\t\t\t\tfinal int j = findRev(a.get(i - 1), a, i, a.size() - 1);\n\t\
    \t\t\tCollections.swap(a, i - 1, j);\n\t\t\t\tCollections.sort(a.subList(i, a.size()),\
    \ Collections.reverseOrder());\n\t\t\t\treturn a.stream().map(String::valueOf).collect(Collectors.joining());\n\
    \t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate static final int find(final int\
    \ dest, final int[] a, final int s, final int e) {\n\t\tif(s == e) {\n\t\t\treturn\
    \ s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] <= dest ? find(dest,\
    \ a, s, m - 1) : find(dest, a, m, e);\n\t}\n\tprivate static final int find(final\
    \ long dest, final long[] a, final int s, final int e) {\n\t\tif(s == e) {\n\t\
    \t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] <= dest\
    \ ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n\t}\n\tprivate static final\
    \ int find(final double dest, final double[] a, final int s, final int e) {\n\t\
    \tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\
    \treturn a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n\t}\n\t\
    private static final int find(final char dest, final List<Character> a, final\
    \ int s, final int e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int\
    \ m = (s + e + 1) / 2;\n\t\treturn a.get(m).compareTo(dest) <= 0 ? find(dest,\
    \ a, s, m - 1) : find(dest, a, m, e);\n\t}\n\tprivate static final int findRev(final\
    \ int dest, final int[] a, final int s, final int e) {\n\t\tif(s == e) {\n\t\t\
    \treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] > dest\
    \ ? findRev(dest, a, s, m - 1) : findRev(dest, a, m, e);\n\t}\n\tprivate static\
    \ final int findRev(final long dest, final long[] a, final int s, final int e)\
    \ {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) /\
    \ 2;\n\t\treturn a[m] > dest ? findRev(dest, a, s, m - 1) : findRev(dest, a, m,\
    \ e);\n\t}\n\tprivate static final int findRev(final double dest, final double[]\
    \ a, final int s, final int e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\
    \tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] > dest ? findRev(dest, a, s,\
    \ m - 1) : findRev(dest, a, m, e);\n\t}\n\tprivate static final int findRev(final\
    \ char dest, final List<Character> a, final int s, final int e) {\n\t\tif(s ==\
    \ e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn\
    \ a.get(m).compareTo(dest) > 0 ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n\
    \t}\n\tprotected static final int find(final int[] a, final int x) {\n\t\tfor(int\
    \ i = 0; i < a.length; ++i) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t\
    }\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int find(final long[]\
    \ a, final long x) {\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tif(a[i] ==\
    \ x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static\
    \ final int find(final double[] a, final double x) {\n\t\tfor(int i = 0; i < a.length;\
    \ ++i) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ -1;\n\t}\n\tprotected static final int find(final String s, final char c) {\n\
    \t\tfor(int i = 0; i < s.length(); ++i) {\n\t\t\tif(s.charAt(i) == c) {\n\t\t\t\
    \treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int\
    \ find(final char[] s, final char c) {\n\t\tfor(int i = 0; i < s.length; ++i)\
    \ {\n\t\t\tif(s[i] == c) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\
    \t}\n\tprotected static final int find(final Object[] a, final Object x) {\n\t\
    \tfor(int i = 0; i < a.length; ++i) {\n\t\t\tif(a[i].equals(x)) {\n\t\t\t\treturn\
    \ i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int findRev(final\
    \ int[] a, final int x) {\n\t\tfor(int i = a.length; --i >= 0;) {\n\t\t\tif(a[i]\
    \ == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected\
    \ static final int findRev(final long[] a, final long x) {\n\t\tfor(int i = a.length;\
    \ --i >= 0;) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\
    return -1;\n\t}\n\tprotected static final int findRev(final double[] a, final\
    \ double x) {\n\t\tfor(int i = a.length; --i >= 0;) {\n\t\t\tif(a[i] == x) {\n\
    \t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final\
    \ int findRev(final String s, final char c) {\n\t\tfor(int i = s.length(); --i\
    \ >= 0;) {\n\t\t\tif(s.charAt(i) == c) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\
    \treturn -1;\n\t}\n\tprotected static final int findRev(final char[] s, final\
    \ char c) {\n\t\tfor(int i = s.length; --i >= 0;) {\n\t\t\tif(s[i] == c) {\n\t\
    \t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final\
    \ int findRev(final Object[] a, final Object x) {\n\t\tfor(int i = a.length; --i\
    \ >= 0;) {\n\t\t\tif(a[i].equals(x)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\
    return -1;\n\t}\n\tprotected static final boolean binarySearch(final int[] a,\
    \ final int x){ return Arrays.binarySearch(a, x) >= 0; }\n\tprotected static final\
    \ boolean binarySearch(final long[] a, final long x){ return Arrays.binarySearch(a,\
    \ x) >= 0; }\n\tprotected static final boolean binarySearch(final Object[] a,\
    \ final Object x){ return Arrays.binarySearch(a, x) >= 0; }\n\tprotected static\
    \ final boolean binarySearch(final List<Object> a, final Object x){ return Collections.binarySearch(a,\
    \ x, null) >= 0; }\n\tprotected static final int lowerBound(final int[] a, final\
    \ int x){ return bins(a.length, -1, (IntPredicate) y -> a[y] >= x); }\n\tprotected\
    \ static final int lowerBound(final long[] a, final long x){ return bins(a.length,\
    \ -1, (IntPredicate) y -> a[y] >= x); }\n\tprotected static final <T extends Comparable<?\
    \ super T>> int lowerBound(final T[] a, final T x){ return lowerBound(Arrays.asList(a),\
    \ x); }\n\tprotected static final <T extends Comparable<? super T>> int lowerBound(final\
    \ List<T> a, final T x){ return ~Collections.binarySearch(a, x, (p, q) -> p.compareTo(q)\
    \ >= 0 ? 1 : -1); }\n\tprotected static final int upperBound(final int[] a, final\
    \ int x){ return bins(a.length, -1, (IntPredicate) y -> a[y] > x); }\n\tprotected\
    \ static final int upperBound(final long[] a, final long x){ return bins(a.length,\
    \ -1, (IntPredicate) y -> a[y] > x); }\n\tprotected static final <T extends Comparable<?\
    \ super T>> int upperBound(final T[] a, final T x){ return upperBound(Arrays.asList(a),\
    \ x); }\n\tprotected static final <T extends Comparable<? super T>> int upperBound(final\
    \ List<T> a, final T x){ return ~Collections.binarySearch(a, x, (p, q) -> p.compareTo(q)\
    \ > 0 ? 1 : -1); }\n\tprotected static final String sorted(final String s){ return\
    \ s.chars().sorted().mapToObj(Character::toString).collect(Collectors.joining());\
    \ }\n\tprotected static final int[] sorted(final int[] a){ return Arrays.stream(a).sorted().toArray();\
    \ }\n\tprotected static final long[] sorted(final long[] a){ return Arrays.stream(a).sorted().toArray();\
    \ }\n\tprotected static final double[] sorted(final double[] a){ return Arrays.stream(a).sorted().toArray();\
    \ }\n\tprotected static final String reverse(final String s){ return new StringBuilder(s).reverse().toString();\
    \ }\n\tprotected static final int[] reverse(final int[] a) {\n\t\tfinal int n\
    \ = a.length;\n\t\tfinal int[] b = new int[n];\n\t\tfor(int i = 0; i <= n / 2;\
    \ ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n - 1 - i] = a[i];\n\t\t}\n\t\t\
    return b;\n\t}\n\tprotected static final long[] reverse(final long[] a) {\n\t\t\
    final int n = a.length;\n\t\tfinal long[] b = new long[n];\n\t\tfor(int i = 0;\
    \ i <= n / 2; ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n - 1 - i] = a[i];\n\
    \t\t}\n\t\treturn b;\n\t}\n\tprotected static final double[] reverse(final double[]\
    \ a) {\n\t\tfinal int n = a.length;\n\t\tfinal double[] b = new double[n];\n\t\
    \tfor(int i = 0; i <= n / 2; ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n - 1\
    \ - i] = a[i];\n\t\t}\n\t\treturn b;\n\t}\n\tprotected static final Object[] reverse(final\
    \ Object[] a) {\n\t\tfinal int n = a.length;\n\t\tfinal Object[] b = new Object[n];\n\
    \t\tfor(int i = 0; i <= n / 2; ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n -\
    \ 1 - i] = a[i];\n\t\t}\n\t\treturn b;\n\t}\n\tprotected static final int[] rotate(final\
    \ int[] a, final int id) {\n\t\tfinal var t = Arrays.stream(a).boxed().collect(Collectors.toList());\n\
    \t\tCollections.rotate(t, id);\n\t\tfinal int[] res = new int[a.length];\n\t\t\
    for(int i = 0; i < a.length; ++i) {\n\t\t\tres[i] = t.get(i);\n\t\t}\n\t\treturn\
    \ res;\n\t}\n\tprotected static final long[] rotate(final long[] a, final int\
    \ id) {\n\t\tfinal var t = Arrays.stream(a).boxed().collect(Collectors.toList());\n\
    \t\tCollections.rotate(t, id);\n\t\tfinal long[] res = new long[a.length];\n\t\
    \tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres[i] = t.get(i);\n\t\t}\n\t\treturn\
    \ res;\n\t}\n\tprotected static final double[] rotate(final double[] a, final\
    \ int id) {\n\t\tfinal var t = Arrays.stream(a).boxed().collect(Collectors.toList());\n\
    \t\tCollections.rotate(t, id);\n\t\tfinal double[] res = new double[a.length];\n\
    \t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres[i] = t.get(i);\n\t\t}\n\t\t\
    return res;\n\t}\n\tprotected static final String rotate(final String s, final\
    \ int id) {\n\t\tfinal var t = s.chars().mapToObj(i -> (char) i).collect(Collectors.toList());\n\
    \t\tCollections.rotate(t, id);\n\t\treturn t.stream().map(i -> i.toString()).collect(Collectors.joining());\n\
    \t}\n\tprotected static final int[][] rotateR(final int[][] a) {\n\t\tfinal int\
    \ h = a.length, w = a[0].length;\n\t\tfinal int[][] b = new int[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][i]);\n\t\t});\n\t\tIntStream.range(0,\
    \ w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn b;\n\t}\n\tprotected static\
    \ final long[][] rotateR(final long[][] a) {\n\t\tfinal int h = a.length, w =\
    \ a[0].length;\n\t\tfinal long[][] b = new long[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][i]);\n\t\t});\n\t\tIntStream.range(0,\
    \ w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn b;\n\t}\n\tprotected static\
    \ final double[][] rotateR(final double[][] a) {\n\t\tfinal int h = a.length,\
    \ w = a[0].length;\n\t\tfinal double[][] b = new double[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][i]);\n\t\t});\n\t\tIntStream.range(0,\
    \ w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn b;\n\t}\n\tprotected static\
    \ final String[] rotateR(final String[] s) {\n\t\tfinal int h = s.length, w =\
    \ s[0].length();\n\t\tfinal char[][] t = new char[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tIntStream.range(0, w).forEach(j -> t[j][i] = s[i].charAt(j));\n\
    \t\t});\n\t\tIntStream.range(0, w).forEach(i -> t[i] = new StringBuilder(new String(t[i])).reverse().toString().toCharArray());\n\
    \t\tfinal String[] res = new String[w];\n\t\tArrays.setAll(res, i -> String.valueOf(t[i]));\n\
    \t\treturn res;\n\t}\n\tprotected static final int[][] rotateL(final int[][] a)\
    \ {\n\t\tfinal int h = a.length, w = a[0].length;\n\t\tfinal int[][] b = new int[w][h];\n\
    \t\tIntStream.range(0, h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][w\
    \ - i - 1]);\n\t\t});\n\t\treturn b;\n\t}\n\tprotected static final long[][] rotateL(final\
    \ long[][] a) {\n\t\tfinal int h = a.length, w = a[0].length;\n\t\tfinal long[][]\
    \ b = new long[w][h];\n\t\tIntStream.range(0, h).forEach(i -> {\n\t\t\tArrays.setAll(b[i],\
    \ j -> a[j][w - i - 1]);\n\t\t});\n\t\treturn b;\n\t}\n\tprotected static final\
    \ double[][] rotateL(final double[][] a) {\n\t\tfinal int h = a.length, w = a[0].length;\n\
    \t\tfinal double[][] b = new double[w][h];\n\t\tIntStream.range(0, h).forEach(i\
    \ -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][w - i - 1]);\n\t\t});\n\t\treturn\
    \ b;\n\t}\n\tprotected static final String[] rotateL(final String[] s) {\n\t\t\
    final int h = s.length, w = s[0].length();\n\t\tfinal char[][] t = new char[w][h];\n\
    \t\tIntStream.range(0, h).forEach(i -> {\n\t\t\tIntStream.range(0, w).forEach(j\
    \ -> t[w - j - 1][i] = s[i].charAt(j));\n\t\t});\n\t\tfinal String[] res = new\
    \ String[w];\n\t\tArrays.setAll(res, i -> String.valueOf(t[i]));\n\t\treturn res;\n\
    \t}\n\tprotected static final void swap(final int[] a, final int i, final int\
    \ j) {\n\t\ta[i] ^= a[j];\n\t\ta[j] ^= a[i];\n\t\ta[i] ^= a[j];\n\t}\n\tprotected\
    \ static final void swap(final long[] a, final int i, final int j) {\n\t\ta[i]\
    \ ^= a[j];\n\t\ta[j] ^= a[i];\n\t\ta[i] ^= a[j];\n\t}\n\tprotected static final\
    \ void swap(final double[] a, final int i, final int j) {\n\t\tfinal var tmp =\
    \ a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n\tprotected static final void\
    \ swap(final char[] a, final int i, final int j) {\n\t\ta[i] ^= a[j];\n\t\ta[j]\
    \ ^= a[i];\n\t\ta[i] ^= a[j];\n\t}\n\tprotected static final void swap(final boolean[]\
    \ a, final int i, final int j) {\n\t\ta[i] ^= a[j];\n\t\ta[j] ^= a[i];\n\t\ta[i]\
    \ ^= a[j];\n\t}\n\tprotected static final void swap(final Object[] a, final int\
    \ i, final int j) {\n\t\tfinal var tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\
    \t}\n\tprotected static final void swap(final int[] a, final int[] b) {\n\t\t\
    assert a.length == b.length;\n\t\tfinal int n = a.length;\n\t\tfinal var c = a.clone();\n\
    \t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0, b, 0, n);\n\t\
    }\n\tprotected static final void swap(final long[] a, final long[] b) {\n\t\t\
    assert a.length == b.length;\n\t\tfinal int n = a.length;\n\t\tfinal var c = a.clone();\n\
    \t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0, b, 0, n);\n\t\
    }\n\tprotected static final void swap(final double[] a, final double[] b) {\n\t\
    \tassert a.length == b.length;\n\t\tfinal int n = a.length;\n\t\tfinal var c =\
    \ a.clone();\n\t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0,\
    \ b, 0, n);\n\t}\n\tprotected static final void swap(final char[] a, final char[]\
    \ b) {\n\t\tassert a.length == b.length;\n\t\tfinal int n = a.length;\n\t\tfinal\
    \ var c = a.clone();\n\t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c,\
    \ 0, b, 0, n);\n\t}\n\tprotected static final void swap(final boolean[] a, final\
    \ boolean[] b) {\n\t\tassert a.length == b.length;\n\t\tfinal int n = a.length;\n\
    \t\tfinal var c = a.clone();\n\t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c,\
    \ 0, b, 0, n);\n\t}\n\tprotected static final void swap(final Object[] a, final\
    \ Object[] b) {\n\t\tassert a.length == b.length;\n\t\tfinal int n = a.length;\n\
    \t\tfinal var c = a.clone();\n\t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c,\
    \ 0, b, 0, n);\n\t}\n\tprotected static final <F, S> List<F> first(final List<Pair<F,\
    \ S>> p){ return p.stream().map(i -> i.first).collect(Collectors.toList()); }\n\
    \tprotected static final <F, S> List<S> second(final List<Pair<F, S>> p){ return\
    \ p.stream().map(i -> i.second).collect(Collectors.toList()); }\n\tprotected static\
    \ final int[] iota(final int n){ return IntStream.range(0, n).toArray(); }\n\t\
    protected static final int[] iota(final int n, final int init){ return IntStream.range(0\
    \ + init, n + init).toArray(); }\n\tprotected static final int bins(int ok, int\
    \ ng, final IntPredicate fn) {\n\t\twhile(Math.abs(ok - ng) > 1) {\n\t\t\tfinal\
    \ int mid = (ok + ng) / 2;\n\t\t\tif(fn.test(mid)) {\n\t\t\t\tok = mid;\n\t\t\t\
    }\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tprotected\
    \ static final long bins(long ok, long ng, final LongPredicate fn) {\n\t\twhile(Math.abs(ok\
    \ - ng) > 1) {\n\t\t\tfinal long mid = (ok + ng) / 2;\n\t\t\tif(fn.test(mid))\
    \ {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t\
    }\n\t\treturn ok;\n\t}\n\tprotected static final double bins(double ok, double\
    \ ng, final DoublePredicate fn) {\n\t\twhile(Math.abs(ok - ng) > VvyLw.eps) {\n\
    \t\t\tfinal double mid = (ok + ng) / 2;\n\t\t\tif(fn.test(mid)) {\n\t\t\t\tok\
    \ = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ ok;\n\t}\n\tprotected static final int[] press(final int[] a) {\n\t\tfinal int[]\
    \ res = new int[a.length];\n\t\tfinal var x = Arrays.stream(a).sorted().distinct().toArray();\n\
    \t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres[i] = lowerBound(x, a[i]);\n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final int[] press(final long[]\
    \ a) {\n\t\tfinal int[] res = new int[a.length];\n\t\tfinal var x = Arrays.stream(a).sorted().distinct().toArray();\n\
    \t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres[i] = lowerBound(x, a[i]);\n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final int[] zAlgorithm(final String\
    \ s) {\n\t\tfinal int n = s.length();\n\t\tint j = 0;\n\t\tfinal int[] pre = new\
    \ int[n];\n\t\tfor(int i = 0; ++i < n;) {\n\t\t\tif(i + pre[i - j] < j + pre[j])\
    \ {\n\t\t\t\tpre[i] = pre[i - j];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k = Math.max(0,\
    \ j + pre[j] - i);\n\t\t\t\twhile(i + k < n && s.charAt(k) == s.charAt(i + k))\
    \ {\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\t\tpre[i] = k;\n\t\t\t\tj = i;\n\t\t\t}\n\
    \t\t}\n\t\tpre[0] = n;\n\t\treturn pre;\n\t}\n\tprotected static final int[] manacher(final\
    \ String s_, final boolean calcEven) {\n\t\tint n = s_.length();\n\t\tfinal char[]\
    \ s;\n\t\tif(calcEven) {\n\t\t\ts = new char[2 * n - 1];\n\t\t\tIntStream.range(0,\
    \ n).forEach(i -> s[i] = s_.charAt(i));\n\t\t\tfor(int i = n; --i >= 0;) {\n\t\
    \t\t\ts[2 * i] = s_.charAt(i);\n\t\t\t}\n\t\t\tfinal var d = Collections.min(s_.chars().mapToObj(c\
    \ -> (char) c).collect(Collectors.toList()));\n\t\t\tfor(int i = 0; i < n - 1;\
    \ ++i) {\n\t\t\t\ts[2 * i + 1] = d;\n\t\t\t}\n\t\t} else {\n\t\t\ts = new char[n];\n\
    \t\t\tIntStream.range(0, n).forEach(i -> s[i] = s_.charAt(i));\n\t\t}\n\t\tn =\
    \ s.length;\n\t\tfinal int[] rad = new int[n];\n\t\tfor(int i = 0, j = 0; i <\
    \ n;) {\n\t\t\twhile(i - j >= 0 && i + j < n && s[i - j] == s[i + j]) {\n\t\t\t\
    \t++j;\n\t\t\t}\n\t\t\trad[i] = j;\n\t\t\tint k = 1;\n\t\t\twhile(i - k >= 0 &&\
    \ i + k < n && k + rad[i - k] < j) {\n\t\t\t\trad[i + k] = rad[i - k];\n\t\t\t\
    \t++k;\n\t\t\t}\n\t\t\ti += k;\n\t\t\tj -= k;\n\t\t}\n\t\tif(calcEven) {\n\t\t\
    \tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(((i ^ rad[i]) & 1) == 0) {\n\t\t\t\t\
    \trad[i]--;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor(var x: rad) {\n\t\t\t\
    \tx = 2 * x - 1;\n\t\t\t}\n\t\t}\n\t\treturn rad;\n\t}\n\tprotected static final\
    \ long kthRoot(final long n, final int k) {\n\t\tif(k == 1) {\n\t\t\treturn n;\n\
    \t\t}\n\t\tfinal LongPredicate chk = x -> {\n\t\t\tlong mul = 1;\n\t\t\tfor(int\
    \ j = 0; j < k; ++j) {\n\t\t\t\ttry {\n\t\t\t\t\tmul = Math.multiplyExact(mul,\
    \ x);\n\t\t\t\t} catch(ArithmeticException e) {\n\t\t\t\t\treturn false;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\treturn mul <= n;\n\t\t};\n\t\tlong ret = 0;\n\t\tfor(int\
    \ i = 32; --i >= 0;) {\n\t\t\tif(chk.test(ret | (1L << i))) {\n\t\t\t\tret |=\
    \ 1L << i;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tprotected static final long\
    \ tetration(final long a, final long b, final long m) {\n\t\tif(m == 1) {\n\t\t\
    \treturn 0;\n\t\t}\n\t\tif(a == 0) {\n\t\t\treturn (b & 1) == 0 ? 1 : 0;\n\t\t\
    }\n\t\tif(b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(b == 1) {\n\t\t\treturn a\
    \ % m;\n\t\t}\n\t\tif(b == 2) {\n\t\t\treturn pow(a, a, m);\n\t\t}\n\t\tfinal\
    \ var phi = eulerPhi(m);\n\t\tvar tmp = tetration(a, b - 1, phi);\n\t\tif(tmp\
    \ == 0) {\n\t\t\ttmp += phi;\n\t\t}\n\t\treturn pow(a, tmp, m);\n\t}\n\tprotected\
    \ interface TriFunction<T, U, V, W> {\n\t\tpublic W apply(final T a, final U b,\
    \ final V c);\n\t}\n\tprotected interface QuadFunction<A, B, C, D, E> {\n\t\t\
    public E apply(final A a, final B b, final C c, final D d);\n\t}\n}\n\nfinal class\
    \ MyScanner {\n\tprivate final Scanner sc = new Scanner(System.in);\n\tfinal int\
    \ ni(){ return sc.nextInt(); }\n\tfinal long nl(){ return sc.nextLong(); }\n\t\
    final double nd(){ return sc.nextDouble(); }\n\tfinal char nc(){ return ns().charAt(0);\
    \ }\n\tfinal String ns(){ return sc.next(); }\n\tfinal BigInteger nb(){ return\
    \ sc.nextBigInteger(); }\n\tfinal int[] ni(final int n) {\n\t\tfinal int[] a =\
    \ new int[n];\n\t\tIntStream.range(0, n).forEach(i -> a[i] = ni());\n\t\treturn\
    \ a;\n\t}\n\tfinal long[] nl(final int n) {\n\t\tfinal long[] a = new long[n];\n\
    \t\tIntStream.range(0, n).forEach(i -> a[i] = nl());\n\t\treturn a;\n\t}\n\tfinal\
    \ double[] nd(final int n) {\n\t\tfinal double[] a = new double[n];\n\t\tIntStream.range(0,\
    \ n).forEach(i -> a[i] = nd());\n\t\treturn a;\n\t}\n\tfinal char[] nc(final int\
    \ n) {\n\t\tfinal char[] a = new char[n];\n\t\tIntStream.range(0, n).forEach(i\
    \ -> a[i] = nc());\n\t\treturn a;\n\t}\n\tfinal String[] ns(final int n) {\n\t\
    \tfinal String[] a = new String[n];\n\t\tIntStream.range(0, n).forEach(i -> a[i]\
    \ = ns());\n\t\treturn a;\n\t}\n\tfinal BigInteger[] nb(final int n) {\n\t\tfinal\
    \ BigInteger[] a = new BigInteger[n];\n\t\tIntStream.range(0, n).forEach(i ->\
    \ a[i] = nb());\n\t\treturn a;\n\t}\n\tfinal int[][] ni(final int h, final int\
    \ w) {\n\t\tfinal int[][] a = new int[h][w];\n\t\tIntStream.range(0, h).forEach(i\
    \ -> a[i] = ni(w));\n\t\treturn a;\n\t}\n\tfinal long[][] nl(final int h, final\
    \ int w) {\n\t\tfinal long[][] a = new long[h][w];\n\t\tIntStream.range(0, h).forEach(i\
    \ -> a[i] = nl(w));\n\t\treturn a;\n\t}\n\tfinal double[][] nd(final int h, final\
    \ int w) {\n\t\tfinal double[][] a = new double[h][w];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> a[i] = nd(w));\n\t\treturn a;\n\t}\n\tfinal char[][] nc(final\
    \ int h, final int w) {\n\t\tfinal char[][] a = new char[h][w];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> a[i] = nc(w));\n\t\treturn a;\n\t}\n\tfinal String[][] ns(final\
    \ int h, final int w) {\n\t\tfinal String[][] a = new String[h][w];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> a[i] = ns(w));\n\t\treturn a;\n\t}\n\tfinal BigInteger[][] nb(final\
    \ int h, final int w) {\n\t\tfinal BigInteger[][] a = new BigInteger[h][w];\n\t\
    \tIntStream.range(0, h).forEach(i -> a[i] = nb(w));\n\t\treturn a;\n\t}\n\tfinal\
    \ void close(){ sc.close(); }\n}\n\nfinal class MyPrinter extends PrintWriter\
    \ {\n\tMyPrinter(final OutputStream os, final boolean flush){ super(os, flush);\
    \ }\n\tfinal void out(){ println(); }\n\tfinal void out(final Object head, final\
    \ Object... tail) {\n\t\tprint(head);\n\t\tfor(final var el: tail) {\n\t\t\tprint(\"\
    \ \" + el);\n\t\t}\n\t\tout();\n\t}\n\tfinal <F, S> void out(final Pair<F, S>\
    \ arg){ println(arg.first + \" \" + arg.second); }\n\tfinal void out(final int[]\
    \ args){ IntStream.range(0, args.length).forEach(i -> print(args[i] + (i + 1 <\
    \ args.length ? \" \" : \"\\n\"))); }\n\tfinal void out(final long[] args){ IntStream.range(0,\
    \ args.length).forEach(i -> print(args[i] + (i + 1 < args.length ? \" \" : \"\\\
    n\"))); }\n\tfinal void out(final double[] args){ IntStream.range(0, args.length).forEach(i\
    \ -> print(args[i] + (i + 1 < args.length ? \" \" : \"\\n\"))); }\n\tfinal void\
    \ out(final boolean[] args){ IntStream.range(0, args.length).forEach(i -> print(args[i]\
    \ + (i + 1 < args.length ? \" \" : \"\\n\"))); }\n\tfinal void out(final char[]\
    \ args){ IntStream.range(0, args.length).forEach(i -> print(args[i] + (i + 1 <\
    \ args.length ? \" \" : \"\\n\"))); }\n\tfinal void out(final Object[] args){\
    \ IntStream.range(0, args.length).forEach(i -> print(args[i] + (i + 1 < args.length\
    \ ? \" \" : \"\\n\"))); }\n\tfinal <T> void out(final List<T> args){ IntStream.range(0,\
    \ args.size()).forEach(i -> print(args.get(i) + (i + 1 < args.size() ? \" \" :\
    \ \"\\n\"))); }\n\tfinal void outl(final Object head, final Object... tail) {\n\
    \t\tout(head);\n\t\tArrays.stream(tail).forEach(this::println);\n\t}\n\tfinal\
    \ void outl(final int[] args){ Arrays.stream(args).forEach(this::println); }\n\
    \tfinal void outl(final int[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> out(args[i])); }\n\tfinal void outl(final long[] args){ Arrays.stream(args).forEach(this::println);\
    \ }\n\tfinal void outl(final long[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> out(args[i])); }\n\tfinal void outl(final double[] args){ Arrays.stream(args).forEach(this::println);\
    \ }\n\tfinal void outl(final double[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> out(args[i])); }\n\tfinal void outl(final boolean[] args){ IntStream.range(0,\
    \ args.length).forEach(i -> out(args[i])); }\n\tfinal void outl(final boolean[][]\
    \ args){ IntStream.range(0, args.length).forEach(i -> out(args[i])); }\n\tfinal\
    \ void outl(final char[] args){ IntStream.range(0, args.length).forEach(i -> out(args[i]));\
    \ }\n\tfinal void outl(final Object[] args){ Arrays.stream(args).forEach(this::println);\
    \ }\n\tfinal <E> void outl(final Collection<E> args){ args.stream().forEach(this::println);\
    \ }\n\tfinal void fin(final Object head, final Object... tail) {\n\t\tout(head,\
    \ tail);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final int[]\
    \ args) {\n\t\tout(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n\tfinal void\
    \ fin(final long[] args) {\n\t\tout(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\
    \t}\n\tfinal void fin(final double[] args) {\n\t\tout(args);\n\t\tflush();\n\t\
    \tSystem.exit(0);\n\t}\n\tfinal void fin(final boolean[] args) {\n\t\tout(args);\n\
    \t\tflush();\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final char[] args) {\n\
    \t\tout(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final\
    \ Object[] args) {\n\t\tout(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n\t\
    final <T> void fin(final List<T> args) {\n\t\tout(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\
    \t}\n\tfinal void ende(final int[] args) {\n\t\toutl(args);\n\t\tflush();\n\t\t\
    System.exit(0);\n\t}\n\tfinal void ende(final long[] args) {\n\t\toutl(args);\n\
    \t\tflush();\n\t\tSystem.exit(0);\n\t}\n\tfinal void ende(final double[] args)\
    \ {\n\t\toutl(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n\tfinal void ende(final\
    \ boolean[] args) {\n\t\toutl(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n\
    \tfinal void ende(final char[] args) {\n\t\toutl(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\
    \t}\n\tfinal void ende(final Object[] args) {\n\t\toutl(args);\n\t\tflush();\n\
    \t\tSystem.exit(0);\n\t}\n\tfinal <E> void ende(final Collection<E> args) {\n\t\
    \toutl(args);\n\t\tflush();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Pair<F, S> {\n\
    \tprotected final F first;\n\tprotected final S second;\n\tPair(final F first,\
    \ final S second) {\n\t\tthis.first = first;\n\t\tthis.second = second;\n\t}\n\
    \t@Override\n\tpublic final boolean equals(final Object o) {\n\t\tif(this == o)\
    \ {\n\t\t\treturn true;\n\t\t}\n\t\tif(o == null || getClass() != o.getClass())\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tfinal Pair<?, ?> p = (Pair<?, ?>) o;\n\t\t\
    if(!first.equals(p.first)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn second.equals(p.second);\n\
    \t}\n\t@Override\n\tpublic final int hashCode(){ return 31 * first.hashCode()\
    \ + second.hashCode(); }\n\t@Override\n\tpublic final String toString(){ return\
    \ \"(\" + first + \", \" + second + \")\"; }\n\tpublic static final <F, S> Pair<F,\
    \ S> of(final F a, final S b){ return new Pair<>(a, b); }\n\tfinal Pair<S, F>\
    \ swap(){ return Pair.of(second, first); }\n}\nfinal class NumPair extends Pair<Number,\
    \ Number> implements Comparable<NumPair>  {\n\tNumPair(final Number first, final\
    \ Number second){ super(first, second); }\n\tfinal NumPair rotate(){ return new\
    \ NumPair(-second.doubleValue(), first.doubleValue()); } \n\tfinal NumPair rotate(final\
    \ int ang) {\n\t\tfinal double rad = Math.toRadians(Utility.mod(ang, 360));\n\t\
    \treturn new NumPair(first.doubleValue() * Math.cos(rad) - second.doubleValue()\
    \ * Math.sin(rad),\n\t\t\t\t\t\t\tfirst.doubleValue() * Math.sin(rad) + second.doubleValue()\
    \ * Math.cos(rad));\n\t}\n\tfinal long dot(final NumPair p){ return first.longValue()\
    \ * p.first.longValue() + second.longValue() + p.second.longValue(); }\n\tfinal\
    \ double dotf(final NumPair p){ return first.doubleValue() * p.first.doubleValue()\
    \ + second.doubleValue() + p.second.doubleValue(); }\n\tfinal long cross(final\
    \ NumPair p){ return rotate().dot(p); }\n\tfinal double crossf(final NumPair p){\
    \ return rotate().dotf(p); }\n\tfinal long sqr(){ return dot(this); }\n\tfinal\
    \ double sqrf(){ return dotf(this); }\n\tfinal double grad() { \n\t\ttry {\n\t\
    \t\treturn second.doubleValue() / first.doubleValue();\n\t\t} catch(ArithmeticException\
    \ e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn Double.NaN;\n\t}\n\tfinal\
    \ double abs(){ return Math.hypot(first.doubleValue(), second.doubleValue());\
    \ }\n\tfinal long lcm(){ return Utility.lcm(first.longValue(), second.longValue());\
    \ }\n\tfinal long gcd(){ return Utility.gcd(first.longValue(), second.longValue());\
    \ }\n\tfinal NumPair extgcd() {\n\t\tlong x = 1, y = 0, t1 = 0, t2 = 0, t3 = 1,\
    \ a = first.longValue(), b = second.longValue();\n\t\twhile(b > 0) {\n\t\t\tt1\
    \ = a / b;\n\t\t\ta -= t1 * b;\n\t\t\ta ^= b;\n\t\t\tb ^= a;\n\t\t\ta ^= b;\n\t\
    \t\tx -= t1 * t2;\n\t\t\tx ^= t2;\n\t\t\tt2 ^= x;\n\t\t\tx ^= t2;\n\t\t\ty -=\
    \ t1 * t3;\n\t\t\ty ^= t3;\n\t\t\tt3 ^= y;\n\t\t\ty ^= t3;\n\t\t}\n\t\treturn\
    \ new NumPair(x, y);\n\t}\n\t@Override\n\tfinal public int compareTo(final NumPair\
    \ o) {\n\t\tif(first.doubleValue() == o.first.doubleValue()) {\n\t\t\treturn Double.compare(second.doubleValue(),\
    \ o.second.doubleValue());\n\t\t}\n\t\treturn Double.compare(first.doubleValue(),\
    \ o.first.doubleValue());\n\t}\n}\n\nfinal class Huitloxopetl {\n\tfinal long\
    \ invNum(final int[] a) {\n\t\tfinal var b = Utility.sorted(a);\n\t\tfinal var\
    \ id = new int[a.length];\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tid[b[i]]\
    \ = i;\n\t\t}\n\t\tfinal var bit = new FenwickTree(a.length);\n\t\tlong res =\
    \ 0;\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres += i - bit.sum(id[a[i]]);\n\
    \t\t\tbit.add(id[a[i]], 1);\n\t\t}\n\t\treturn res;\n\t}\n\tfinal long invNum(final\
    \ long[] a) {\n\t\tfinal var b = Utility.sorted(a);\n\t\tfinal var id = new HashMap<Long,\
    \ Integer>();\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tid.put(b[i], i);\n\
    \t\t}\n\t\tfinal var bit = new FenwickTree(a.length);\n\t\tlong res = 0;\n\t\t\
    for(int i = 0; i < a.length; ++i) {\n\t\t\tres += i - bit.sum(id.get(a[i]));\n\
    \t\t\tbit.add(id.get(a[i]), 1);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nfinal class\
    \ UnionFind {\n\tprivate final int[] par;\n\tUnionFind(final int n) {\n\t\tpar\
    \ = new int[n];\n\t\tArrays.fill(par, -1);\n\t}\n\tfinal int root(final int i){\
    \ return par[i] >= 0 ? par[i] = root(par[i]) : i; }\n\tfinal int size(final int\
    \ i){ return -par[root(i)]; }\n\tfinal boolean unite(int i, int j) {\n\t\ti =\
    \ root(i);\n\t\tj = root(j);\n\t\tif(i == j) return false;\n\t\tif(i > j) {\n\t\
    \t\ti ^= j;\n\t\t\tj ^= i;\n\t\t\ti ^= j;\n\t\t}\n\t\tpar[i] += par[j];\n\t\t\
    par[j] = i;\n\t\treturn true;\n\t}\n\tfinal boolean same(final int i, final int\
    \ j){ return root(i) == root(j); }\n\tfinal ArrayList<ArrayList<Integer>> groups()\
    \ {\n\t\tfinal int n = par.length;\n\t\tArrayList<ArrayList<Integer>> res = new\
    \ ArrayList<>(n);\n\t\tIntStream.range(0, n).forEach(i -> res.add(new ArrayList<>()));\n\
    \t\tIntStream.range(0, n).forEach(i -> res.get(root(i)).add(i));\n\t\tres.removeIf(ArrayList::isEmpty);\n\
    \t\treturn res;\n\t}\n\tfinal boolean isBipartite() {\n\t\tfinal int n = par.length\
    \ / 2;\n\t\tboolean ok = true;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tok &=\
    \ root(i) != root(i + n);\n\t\t}\n\t\treturn ok;\n\t}\n}\n\nfinal class WeightedUnionFind\
    \ {\n\tprivate final int[] par;\n\tprivate final long[] weight;\n\tWeightedUnionFind(final\
    \ int n) {\n\t\tpar = new int[n];\n\t\tweight = new long[n];\n\t\tArrays.fill(par,\
    \ -1);\n\t}\n\tfinal int root(final int i) {\n\t\tif(par[i] < 0) {\n\t\t\treturn\
    \ i;\n\t\t}\n\t\tfinal int r = root(par[i]);\n\t\tweight[i] += weight[par[i]];\n\
    \t\treturn par[i] = r;\n\t}\n\tfinal long get(final int i) {\n\t\troot(i);\n\t\
    \treturn weight[i];\n\t}\n\tfinal long diff(final int x, final int y){ return\
    \ get(y) - get(x); }\n\tfinal int unite(int x, int y, long w) {\n\t\tw += diff(y,\
    \ x);\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x == y) {\n\t\t\treturn w ==\
    \ 0 ? 0 : -1;\n\t\t}\n\t\tif(par[x] > par[y]) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\
    \t\t\tx ^= y;\n\t\t\tw = -w;\n\t\t}\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\
    \tweight[y] = w;\n\t\treturn 1;\n\t}\n\tfinal boolean same(final int x, final\
    \ int y){ return root(x) == root(y); }\n}\n\nfinal class UndoUnionFind {\n\tprivate\
    \ final int[] par;\n\tprivate final Stack<Pair<Integer, Integer>> his;\n\tUndoUnionFind(final\
    \ int n) {\n\t    par = new int[n];\n\t    Arrays.fill(par, -1);\n\t    his =\
    \ new Stack<>();\n\t}\n\tfinal boolean unite(int x, int y) {\n\t\tx = root(x);\n\
    \t\ty = root(y);\n\t\this.add(Pair.of(x, par[x]));\n\t\this.add(Pair.of(y, par[y]));\n\
    \t\tif(x == y) {\n\t\t\treturn false;\n\t\t}\n\t\tif(par[x] > par[y]) {\n\t\t\t\
    x ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tpar[x] += par[y];\n\t\tpar[y]\
    \ = x;\n\t\treturn true;\n\t}\n\tfinal int root(final int i) {\n\t\tif(par[i]\
    \ < 0) {\n\t\t\treturn i;\n\t\t}\n\t\treturn root(par[i]);\n\t}\n\tfinal int size(final\
    \ int i){ return -par[root(i)]; }\n\tfinal void undo() {\n\t\tfinal Pair<Integer,\
    \ Integer> pop1 = his.pop(), pop2 = his.pop();\n\t\tpar[pop1.first] = pop1.second;\n\
    \t\tpar[pop2.first] = pop2.second;\n\t}\n\tfinal void snapshot() {\n\t\twhile(!his.empty())\
    \ {\n\t\t\this.pop();\n\t\t}\n\t}\n\tfinal void rollback() {\n\t\twhile(!his.empty())\
    \ {\n\t\t\tundo();\n\t\t}\n\t}\n}\n\nfinal class Edge {\n\tpublic int src;\n\t\
    public int to;\n\tpublic long cost;\n\tEdge(final int to) {\n\t\tthis.to = to;\n\
    \t}\n\tEdge(final int to, final long cost) {\n\t\tthis.to = to;\n\t\tthis.cost\
    \ = cost;\n\t}\n\tEdge(final int src, final int to, final long cost) {\n\t\tthis.src\
    \ = src;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\t@Override\n\tpublic\
    \ final boolean equals(final Object o) {\n\t\tif(this == o) {\n\t\t\treturn true;\n\
    \t\t}\n\t\tif(o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\
    \t\t}\n\t\tfinal Edge e = (Edge) o;\n\t\tif(src != e.src) {\n\t\t\treturn false;\n\
    \t\t}\n\t\tif(to != e.to) {\n\t\t\treturn false;\n\t\t}\n\t\treturn cost == e.cost;\n\
    \t}\n\t@Override\n\tpublic final int hashCode() {\n\t\tint result = 17;\n\t\t\
    result = 31 * result + src;\n\t\tresult = 31 * result + to;\n\t\tresult = 31 *\
    \ result + (int) (cost ^ (cost >>> 32)); // XOR for long values\n\t\treturn result;\n\
    \t}\n\t@Override\n\tpublic final String toString(){ return \"(\" + src + \", \"\
    \ + to + \", \" + cost + \")\"; }\n}\nclass Graph extends ArrayList<ArrayList<Edge>>\
    \ {\n\tprotected final boolean undirected;\n\tprotected final int n, indexed;\n\
    \tprotected final ArrayList<Edge> edge;\n\tGraph(final int n, final int indexed,\
    \ final boolean undirected) {\n\t\tthis.n = n;\n\t\tthis.indexed = indexed;\n\t\
    \tthis.undirected = undirected;\n\t\tedge = new ArrayList<>();\n\t\tIntStream.range(0,\
    \ n).forEach(i -> this.add(new ArrayList<>()));\n\t}\n\tfinal void addEdge(int\
    \ a, int b) {\n\t\ta -= indexed;\n\t\tb -= indexed;\n\t\tthis.get(a).add(new Edge(b));\n\
    \t\tedge.add(new Edge(a, b, 0));\n\t\tif(undirected) {\n\t\t\tthis.get(b).add(new\
    \ Edge(a));\n\t\t\tedge.add(new Edge(b, a, 0));\n\t\t}\n\t}\n\tvoid input(final\
    \ int m){ IntStream.range(0, m).forEach(i -> addEdge(VvyLw.sc.ni(), VvyLw.sc.ni()));\
    \ }\n\tprotected final int[] allDist(final int v) {\n\t\tfinal int[] d = new int[n];\n\
    \t\tArrays.fill(d, -1);\n\t\tfinal Queue<Integer> q = new ArrayDeque<>();\n\t\t\
    d[v] = 0;\n\t\tq.add(v);\n\t\twhile(!q.isEmpty()) {\n\t\t\tfinal int tmp = q.poll();\n\
    \t\t\tfor(final var el: this.get(tmp)) {\n\t\t\t\tif(d[el.to] != -1) {\n\t\t\t\
    \t\tcontinue;\n\t\t\t\t}\n\t\t\t\td[el.to] = d[tmp] + 1;\n\t\t\t\tq.add(el.to);\n\
    \t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tprotected final int dist(final int u, final\
    \ int v){ return allDist(u)[v]; }\n\tprotected final ArrayList<Integer> topologicalSort()\
    \ {\n\t\tfinal int[] deg = new int[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\
    \tfor(final var ed: this.get(i)) {\n\t\t\t\tdeg[ed.to]++;\n\t\t\t}\n\t\t}\n\t\t\
    final var sk = new Stack<Integer>();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\
    if(deg[i] == 0) {\n\t\t\t\tsk.add(i);\n\t\t\t}\n\t\t}\n\t\tfinal var ord = new\
    \ ArrayList<Integer>();\n\t\twhile(!sk.isEmpty()) {\n\t\t\tfinal var tmp = sk.pop();\n\
    \t\t\tord.add(tmp);\n\t\t\tfor(final var ed: this.get(tmp)) {\n\t\t\t\tif(--deg[ed.to]\
    \ == 0) {\n\t\t\t\t\tsk.add(ed.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ord.size()\
    \ == size() ? ord : new ArrayList<>();\n\t}\n}\n\nfinal class MST {\n\tpublic\
    \ final ArrayList<Edge> tree;\n\tpublic final long cost;\n\tMST(final ArrayList<Edge>\
    \ tree, final long cost) {\n\t\tthis.tree = tree;\n\t\tthis.cost = cost;\n\t}\n\
    }\nfinal class WeightedGraph extends Graph {\n\tWeightedGraph(final int n, final\
    \ int indexed, final boolean undirected){ super(n, indexed, undirected); }\n\t\
    final void addEdge(int a, int b, final long cost) {\n\t\ta -= indexed;\n\t\tb\
    \ -= indexed;\n\t\tthis.get(a).add(new Edge(b, cost));\n\t\tedge.add(new Edge(a,\
    \ b, cost));\n\t\tif(undirected) {\n\t\t\tthis.get(b).add(new Edge(a, cost));\n\
    \t\t\tedge.add(new Edge(b, a, cost));\n\t\t}\n\t}\n\tfinal void input(final int\
    \ m){ IntStream.range(0, m).forEach(i -> addEdge(VvyLw.sc.ni(), VvyLw.sc.ni(),\
    \ VvyLw.sc.ni())); }\n\tfinal long[] dijkstra(final int v) {\n\t\tfinal long[]\
    \ cost = new long[n];\n\t\tArrays.fill(cost, Long.MAX_VALUE);\n\t\tfinal Queue<NumPair>\
    \ dj = new PriorityQueue<>();\n\t\tcost[v] = 0;\n\t\tdj.add(new NumPair(cost[v],\
    \ v));\n\t\twhile(!dj.isEmpty()) {\n\t\t\tfinal var tmp = dj.poll();\n\t\t\tif(cost[tmp.second.intValue()]\
    \ < tmp.first.longValue()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(final var\
    \ el: this.get(tmp.second.intValue())) {\n\t\t\t\tif(cost[el.to] > tmp.first.longValue()\
    \ + el.cost) {\n\t\t\t\t\tcost[el.to] = tmp.first.longValue() + el.cost;\n\t\t\
    \t\t\tdj.add(new NumPair(cost[el.to], el.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\
    return cost;\n\t}\n\tfinal long[] bellmanFord(final int v) {\n\t\tfinal long[]\
    \ cost = new long[n];\n\t\tArrays.fill(cost, Long.MAX_VALUE);\n\t\tcost[v] = 0;\n\
    \t\tfor(int i = 0; i < edge.size() - 1; ++i) {\n\t\t\tfor(final var e: edge) {\n\
    \t\t\t\tif(cost[e.src] == Long.MAX_VALUE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\
    \t\t\tif(cost[e.to] > cost[e.src] + e.cost) {\n\t\t\t\t\tcost[e.to] = cost[e.src]\
    \ + e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(final var e: edge) {\n\t\t\tif(cost[e.src]\
    \ == Long.MAX_VALUE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(cost[e.src] + e.cost\
    \ < cost[e.to]) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t\
    }\n\tfinal long[][] warshallFloyd() {\n\t\tfinal long[][] cost = new long[n][n];\n\
    \t\tIntStream.range(0, n).forEach(i -> Arrays.fill(cost[i], VvyLw.linf));\n\t\t\
    IntStream.range(0, n).forEach(i -> cost[i][i] = 0);\n\t\tfor(int i = 0; i < n;\
    \ ++i) {\n\t\t\tfor(final var j: this.get(i)) {\n\t\t\t\tcost[i][j.to] = j.cost;\n\
    \t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; ++k) {\n\t\t\tfor(int i = 0; i < n;\
    \ ++i) {\n\t\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\t\tif(cost[i][k] == VvyLw.linf\
    \ || cost[k][j] == VvyLw.linf) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\
    \tif(cost[i][j] > cost[i][k] + cost[k][j]) {\n\t\t\t\t\t\tcost[i][j] = cost[i][k]\
    \ + cost[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t\
    }\n\tfinal MST kruskal() {\n\t\tfinal UnionFind uf = new UnionFind(n);\n\t\tfinal\
    \ var e = new ArrayList<Edge>();\n\t\tlong res = 0;\n\t\tfor(final var ed: edge.stream().sorted(Comparator.comparing(ed\
    \ -> ed.cost)).collect(Collectors.toList())) {\n\t\t\tif(uf.unite(ed.src, ed.to))\
    \ {\n\t\t\t\te.add(ed);\n\t\t\t\tres += ed.cost;\n\t\t\t}\n\t\t}\n\t\treturn new\
    \ MST(e, res);\n\t}\n\tfinal MST directed(final int v) {\n\t\t@SuppressWarnings(\"\
    unchecked\")\n\t\tfinal var ed = (ArrayList<Edge>) edge.clone();\n\t\tfor(int\
    \ i = 0; i < n; ++i) {\n\t\t\tif(i != v) {\n\t\t\t\ted.add(new Edge(i, v, 0));\n\
    \t\t\t}\n\t\t}\n\t\tint x = 0;\n\t\tfinal int[] par = new int[2 * n], vis = new\
    \ int[2 * n], link = new int[2 * n];\n\t\tArrays.fill(par, -1);\n\t\tArrays.fill(vis,\
    \ -1);\n\t\tArrays.fill(link, -1);\n\t\tfinal var heap = new SkewHeap(true);\n\
    \t\tfinal var ins = new SkewHeap.Node[2 * n];\n\t\tArrays.fill(ins, null);\n\t\
    \tfor(int i = 0; i < ed.size(); i++) {\n\t\t\tfinal var e = ed.get(i);\n\t\t\t\
    ins[e.to] = heap.push(ins[e.to], e.cost, i);\n\t\t}\n\t\tfinal var st = new ArrayList<Integer>();\n\
    \t\tfinal Function<Integer, Integer> go = z -> {\n\t\t\tz = ed.get(ins[z].idx).src;\n\
    \t\t\twhile(link[z] != -1) {\n\t\t\t\tst.add(z);\n\t\t\t\tz = link[z];\n\t\t\t\
    }\n\t\t\tfor(final var p: st) {\n\t\t\t\tlink[p] = z;\n\t\t\t}\n\t\t\tst.clear();\n\
    \t\t\treturn z;\n\t\t};\n\t\tfor(int i = n; ins[x] != null; ++i) {\n\t\t\twhile(vis[x]\
    \ == -1) {\n\t\t\t\tvis[x] = 0;\n\t\t\t\tx = go.apply(x);\n\t\t\t}\n\t\t\twhile(x\
    \ != i) {\n\t\t\t\tfinal var w = ins[x].key;\n\t\t\t\tvar z = heap.pop(ins[x]);\n\
    \t\t\t\tz = heap.add(z, -w);\n\t\t\t\tins[i] = heap.meld(ins[i], z);\n\t\t\t\t\
    par[x] = i;\n\t\t\t\tlink[x] = i;\n\t\t\t\tx = go.apply(x);\n\t\t\t}\n\t\t\twhile(ins[x]\
    \ != null && go.apply(x) == x) {\n\t\t\t\tins[x] = heap.pop(ins[x]);\n\t\t\t}\n\
    \t\t}\n\t\tfor(int i = v; i != -1; i = par[i]) {\n\t\t\tvis[i] = 1;\n\t\t}\n\t\
    \tlong cost = 0;\n\t\tArrayList<Edge> e = new ArrayList<>();\n\t\tfor(int i =\
    \ x; i >= 0; i--) {\n\t\t\tif(vis[i] == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\
    \tcost += ed.get(ins[i].idx).cost;\n\t\t\te.add(ed.get(ins[i].idx));\n\t\t\tfor(int\
    \ j = ed.get(ins[i].idx).to; j != -1 && vis[j] == 0; j = par[j]) {\n\t\t\t\tvis[j]\
    \ = 1;\n\t\t\t}\n\t\t}\n\t\treturn new MST(e, cost);\n\t}\n}\nfinal class SkewHeap\
    \ {\n\tstatic final class Node {\n\t\tlong key, lazy;\n\t\tNode l, r;\n\t\tfinal\
    \ int idx;\n\t\tNode(final long key, final int idx) {\n\t\t\tthis.key = key;\n\
    \t\t\tthis.idx = idx;\n\t\t\tlazy = 0;\n\t\t\tl = null;\n\t\t\tr = null;\n\t\t\
    }\n\t}\n\tprivate final boolean isMin;\n\tSkewHeap(final boolean isMin){ this.isMin\
    \ = isMin; }\n\tprivate final Node alloc(final long key, final int idx){ return\
    \ new Node(key, idx); }\n\tprivate final Node propagate(final Node t) {\n\t\t\
    if(t != null && t.lazy != 0) {\n\t\t\tif(t.l != null) {\n\t\t\t\tt.l.lazy += t.lazy;\n\
    \t\t\t}\n\t\t\tif(t.r != null) {\n\t\t\t\tt.r.lazy += t.lazy;\n\t\t\t}\n\t\t\t\
    t.key += t.lazy;\n\t\t\tt.lazy = 0;\n\t\t}\n\t\treturn t;\n\t}\n\tfinal Node meld(Node\
    \ x, Node y) {\n\t\tpropagate(x);\n\t\tpropagate(y);\n\t\tif(x == null || y ==\
    \ null) {\n\t\t\treturn x != null ? x : y;\n\t\t}\n\t\tif((x.key < y.key) ^ isMin)\
    \ {\n\t\t\tfinal var tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\t\tx.r =\
    \ meld(y, x.r);\n\t\tfinal var tmp = x.l;\n\t\tx.l = x.r;\n\t\tx.r = tmp;\n\t\t\
    return x;\n\t}\n\tfinal Node push(final Node t, final long key, int idx){ return\
    \ meld(t, alloc(key, idx)); }\n\tfinal Node pop(final Node t) {\n\t\tif(t == null)\
    \ {\n\t\t\tthrow new NullPointerException();\n\t\t}\n\t\treturn meld(t.l, t.r);\n\
    \t}\n\tfinal Node add(Node t, final long lazy) {\n\t\tif(t != null) {\n\t\t\t\
    t.lazy += lazy;\n\t\t\tpropagate(t);\n\t\t}\n\t\treturn t;\n\t}\n}\n\nfinal class\
    \ LowestCommonAncestor<G extends Graph> {\n\tprivate final int log;\n\tfinal int[]\
    \ dep, sum;\n\tprivate final G g;\n\tfinal int[][] table;\n\tLowestCommonAncestor(final\
    \ G g) {\n\t\tthis.g = g;\n\t\tfinal int n = g.size();\n\t\tdep = new int[n];\n\
    \t\tsum = new int[n];\n\t\tlog = Integer.toBinaryString(n).length();\n\t\ttable\
    \ = new int[log][n];\n\t\tIntStream.range(0, log).forEach(i -> Arrays.fill(table[i],\
    \ -1));\n\t\tbuild();\n\t}\n\tprivate final void dfs(final int idx, final int\
    \ par, final int d) {\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor(final\
    \ var el: g.get(idx)) {\n\t\t\tif(el.to != par) {\n\t\t\t\tsum[el.to] = (int)\
    \ (sum[idx] + el.cost); \n\t\t\t\tdfs(el.to, idx, d + 1);\n\t\t\t}\n\t\t}\n\t\
    }\n\tprivate final void build() {\n\t\tdfs(0, -1, 0);\n\t\tfor(int k = 0; k <\
    \ log - 1; ++k) {\n\t\t\tfor(int i = 0; i < table[k].length; ++i) {\n\t\t\t\t\
    if(table[k][i] == -1) {\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\t} else {\n\t\
    \t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\tfinal int query(int u, int v) {\n\t\tif(dep[u] > dep[v]) {\n\t\t\tu ^= v;\n\
    \t\t\tv ^= u;\n\t\t\tu ^= v;\n\t\t}\n\t\tv = climb(v, dep[v] - dep[u]);\n\t\t\
    if(u == v) {\n\t\t\treturn u;\n\t\t}\n\t\tfor(int i = log; --i >= 0;) {\n\t\t\t\
    if(table[i][u] != table[i][v]) {\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\
    \t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n\tfinal int climb(int u, final int\
    \ k) {\n\t\tif(dep[u] < k) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int i = log; --i\
    \ >= 0;) {\n\t\t\tif(((k >> i) % 2) == 1) {\n\t\t\t\tu = table[i][u];\n\t\t\t\
    }\n\t\t}\n\t\treturn u;\n\t}\n\tfinal int dist(final int u, final int v){ return\
    \ sum[u] + sum[v] - 2 * sum[query(u, v)]; }\n}\n\nfinal class PrimeTable {\n\t\
    private final int size;\n\tprivate final int[] p;\n\tprivate final boolean[] sieve;\n\
    \tPrimeTable(final int n) {\n\t\tsieve = new boolean[n + 1];\n\t\tArrays.fill(sieve,\
    \ true);\n\t\tsieve[0] = sieve[1] = false;\n\t\tfor(long i = 2; i <= n; ++i) {\n\
    \t\t\tif(!sieve[(int) i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(long j = i\
    \ * i; j <= n; j += i) {\n\t\t\t\tsieve[(int) j] = false;\n\t\t\t}\n\t\t}\n\t\t\
    size = (int) IntStream.rangeClosed(0, n).filter(i -> sieve[i]).count();\n\t\t\
    int j = 0;\n\t\tp = new int[size];\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\t\
    if(sieve[i]) {\n\t\t\t\tp[j++] = i; \n\t\t\t}\n\t\t}\n\t}\n\tfinal boolean[] table(){\
    \ return sieve; }\n\tfinal int[] get(){ return p; }\n}\n\nfinal class PrimeFactor\
    \ {\n\tprivate final int[] spf;\n\tPrimeFactor(final int n) {\n\t\tspf = Utility.iota(n\
    \ + 1);\n\t\tfor(int i = 2; i * i <= n; ++i) {\n\t\t\tif(spf[i] == i) {\n\t\t\t\
    \tfor(int j = i * i; j <= n; j += i) {\n\t\t\t\t\tif(spf[j] == j) {\n\t\t\t\t\t\
    \tspf[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinal TreeMap<Integer,\
    \ Integer> get(int n) {\n\t\tfinal TreeMap<Integer, Integer> m = new TreeMap<>();\n\
    \t\twhile(n != 1) {\n\t\t\tm.merge(spf[n], 1, (a, b) -> (a + b));\n\t\t\tn /=\
    \ spf[n];\n\t\t}\n\t\treturn m;\n\t}\n}\n\nfinal class PrimeCounter {\n\tprivate\
    \ final int sq;\n\tprivate final boolean[] p;\n\tprivate final int[] psum;\n\t\
    private final ArrayList<Integer> ps;\n\tPrimeCounter(final long lim) {\n\t\tsq\
    \ = (int) kthRooti(lim, 2);\n\t\tpsum = new int[sq + 1];\n\t\tp = new PrimeTable(sq).table();\n\
    \t\tfor(int i = 1; i <= sq; ++i) {\n\t\t\tpsum[i] = psum[i - 1] + (p[i] ? 1 :\
    \ 0);\n\t\t}\n\t\tps = new ArrayList<>();\n\t\tfor(int i = 1; i <= sq; ++i) {\n\
    \t\t\tif(p[i]) {\n\t\t\t\tps.add(i);\n\t\t\t}\n\t\t}\n\t}\n\tprivate final long\
    \ kthRooti(final long n, final int k){ return Utility.kthRoot(n, k); }\n\tprivate\
    \ final long p2(final long x, final long y) {\n\t\tif(x < 4) {\n\t\t\treturn 0;\n\
    \t\t}\n\t\tfinal long a = pi(y);\n\t\tfinal long b = pi(kthRooti(x, 2));\n\t\t\
    if(a >= b) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong sum = (long) (a - 2) * (a + 1)\
    \ / 2 - (b - 2) * (b + 1) / 2;\n\t\tfor(long i = a; i < b; ++i) {\n\t\t\tsum +=\
    \ pi(x / ps.get((int) i));\n\t\t}\n\t\treturn sum;\n\t}\n\tprivate final long\
    \ phi(final long m, final long a) {\n\t\tif(m < 1) {\n\t\t\treturn 0;\n\t\t}\n\
    \t\tif(a > m) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(a < 1) {\n\t\t\treturn m;\n\t\t\
    }\n\t\tif(m <= (long) ps.get((int) (a - 1)) * ps.get((int) (a - 1))) {\n\t\t\t\
    return pi(m) - a + 1;\n\t\t}\n\t\tif(m <= (long) ps.get((int) (a - 1)) * ps.get((int)\
    \ (a - 1)) * ps.get((int) (a - 1)) && m <= sq) {\n\t\t\tfinal long sx = pi(kthRooti(m,\
    \ 2));\n\t\t\tlong ans = pi(m) - (long) (sx + a - 2) * (sx - a + 1) / 2;\n\t\t\
    \tfor(long i = a; i < sx; ++i) {\n\t\t\t\tans += pi(m / ps.get((int) i));\n\t\t\
    \t}\n\t\t\treturn ans;\n\t\t}\n\t\treturn phi(m, a - 1) - phi(m / ps.get((int)\
    \ (a - 1)), a - 1);\n\t}\n\tfinal long pi(final long n) {\n\t\tif(n <= sq) {\n\
    \t\t\treturn psum[(int) n];\n\t\t}\n\t\tfinal long m = kthRooti(n, 3);\n\t\tfinal\
    \ long a = pi(m);\n\t\treturn phi(n, a) + a - 1 - p2(n, m);\n\t}\n}\n\n// N <=\
    \ 1e18;\nfinal class LongPrime {\n\tprivate final int bsf(final long x){ return\
    \ Long.numberOfTrailingZeros(x); }\n\tprivate final long gcd(long a, long b) {\n\
    \t\ta = Math.abs(a);\n\t\tb = Math.abs(b);\n\t\tif(a == 0) {\n\t\t\treturn b;\n\
    \t\t}\n\t\tif(b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\tfinal int shift = bsf(a|b);\n\
    \t\ta >>= bsf(a);\n\t\tdo {\n\t\t\tb >>= bsf(b);\n\t\t\tif(a > b) {\n\t\t\t\t\
    a ^= b;\n\t\t\t\tb ^= a;\n\t\t\t\ta ^= b;\n\t\t\t}\n\t\t\tb -= a;\n\t\t} while(b\
    \ > 0);\n\t\treturn a << shift;\n\t}\n\tfinal boolean isPrime(final long n) {\n\
    \t\tif(n <= 1) {\n\t\t\treturn false;\n\t\t}\n\t\tif(n == 2) {\n\t\t\treturn true;\n\
    \t\t}\n\t\tif(n % 2 == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tlong d = n - 1;\n\
    \t\twhile(d % 2 == 0) {\n\t\t\td /= 2;\n\t\t}\n\t\tfinal long[] sample = {2, 3,\
    \ 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n\t\tfor(final long a: sample) {\n\t\t\
    \tif(n <= a) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong t = d;\n\t\t\tBigInteger y\
    \ = BigInteger.valueOf(a).modPow(BigInteger.valueOf(t), BigInteger.valueOf(n));\n\
    \t\t\twhile(t != n - 1 && !y.equals(BigInteger.ONE) && !y.equals(BigInteger.valueOf(n).subtract(BigInteger.ONE)))\
    \ {\n\t\t\t\ty = y.multiply(y).mod(BigInteger.valueOf(n));\n\t\t\t\tt <<= 1;\n\
    \t\t\t}\n\t\t\tif(!y.equals(BigInteger.valueOf(n).subtract(BigInteger.ONE)) &&\
    \ t % 2 == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\
    \tfinal private long find(final long n) {\n\t\tif(isPrime(n)) {\n\t\t\treturn\
    \ n;\n\t\t}\n\t\tif(n % 2 == 0) {\n\t\t\treturn 2;\n\t\t}\n\t\tlong st = 0;\n\t\
    \tfinal LongBinaryOperator f = (x, y) -> { return BigInteger.valueOf(x).multiply(BigInteger.valueOf(x)).add(BigInteger.valueOf(y)).mod(BigInteger.valueOf(n)).longValue();\
    \ };\n\t\twhile(true) {\n\t\t\tst++;\n\t\t\tlong x = st, y = f.applyAsLong(x,\
    \ st);\n\t\t\twhile(true) {\n\t\t\t\tfinal long p = gcd(y - x + n, n);\n\t\t\t\
    \tif(p == 0 || p == n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(p != 1) {\n\t\
    \t\t\t\treturn p;\n\t\t\t\t}\n\t\t\t\tx = f.applyAsLong(x, st);\n\t\t\t\ty = f.applyAsLong(f.applyAsLong(y,\
    \ st), st);\n\t\t\t}\n\t\t}\n\t}\n\tfinal ArrayList<Long> primeFactor(final long\
    \ n) {\n\t\tif(n == 1) return new ArrayList<>();\n\t\tfinal long x = find(n);\n\
    \t\tif(x == n) return new ArrayList<>(Arrays.asList(x));\n\t\tArrayList<Long>\
    \ l = primeFactor(x);\n\t\tfinal ArrayList<Long> r = primeFactor(n / x);\n\t\t\
    l.addAll(r);\n\t\tCollections.sort(l);\n\t\treturn l;\n\t}\n}\n// N > 1e18\nfinal\
    \ class BigPrime {\n\tprotected final int bsf(final long x){ return Long.numberOfTrailingZeros(x);\
    \ }\n\tprivate final BigInteger gcd(BigInteger a, BigInteger b) {\n\t\ta = a.abs();\n\
    \t\tb = b.abs();\n\t\tif(a.equals(BigInteger.ZERO)) {\n\t\t\treturn b;\n\t\t}\n\
    \t\tif(b.equals(BigInteger.ZERO)) {\n\t\t\treturn a;\n\t\t}\n\t\tfinal int shift\
    \ = bsf(a.or(b).longValue());\n\t\ta = a.shiftRight(bsf(a.longValue()));\n\t\t\
    do {\n\t\t\tb = b.shiftRight(bsf(b.longValue()));\n\t\t\tif(a.compareTo(b) > 0)\
    \ {\n\t\t\t\tfinal var tmp = b;\n\t\t\t\tb = a;\n\t\t\t\ta = tmp;\n\t\t\t}\n\t\
    \t\tb = b.subtract(a);\n\t\t} while(b.compareTo(BigInteger.ZERO) > 0);\n\t\treturn\
    \ a.shiftLeft(shift);\n\t}\n\tfinal boolean isPrime(final BigInteger n) {\n\t\t\
    if(n.compareTo(BigInteger.ONE) <= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif(n.equals(BigInteger.TWO))\
    \ {\n\t\t\treturn true;\n\t\t}\n\t\tif(n.and(BigInteger.ONE).equals(BigInteger.valueOf(0)))\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tBigInteger d = n.subtract(BigInteger.ONE);\n\
    \t\twhile(d.and(BigInteger.ONE).equals(BigInteger.valueOf(0))) {\n\t\t\td = d.shiftRight(1);\n\
    \t\t}\n\t\tfinal long[] sample = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n\
    \t\tfor(final long a: sample) {\n\t\t\tif(n.compareTo(BigInteger.valueOf(a)) <=\
    \ 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBigInteger t = d;\n\t\t\tBigInteger y =\
    \ BigInteger.valueOf(a).modPow(t, n);\n\t\t\twhile(!t.equals(n.subtract(BigInteger.ONE))\
    \ && !y.equals(BigInteger.ONE) && !y.equals(n.subtract(BigInteger.ONE))) {\n\t\
    \t\t\ty = y.multiply(y).mod(n);\n\t\t\t\tt = t.shiftLeft(1);\n\t\t\t}\n\t\t\t\
    if(!y.equals(n.subtract(BigInteger.ONE)) && t.and(BigInteger.ONE).equals(BigInteger.ZERO))\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate final\
    \ BigInteger find(final BigInteger n) {\n\t\tif(isPrime(n)) {\n\t\t\treturn n;\n\
    \t\t}\n\t\tif(n.and(BigInteger.ONE).equals(BigInteger.ZERO)) {\n\t\t\treturn BigInteger.TWO;\n\
    \t\t}\n\t\tint st = 0;\n\t\tfinal BiFunction<BigInteger, Integer, BigInteger>\
    \ f = (x, y) -> { return x.multiply(x).add(BigInteger.valueOf(y)).mod(n); };\n\
    \t\twhile(true) {\n\t\t\tst++;\n\t\t\tBigInteger x = BigInteger.valueOf(st), y\
    \ = f.apply(x, st);\n\t\t\twhile(true) {\n\t\t\t\tfinal BigInteger p = gcd(y.subtract(x).add(n),\
    \ n);\n\t\t\t\tif(p.equals(BigInteger.ZERO) || p.equals(n)) {\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t\tif(!p.equals(BigInteger.ONE)) {\n\t\t\t\t\treturn p;\n\t\t\t\
    \t}\n\t\t\t\tx = f.apply(x, st);\n\t\t\t\ty = f.apply(f.apply(y, st), st);\n\t\
    \t\t}\n\t\t}\n\t}\n\tfinal ArrayList<BigInteger> primeFactor(final BigInteger\
    \ n) {\n\t\tif(n.equals(BigInteger.ONE)) {\n\t\t\treturn new ArrayList<>();\n\t\
    \t}\n\t\tfinal BigInteger x = find(n);\n\t\tif(x.equals(n)) {\n\t\t\treturn new\
    \ ArrayList<>(Arrays.asList(x));\n\t\t}\n\t\tvar l = primeFactor(x);\n\t\tfinal\
    \ var r = primeFactor(n.divide(x));\n\t\tl.addAll(r);\n\t\tCollections.sort(l);\n\
    \t\treturn l;\n\t}\n}\n\nfinal class EulerPhiTable {\n\tprivate final int n;\n\
    \tprivate final int[] euler;\n\tEulerPhiTable(final int n) {\n\t\tthis.n = n;\n\
    \t\teuler = Utility.iota(n + 1);\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\tif(euler[i]\
    \ == i) {\n\t\t\t\tfor(int j = i; j <= n; j += i) {\n\t\t\t\t\teuler[j] = euler[j]\
    \ / i * (i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinal int[] get(){ return\
    \ euler; }\n\tfinal long[] acc() {\n\t\tlong[] ret = new long[n + 1];\n\t\tret[1]\
    \ = 2;\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\tret[i] = ret[i - 1] + euler[i];\n\
    \t\t}\n\t\treturn ret;\n\t}\n}\n\nclass InclusiveScan {\n\tprotected final int\
    \ n;\n\tprotected long[] s;\n\tInclusiveScan(final int[] a, final LongBinaryOperator\
    \ op) {\n\t\tn = a.length;\n\t\ts = Arrays.stream(a).mapToLong(i -> i).toArray();\n\
    \t\tArrays.parallelPrefix(s, op);\n\t}\n\tInclusiveScan(final long[] a, final\
    \ LongBinaryOperator op) {\n\t\tn = a.length;\n\t\ts = a.clone();\n\t\tArrays.parallelPrefix(s,\
    \ op);\n\t}\n\tprotected long[] get(){ return s; }\n\tprotected long query(final\
    \ int l, final int r){ return s[r] - s[l]; }\n}\nfinal class PrefixSum extends\
    \ InclusiveScan {\n\tPrefixSum(final int[] a) {\n\t\tsuper(a, (x, y) -> x + y);\n\
    \t\ts = Utility.rotate(Arrays.copyOf(s, n + 1), 1);\n\t}\n\tPrefixSum(final long[]\
    \ a) {\n\t\tsuper(a, (x, y) -> x + y);\n\t\ts = Utility.rotate(Arrays.copyOf(s,\
    \ n + 1), 1);\n\t}\n}\n\nfinal class FenwickTree {\n\tprivate final int n;\n\t\
    private final long[] data;\n\tFenwickTree(final int n) {\n\t\tthis.n = n + 2;\n\
    \t\tdata = new long[this.n + 1];\n\t}\n\tfinal long sum(int k) {\n\t\tif(k < 0)\
    \ return 0;\n\t\tlong ret = 0;\n\t\tfor(++k; k > 0; k -= k & -k) {\n\t\t\tret\
    \ += data[k];\n\t\t}\n\t\treturn ret;\n\t}\n\tfinal long sum(final int l, final\
    \ int r){ return sum(r) - sum(l - 1); }\n\tfinal long get(final int k){ return\
    \ sum(k) - sum(k - 1); }\n\tfinal void add(int k, final long x) {\n\t\tfor(++k;\
    \ k < n; k += k & -k) {\n\t\t\tdata[k] += x;\n\t\t}\n\t}\n\tfinal void imos(final\
    \ int l, final int r, long x) {\n\t\tadd(l, x);\n\t\tadd(r + 1, -x);\n\t}\n\t\
    private final int lg(final int n){ return 63 - Integer.numberOfLeadingZeros(n);\
    \ }\n\tfinal int lowerBound(long w) {\n\t\tif(w <= 0) {\n\t\t\treturn 0;\n\t\t\
    }\n\t\tint x = 0;\n\t\tfor(int k = 1 << lg(n); k > 0; k >>= 1) {\n\t\t\tif(x +\
    \ k <= n - 1 && data[x + k] < w) {\n\t\t\t\tw -= data[x + k];\n\t\t\t\tx += k;\n\
    \t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\tfinal int upperBound(long w) {\n\t\tif(w\
    \ < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint x = 0;\n\t\tfor(int k = 1 << lg(n);\
    \ k > 0; k >>= 1) {\n\t\t\tif(x + k <= n - 1 && data[x + k] <= w) {\n\t\t\t\t\
    w -= data[x + k];\n\t\t\t\tx += k;\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n}\n\n\
    final class SegmentTree<T extends Number> {\n\tprivate int n = 1, rank = 0, fini;\n\
    \tprivate final BinaryOperator<T> op;\n\tprivate final T e;\n\tprivate final Object[]\
    \ dat;\n\tSegmentTree(final int fini, final BinaryOperator<T> op, final T e) {\n\
    \t\tthis.fini = fini;\n\t\tthis.op = op;\n\t\tthis.e = e;\n\t\twhile(this.fini\
    \ > n) {\n\t\t\tn <<= 1;\n\t\t\trank++;\n\t\t}\n\t\tdat = new Object[2 * n];\n\
    \t\tArrays.fill(dat, e);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal void\
    \ update(int i, final T x) {\n\t\ti += n;\n\t\tdat[i] = x;\n\t\tdo {\n\t\t\ti\
    \ >>= 1;\n\t\t\tdat[i] = op.apply((T) dat[2 * i], (T) dat[2 * i + 1]);\n\t\t}\
    \ while(i > 0);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T query(int\
    \ a, int b) {\n\t\tT l = e, r = e;\n\t\tfor(a += n, b += n; a < b; a >>= 1, b\
    \ >>= 1) {\n\t\t\tif(a % 2 == 1) {\n\t\t\t\tl = op.apply(l, (T) dat[a++]);\n\t\
    \t\t}\n\t\t\tif(b % 2 == 1) {\n\t\t\t\tr = op.apply((T) dat[--b], r);\n\t\t\t\
    }\n\t\t}\n\t\treturn op.apply(l, r);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\
    \tfinal int findLeft(final int r, final Predicate<T> fn) {\n\t\tif(r == 0) {\n\
    \t\t\treturn 0;\n\t\t}\n\t\tint h = 0, i = r + n;\n\t\tT val = e;\n\t\tfor(; h\
    \ <= rank; h++) {\n\t\t\tif(i >> (h & 1) > 0) {\n\t\t\t\tfinal T val2 = op.apply(val,\
    \ (T) dat[i >> (h ^ 1)]);\n\t\t\t\tif(fn.test(val2)){\n\t\t\t\t\ti -= 1 << h;\n\
    \t\t\t\t\tif(i == n) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tval = val2;\n\
    \t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(;\
    \ h-- > 0;) {\n\t\t\tfinal T val2 = op.apply(val, (T) dat[(i >> h) - 1]);\n\t\t\
    \tif(fn.test(val2)){\n\t\t\t\ti -= 1 << h;\n\t\t\t\tif(i == n) {\n\t\t\t\t\treturn\
    \ 0;\n\t\t\t\t}\n\t\t\t\tval = val2;\n\t\t\t}\n\t\t}\n\t\treturn i - n;\n\t}\n\
    \t@SuppressWarnings(\"unchecked\")\n\tfinal int findRight(final int l, final Predicate<T>\
    \ fn) {\n\t\tif(l == fini) {\n\t\t\treturn fini;\n\t\t}\n\t\tint h = 0, i = l\
    \ + n;\n\t\tT val = e;\n\t\tfor(; h <= rank; h++) {\n\t\t\tif(i >> (h & 1) > 0){\n\
    \t\t\t\tfinal T val2 = op.apply(val, (T) dat[i >> h]);\n\t\t\t\tif(fn.test(val2)){\n\
    \t\t\t\t\ti += 1 << h;\n\t\t\t\t\tif(i == n * 2) {\n\t\t\t\t\t\treturn fini;\n\
    \t\t\t\t\t}\n\t\t\t\t\tval = val2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(; h-- > 0;) {\n\t\t\tfinal T val2 = op.apply(val,\
    \ (T) dat[i>>h]);\n\t\t\tif(fn.test(val2)) {\n\t\t\t\ti += 1 << h;\n\t\t\t\tif(i\
    \ == n * 2) {\n\t\t\t\t\treturn fini;\n\t\t\t\t}\n\t\t\t\tval = val2;\n\t\t\t\
    }\n\t\t}\n\t\treturn Math.min(i - n, fini);\n\t}\n}\n\nfinal class SparseTable\
    \ {\n\tprivate final long[][] st;\n\tprivate final int[] lookup;\n\tprivate final\
    \ LongBinaryOperator op;\n\tSparseTable(final int[] a, final LongBinaryOperator\
    \ op) {\n\t\tthis.op = op;\n\t\tint b = 0;\n\t\twhile((1 << b) <= a.length) {\n\
    \t\t\t++b;\n\t\t}\n\t\tst = new long[b][1 << b];\n\t\tfor(int i = 0; i < a.length;\
    \ i++) {\n\t\t\tst[0][i] = a[i];\n\t\t}\n\t\tfor(int i = 1; i < b; i++) {\n\t\t\
    \tfor(int j = 0; j + (1 << i) <= (1 << b); j++) {\n\t\t\t\tst[i][j] = op.applyAsLong(st[i\
    \ - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\t\t}\n\t\t}\n\t\tlookup = new int[a.length\
    \ + 1];\n\t\tfor(int i = 2; i < lookup.length; i++) {\n\t\t\tlookup[i] = lookup[i\
    \ >> 1] + 1;\n\t\t}\n\t}\n\tSparseTable(final long[] a, final LongBinaryOperator\
    \ op) {\n\t\tthis.op = op;\n\t\tint b = 0;\n\t\twhile((1 << b) <= a.length) {\n\
    \t\t\t++b;\n\t\t}\n\t\tst = new long[b][1 << b];\n\t\tfor(int i = 0; i < a.length;\
    \ i++) {\n\t\t\tst[0][i] = a[i];\n\t\t}\n\t\tfor(int i = 1; i < b; i++) {\n\t\t\
    \tfor(int j = 0; j + (1 << i) <= (1 << b); j++) {\n\t\t\t\tst[i][j] = op.applyAsLong(st[i\
    \ - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\t\t}\n\t\t}\n\t\tlookup = new int[a.length\
    \ + 1];\n\t\tfor(int i = 2; i < lookup.length; i++) {\n\t\t\tlookup[i] = lookup[i\
    \ >> 1] + 1;\n\t\t}\n\t}\n\tfinal long query(final int l, final int r) {\n\t\t\
    final int b = lookup[r - l];\n\t\treturn op.applyAsLong(st[b][l], st[b][r - (1\
    \ << b)]);\n\t}\n\tfinal int minLeft(final int x, final LongPredicate fn) {\n\t\
    \tif(x == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint ok = x, ng = -1;\n\t\twhile(Math.abs(ok\
    \ - ng) > 1) {\n\t\t\tfinal int mid = (ok + ng) / 2;\n\t\t\tif(fn.test(query(mid,\
    \ x) - 1)) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\
    \t}\n\t\t}\n\t\treturn ok;\n\t}\n\tfinal int maxRight(final int x, final LongPredicate\
    \ fn) {\n\t\tif(x == lookup.length - 1) {\n\t\t\treturn lookup.length - 1;\n\t\
    \t}\n\t\tint ok = x, ng = lookup.length;\n\t\twhile(Math.abs(ok - ng) > 1) {\n\
    \t\t\tint mid = (ok + ng) / 2;\n\t\t\tif(fn.test(query(x, mid))) {\n\t\t\t\tok\
    \ = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ ok;\n\t}\n}\n\nfinal class SuffixArray extends ArrayList<Integer> {\n\tprivate\
    \ final String vs;\n\tSuffixArray(final String vs, final boolean compress) {\n\
    \t\tthis.vs = vs;\n\t\tint[] newVS = new int[vs.length() + 1];\n\t\tif(compress)\
    \ {\n\t\t\tfinal var xs = vs.chars().sorted().distinct().boxed().collect(Collectors.toList());\n\
    \t\t\tfor(int i = 0; i < vs.length(); ++i) {\n\t\t\t\tnewVS[i] = Utility.lowerBound(xs,\
    \ (int) vs.charAt(i)) + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tfinal int d = vs.chars().min().getAsInt();\n\
    \t\t\tfor(int i = 0; i < vs.length(); ++i) {\n\t\t\t\tnewVS[i] = vs.charAt(i)\
    \ - d + 1;\n\t\t\t}\n\t\t}\n\t\tthis.addAll(Arrays.stream(SAIS(newVS)).boxed().collect(Collectors.toList()));\n\
    \t}\n\tprivate final int[] SAIS(final int[] s) {\n\t\tfinal int n = s.length;\n\
    \t\tfinal int[] ret = new int[n];\n\t\tfinal boolean[] isS = new boolean[n], isLMS\
    \ = new boolean[n];\n\t\tint m = 0;\n\t\tfor(int i = n - 2; i >= 0; i--) {\n\t\
    \t\tisS[i] = (s[i] > s[i + 1]) || (s[i] == s[i + 1] && isS[i + 1]);\n\t\t\tm +=\
    \ (isLMS[i + 1] = isS[i] && !isS[i + 1]) ? 1 : 0;\n\t\t}\n\t\tfinal Consumer<ArrayList<Integer>>\
    \ inducedSort = (lms) -> {\n\t\t\tfinal int upper = Arrays.stream(s).max().getAsInt();\n\
    \t\t\tint[] l = new int[upper + 2], r = new int[upper + 2];\n\t\t\tfor(final var\
    \ v: s) {\n\t\t\t\t++l[v + 1];\n\t\t\t\t++r[v];\n\t\t\t}\n\t\t\tArrays.parallelPrefix(l,\
    \ (x, y) -> x + y);\n\t\t\tArrays.parallelPrefix(r, (x, y) -> x + y);\n\t\t\t\
    Arrays.fill(ret, -1);\n\t\t\tfor(int i = lms.size(); --i >= 0;) {\n\t\t\t\tret[--r[s[lms.get(i)]]]\
    \ = lms.get(i);\n\t\t\t}\n\t\t\tfor(final var v: ret) {\n\t\t\t\tif(v >= 1 &&\
    \ isS[v - 1]) {\n\t\t\t\t\tret[l[s[v - 1]]++] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\
    \t\tArrays.fill(r, 0);\n\t\t\tfor(final var v: s) {\n\t\t\t\t++r[v];\n\t\t\t}\n\
    \t\t\tArrays.parallelPrefix(r, (x, y) -> x + y);\n\t\t\tfor(int k = ret.length\
    \ - 1, i = ret[k]; k >= 1; i = ret[--k]) {\n\t\t\t\tif(i >= 1 && !isS[i - 1])\
    \ {\n\t\t\t\t\tret[--r[s[i - 1]]] = i - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfinal\
    \ ArrayList<Integer> lms = new ArrayList<>(), newLMS = new ArrayList<>();\n\t\t\
    for(int i = 0; ++i < n;) {\n\t\t\tif(isLMS[i]) {\n\t\t\t\tlms.add(i);\n\t\t\t\
    }\n\t\t}\n\t\tinducedSort.accept(lms);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\
    \tif(!isS[ret[i]] && ret[i] > 0 && isS[ret[i] - 1]) {\n\t\t\t\tnewLMS.add(ret[i]);\n\
    \t\t\t}\n\t\t}\n\t\tfinal BiPredicate<Integer, Integer> same = (a, b) -> {\n\t\
    \t\tif(s[a++] != s[b++]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\twhile(true)\
    \ {\n\t\t\t\tif(s[a] != s[b]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\
    if(isLMS[a] || isLMS[b]) {\n\t\t\t\t\treturn isLMS[a] && isLMS[b];\n\t\t\t\t}\n\
    \t\t\t\ta++;\n\t\t\t\tb++;\n\t\t\t}\n\t\t};\n\t\tint rank = 0;\n\t\tret[n - 1]\
    \ = 0;\n\t\tfor(int i = 0; ++i < m;) {\n\t\t\tif(!same.test(newLMS.get(i - 1),\
    \ newLMS.get(i))) {\n\t\t\t\t++rank;\n\t\t\t}\n\t\t\tret[newLMS.get(i)] = rank;\n\
    \t\t}\n\t\tif(rank + 1 < m) {\n\t\t\tint[] newS = new int[m];\n\t\t\tfor(int i\
    \ = 0; i < m; ++i) {\n\t\t\t\tnewS[i] = ret[lms.get(i)];\n\t\t\t}\n\t\t\tfinal\
    \ var lmsSA = SAIS(newS);\n\t\t\tIntStream.range(0, m).forEach(i -> newLMS.set(i,\
    \ lms.get(lmsSA[i])));\n\t\t}\n\t\tinducedSort.accept(newLMS);\n\t\treturn ret;\n\
    \t}\n\tfinal boolean ltSubstr(final String t, int si, int ti) {\n\t\tfinal int\
    \ sn = vs.length(), tn = t.length();\n\t\twhile(si < sn && ti < tn) {\n\t\t\t\
    if(vs.charAt(si) < t.charAt(ti)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(vs.charAt(si)\
    \ > t.charAt(ti)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t++si;\n\t\t\t++ti;\n\
    \t\t}\n\t\treturn si >= sn && ti < tn;\n\t}\n\tfinal int lowerBound(final String\
    \ t) {\n\t\tint ok = this.size(), ng = 0;\n\t\twhile(ok - ng > 1) {\n\t\t\tfinal\
    \ int mid = (ok + ng) / 2;\n\t\t\tif(ltSubstr(t, this.get(mid), 0)) {\n\t\t\t\t\
    ng = mid;\n\t\t\t} else {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\
    \t}\n\tfinal Pair<Integer, Integer> equalRange(final String t) {\n\t\tfinal int\
    \ low = lowerBound(t);\n\t\tint ng = low - 1, ok = this.size();\n\t\tvar sb =\
    \ new StringBuilder(t);\n\t\tsb.setCharAt(t.length() - 1, (char)(sb.charAt(sb.length()\
    \ - 1) - 1));\n\t\tfinal String u = sb.toString();\n\t\twhile(ok - ng > 1) {\n\
    \t\t\tfinal int mid = (ok + ng) / 2;\n\t\t\tif(ltSubstr(u, this.get(mid), 0))\
    \ {\n\t\t\t\tng = mid;\n\t\t\t} else {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t}\n\t\t\
    final int end = this.size() - 1;\n\t\tthis.add(end, this.get(end) - 1);\n\t\t\
    return Pair.of(low, ok);\n\t}\n\tfinal int[] lcpArray() {\n\t\tfinal int n = this.size()\
    \ - 1;\n\t\tint[] lcp = new int[n + 1], rank = new int[n + 1];\n\t\tfor(int i\
    \ = 0; i <= n; ++i) {\n\t\t\trank[this.get(i)] = i;\n\t\t}\n\t\tint h = 0;\n\t\
    \tfor(int i = 0; i <= n; ++i) {\n\t\t\tif(rank[i] < n) {\n\t\t\t\tfinal int j\
    \ = this.get(rank[i] + 1);\n\t\t\t\tfor(; j + h < n && i + h < n; ++h) {\n\t\t\
    \t\t\tif(vs.charAt(j + h) != vs.charAt(i + h)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\
    \t}\n\t\t\t\t}\n\t\t\t\tlcp[rank[i] + 1] = h;\n\t\t\t\tif(h > 0) {\n\t\t\t\t\t\
    h--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lcp;\n\t}\n\t@Override\n\tpublic final\
    \ String toString() { \n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int\
    \ i = 0; i < this.size(); ++i) {\n\t\t\tsb.append(i + \":[\" + this.get(i) + \"\
    ]\");\n\t\t\tfor(int j = this.get(i); j < vs.length(); ++j) {\n\t\t\t\tsb.append(\"\
    \ \" + vs.charAt(j));\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\
    \t}\n}\n\nfinal class DoubleEndedPriorityQueue<T extends Number> {\n\tprivate\
    \ final ArrayList<T> d;\n\tDoubleEndedPriorityQueue(final ArrayList<T> d) {\n\t\
    \tthis.d = d;\n\t\tmakeHeap();\n\t}\n\tprivate final void makeHeap() {\n\t\tfor(int\
    \ i = d.size(); i-- > 0;) {\n\t\t\tif (i % 2 == 1 && d.get(i - 1).longValue()\
    \ < d.get(i).longValue()) {\n\t\t\t\tCollections.swap(d, i - 1, i);\n\t\t\t}\n\
    \t\t\tup(down(i), i);\n\t\t}\n\t}\n\tprivate final int down(int k) {\n\t\tfinal\
    \ int n = d.size();\n\t\tif(k % 2 == 1) {\n\t\t\twhile(2 * k + 1 < n) {\n\t\t\t\
    \tint c = 2 * k + 3;\n\t\t\t\tif(n <= c || d.get(c - 2).longValue() < d.get(c).longValue())\
    \ {\n\t\t\t\t\t c -= 2;\n\t\t\t\t}\n\t\t\t\tif(c < n && d.get(c).longValue() <\
    \ d.get(k).longValue()) {\n\t\t\t\t\tCollections.swap(d, k, c);\n\t\t\t\t\tk =\
    \ c;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else\
    \ {\n\t\t\twhile(2 * k + 2 < n) {\n\t\t\t\tint c = 2 * k + 4;\n\t\t\t\tif(n <=\
    \ c || d.get(c).longValue() < d.get(c - 2).longValue()) {\n\t\t\t\t\tc -= 2;\n\
    \t\t\t\t}\n\t\t\t\tif(c < n && d.get(k).longValue() < d.get(c).longValue()) {\n\
    \t\t\t\t\tCollections.swap(d, k, c);\n\t\t\t\t\tk = c;\n\t\t\t\t}\n\t\t\t\telse\
    \ {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn k;\n\t}\n\tprivate\
    \ final int up(int k, final int root) {\n\t\tif((k | 1) < d.size() && d.get(k\
    \ & ~1).longValue() < d.get(k | 1).longValue()) {\n\t\t\tCollections.swap(d, k\
    \ & ~1, k | 1);\n\t\t\tk ^= 1;\n\t\t}\n\t\tint p;\n\t\twhile(root < k && d.get(p\
    \ = parent(k)).longValue() < d.get(k).longValue()) {\n\t\t\tCollections.swap(d,\
    \ p, k);\n\t\t\tk = p;\n\t\t}\n\t\twhile(root < k && d.get(k).longValue() < d.get(p\
    \ = parent(k) | 1).longValue()) {\n\t\t\tCollections.swap(d, p, k);\n\t\t\tk =\
    \ p;\n\t\t}\n\t\treturn k;\n\t}\n\tprivate final int parent(final int k){ return\
    \ ((k >> 1) - 1) & ~1; }\n\tprivate final void popBack(final ArrayList<T> d){\
    \ d.remove(d.size() - 1); } \n\tfinal void push(final T x) {\n\t\tfinal int k\
    \ = d.size();\n\t\td.add(x);\n\t\tup(k, 1);\n\t}\n\tfinal T popMin() {\n\t\tfinal\
    \ var res = getMin();\n\t\tif(d.size() < 3) {\n\t\t\tpopBack(d); \n\t\t} else\
    \ {\n\t\t\tCollections.swap(d, 1, d.size() - 1);\n\t\t\tpopBack(d);\n\t\t\tup(down(1),\
    \ 1);\n\t\t}\n\t\treturn res;\n\t}\n\tfinal T popMax() {\n\t\tfinal var res =\
    \ getMax();\n\t\tif(d.size() < 2) { \n\t\t\tpopBack(d);\n\t\t} else {\n\t\t\t\
    Collections.swap(d, 0, d.size() - 1);\n\t\t\tpopBack(d);\n\t\t\tup(down(0), 1);\n\
    \t\t}\n\t\treturn res;\n\t}\n\tfinal T getMin(){ return d.size() < 2 ? d.get(0)\
    \ : d.get(1); }\n\tfinal T getMax(){ return d.get(0); }\n\tfinal int size(){ return\
    \ d.size(); }\n\tfinal boolean isEmpty(){ return d.isEmpty(); }\n}\n\nfinal class\
    \ SuccinctIndexableDictionary {\n\tprivate final int blk;\n\tprivate final int[]\
    \ bit, sum;\n\tSuccinctIndexableDictionary(final int len) {\n\t\tblk = (len +\
    \ 31) >> 5;\n\t\tbit = new int[blk];\n\t\tsum = new int[blk];\n\t}\n\tfinal void\
    \ set(final int k){ bit[k >> 5] |= 1 << (k & 31); }\n\tfinal void build() {\n\t\
    \tsum[0] = 0;\n\t\tfor(int i = 0; ++i < blk;) {\n\t\t\tsum[i] = sum[i - 1] + Integer.bitCount(bit[i\
    \ - 1]);\n\t\t}\n\t}\n\tfinal boolean get(final int k){ return ((bit[k >> 5] >>\
    \ (k & 31)) & 1) == 1; }\n\tfinal int rank(final int k){ return (sum[k >> 5] +\
    \ Integer.bitCount(bit[k >> 5] & ((1 << (k & 31)) - 1))); }\n\tfinal int rank(final\
    \ boolean val, final int k){ return val ? rank(k) : k - rank(k); }\n}\nfinal class\
    \ WaveletMatrixBeta {\n\tprivate final int log;\n\tprivate final SuccinctIndexableDictionary[]\
    \ matrix;\n\tprivate final int[] mid;\n\tWaveletMatrixBeta(long[] arr, final int\
    \ log) {\n\t\tfinal int len = arr.length;\n\t\tthis.log = log;\n\t\tmatrix = new\
    \ SuccinctIndexableDictionary[log];\n\t\tmid = new int[log];\n\t\tfinal long[]\
    \ l = new long[len], r = new long[len];\n\t\tfor(int level = log; --level >= 0;)\
    \ {\n\t\t\tmatrix[level] = new SuccinctIndexableDictionary(len + 1);\n\t\t\tint\
    \ left = 0, right = 0;\n\t\t\tfor(int i = 0; i < len; ++i) {\n\t\t\t\tif(((arr[i]\
    \ >> level) & 1) == 1) {\n\t\t\t\t\tmatrix[level].set(i);\n\t\t\t\t\tr[right++]\
    \ = arr[i];\n\t\t\t\t} else {\n\t\t\t\t\tl[left++] = arr[i];\n\t\t\t\t}\n\t\t\t\
    }\n\t\t\tmid[level] = left;\n\t\t\tmatrix[level].build();\n\t\t\tfinal long[]\
    \ tmp = new long[len];\n\t\t\tSystem.arraycopy(arr, 0, tmp, 0, len);\n\t\t\tSystem.arraycopy(l,\
    \ 0, arr, 0, len);\n\t\t\tSystem.arraycopy(tmp, 0, l, 0, len);\n\t\t\tfor(int\
    \ i = 0; i < right; ++i) {\n\t\t\t\tarr[left + i] = r[i];\n\t\t\t}\n\t\t}\n\t\
    }\n\tprivate final NumPair succ(final boolean f, final int l, final int r, final\
    \ int level){ return new NumPair(matrix[level].rank(f, l) + mid[level] * (f ?\
    \ 1 : 0), matrix[level].rank(f, r) + mid[level] * (f ? 1 : 0)); }\n\tfinal long\
    \ access(int k) {\n\t\tlong ret = 0;\n\t\tfor(int level = log; --level >= 0;)\
    \ {\n\t\t\tfinal boolean f = matrix[level].get(k);\n\t\t\tif(f) {\n\t\t\t\tret\
    \ |= 1L << level;\n\t\t\t}\n\t\t\tk = matrix[level].rank(f, k) + mid[level] *\
    \ (f ? 1 : 0);\n\t\t}\t\n\t\treturn ret;\n\t}\n\tfinal int rank(final long x,\
    \ int r) {\n\t\tint l = 0;\n\t\tfor(int level = log; --level >= 0;) {\n\t\t\t\
    final var p = succ(((x >> level) & 1) == 1, l, r, level);\n\t\t\tl = p.first.intValue();\n\
    \t\t\tr = p.second.intValue();\n\t\t}\n\t\treturn r - l;\n\t}\n\tfinal long kthMin(int\
    \ l, int r, int k) {\n\t\tif(!Utility.scope(0, k, r - l - 1)) {\n\t\t\tthrow new\
    \ IndexOutOfBoundsException();\n\t\t}\n\t\tlong ret = 0;\n\t\tfor(int level =\
    \ log; --level >= 0;) {\n\t\t\tfinal int cnt = matrix[level].rank(false, r) -\
    \ matrix[level].rank(false, l);\n\t\t\tfinal boolean f = cnt <= k;\n\t\t\tif(f)\
    \ {\n\t\t\t\tret |= 1 << level;\n\t\t\t\tk -= cnt;\n\t\t\t}\n\t\t\tfinal var p\
    \ = succ(f, l, r, level);\n\t\t\tl = p.first.intValue();\n\t\t\tr = p.second.intValue();\n\
    \t\t}\n\t\treturn ret;\n\t}\n\tfinal long kthMax(final int l, final int r, final\
    \ int k){ return kthMin(l, r, r - l - k - 1); }\n\tfinal int rangeFreq(int l,\
    \ int r, final long upper) {\n\t\tint ret = 0;\n\t\tfor(int level = log; --level\
    \ >= 0;) {\n\t\t\tfinal boolean f = ((upper >> level) & 1) == 1;\n\t\t\tif(f)\
    \ {\n\t\t\t\tret += matrix[level].rank(false, r) - matrix[level].rank(false, l);\n\
    \t\t\t}\n\t\t\tfinal var p = succ(f, l, r, level); \n\t\t\tl = p.first.intValue();\n\
    \t\t\tr = p.second.intValue();\n\t\t}\n\t\treturn ret;\n\t}\n\tfinal int rangeFreq(final\
    \ int l, final int r, final long lower, final long upper){ return rangeFreq(l,\
    \ r, upper) - rangeFreq(l, r, lower); }\n\tfinal long prev(final int l, final\
    \ int r, final long upper) {\n\t\tfinal int cnt = rangeFreq(l, r, upper);\n\t\t\
    return cnt == 0 ? -1 : kthMin(l, r, cnt - 1);\n\t}\n\tfinal long next(final int\
    \ l, final int r, final long lower) {\n\t\tfinal int cnt = rangeFreq(l, r, lower);\n\
    \t\treturn cnt == r - l ? -1 : kthMin(l, r, cnt);\n\t}\n}\nfinal class WaveletMatrix\
    \ {\n\tprivate final WaveletMatrixBeta mat;\n\tprivate final long[] ys;\n\tWaveletMatrix(final\
    \ long[] arr, final int log) {\n\t\tys = Arrays.stream(arr).sorted().distinct().toArray();\n\
    \t\tfinal long[] t = new long[arr.length];\n\t\tIntStream.range(0, arr.length).forEach(i\
    \ -> t[i] = get(arr[i]));\n\t\tmat = new WaveletMatrixBeta(t, log);\n\t}\n\tprivate\
    \ final int get(final long x){ return Utility.lowerBound(ys, x); }\n\tfinal long\
    \ access(final int k){ return ys[(int) mat.access(k)]; }\n\tfinal int rank(final\
    \ long x, final int r) {\n\t\tfinal var pos = get(x);\n\t\tif(pos == ys.length\
    \ || ys[pos] != x) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn mat.rank(pos, r);\n\t\
    }\n\tfinal long kthMin(final int l, final int r, final int k){ return ys[(int)\
    \ mat.kthMin(l, r, k)]; }\n\tfinal long kthMax(final int l, final int r, final\
    \ int k){ return ys[(int) mat.kthMax(l, r, k)]; }\n\tfinal int rangeFreq(final\
    \ int l, final int r, final long upper){ return mat.rangeFreq(l, r, get(upper));\
    \ }\n\tfinal int rangeFreq(final int l, final int r, final long lower, final long\
    \ upper){ return mat.rangeFreq(l, r, get(lower), get(upper)); }\n\tfinal long\
    \ prev(final int l, final int r, final long upper) {\n\t\tfinal var ret = mat.prev(l,\
    \ r, get(upper));\n\t\treturn ret == -1 ? -1 : ys[(int) ret];\n\t}\n\tfinal long\
    \ next(final int l, final int r, final long lower) {\n\t\tfinal var ret = mat.next(l,\
    \ r, get(lower));\n\t\treturn ret == -1 ? -1 : ys[(int) ret];\n\t}\n}\n\nfinal\
    \ class AVLTree<T extends Comparable<? super T>> {\n\tstatic final class Node<T\
    \ extends Comparable<? super T>> {\n\t\tT val;\n\t\t@SuppressWarnings(\"unchecked\"\
    )\n\t\tNode<T>[] ch = new Node[2];\n\t\tint dep, size;\n\t\tNode(final T val,\
    \ Node<T> l, Node<T> r) {\n\t\t\tthis.val = val;\n\t\t\tdep = size = 1;\n\t\t\t\
    ch[0] = l;\n\t\t\tch[1] = r;\n\t\t}\n\t}\n\tprivate Node<T> root;\n\tprivate final\
    \ int depth(final Node<T> t){ return t == null ? 0 : t.dep; }\n\tprivate final\
    \ int count(final Node<T> t){ return t == null ? 0 : t.size; }\n\tprivate final\
    \ Node<T> update(final Node<T> t) {\n\t\tt.dep = Math.max(depth(t.ch[0]), depth(t.ch[1]))\
    \ + 1;\n\t\tt.size = count(t.ch[0]) + count(t.ch[1]) + 1;\n\t\treturn t;\n\t}\n\
    \tprivate final Node<T> rotate(Node<T> t, final int b) {\n\t\tvar s = t.ch[1 -\
    \ b];\n\t\tt.ch[1 - b] = s.ch[b];\n\t\ts.ch[b] = t;\n\t\tt = update(t);\n\t\t\
    s = update(s);\n\t\treturn s;\n\t}\n\tprivate final Node<T> fetch(Node<T> t) {\n\
    \t\tif(t == null) {\n\t\t\treturn t;\n\t\t}\n\t\tif(depth(t.ch[0]) - depth(t.ch[1])\
    \ == 2) {\n\t\t\tif(depth(t.ch[0].ch[1]) > depth(t.ch[0].ch[0])) {\n\t\t\t\tt.ch[0]\
    \ = rotate(t.ch[0], 0);\n\t\t\t}\n\t\t\tt = rotate(t, 1);\n\t\t}\n\t\telse if(depth(t.ch[0])\
    \ - depth(t.ch[1]) == -2) {\n\t\t\tif (depth(t.ch[1].ch[0]) > depth(t.ch[1].ch[1]))\
    \ {\n\t\t\t\tt.ch[1] = rotate(t.ch[1], 1);\n\t\t\t}\n\t\t\tt = rotate(t, 0);\n\
    \t\t}\n\t\treturn t;\n\t}\n\tprivate final Node<T> insert(final Node<T> t, final\
    \ int k, final T v) {\n\t\tif(t == null) {\n\t\t\treturn new Node<T>(v, null,\
    \ null);\n\t\t}\n\t\tfinal int c = count(t.ch[0]), b = (k > c) ? 1 : 0;\n\t\t\
    t.ch[b] = insert(t.ch[b], k - (b == 1 ? (c + 1) : 0), v);\n\t\tupdate(t);\n\t\t\
    return fetch(t);\n\t}\n\tprivate final Node<T> erase(final Node<T> t) {\n\t\t\
    if(t == null || t.ch[0] == null && t.ch[1] == null) {\n\t\t\treturn null;\n\t\t\
    }\n\t\tif(t.ch[0] == null || t.ch[1] == null) {\n\t\t\treturn t.ch[t.ch[0] ==\
    \ null ? 1 : 0];\n\t\t}\n\t\treturn fetch(update(new Node<T>(find(t.ch[1], 0).val,\
    \ t.ch[0], erase(t.ch[1], 0))));\n\t}\n\tprivate final Node<T> erase(Node<T> t,\
    \ final int k) {\n\t\tif(t == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal int\
    \ c = count(t.ch[0]);\n\t\tif(k < c) {\n\t\t\tt.ch[0] = erase(t.ch[0], k);\n\t\
    \t\tt = update(t);\n\t\t}\n\t\telse if(k > c) {\n\t\t\tt.ch[1] = erase(t.ch[1],\
    \ k - (c + 1));\n\t\t\tt = update(t);\n\t\t}\n\t\telse {\n\t\t\tt = erase(t);\n\
    \t\t}\n\t\treturn fetch(t);\n\t}\n\tprivate final Node<T> find(final Node<T> t,\
    \ final int k) {\n\t\tif(t == null) {\n\t\t\treturn t;\n\t\t}\n\t\tfinal int c\
    \ = count(t.ch[0]);\n\t\treturn k < c ? find(t.ch[0], k) : k == c ? t : find(t.ch[1],\
    \ k - (c + 1));\n\t}\n\tprivate final int cnt(final Node<T> t, final T v) {\n\t\
    \tif(t == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(t.val.compareTo(v) < 0) {\n\t\
    \t\treturn count(t.ch[0]) + 1 + cnt(t.ch[1], v);\n\t\t}\n\t\tif(t.val.equals(v))\
    \ {\n\t\t\treturn count(t.ch[0]);\n\t\t}\n\t\treturn cnt(t.ch[0], v);\n\t}\n\t\
    AVLTree(){ root = null; }\n\tfinal void add(final T val){ root = insert(root,\
    \ cnt(root, val), val); }\n\tfinal void remove(final int k){ root = erase(root,\
    \ k); }\n\tfinal T get(final int k){ return find(root, k).val; }\n\tfinal int\
    \ count(final T val){ return cnt(root, val); }\n\tfinal int size(){ return root.size;\
    \ }\n\t@Override\n\tpublic final String toString() {\n\t\tfinal var sb = new StringBuilder();\n\
    \t\tsb.append(get(0));\n\t\tfor(int i = 0; ++i < root.size;) {\n\t\t\tsb.append(\"\
    \ \");\n\t\t\tsb.append(get(i));\n\t\t}\n\t\treturn \"[\" + sb.toString() + \"\
    ]\";\n\t}\n}\n\nfinal class Deque<T> implements Iterable<T> {\n\tprivate int n,\
    \ head, tail;\n\tprivate Object[] buf;\n\tDeque(){ this(1 << 17); }\n\tDeque(final\
    \ int n) {\n\t\tthis.n = n;\n\t\thead = tail = 0;\n\t\tbuf = new Object[n];\n\t\
    }\n\tDeque(final T[] a) {\n\t\tthis(a.length);\n\t\tArrays.stream(a).forEach(i\
    \ -> add(i));\n\t}\n\tprivate final int next(final int index) {\n\t\tfinal int\
    \ next = index + 1;\n\t\treturn next == n ? 0 : next;\n\t}\n\tprivate final int\
    \ prev(final int index) {\n\t\tfinal int prev = index - 1;\n\t\treturn prev ==\
    \ -1 ? n - 1 : prev;\n\t}\n\tprivate final int index(final int i) {\n\t\tfinal\
    \ int size = size();\n\t\tif(i >= size) {\n\t\t\tthrow new IndexOutOfBoundsException(\"\
    Index \"+ i +\" out of bounds for length \" + size);\n\t\t}\n\t\tfinal int id\
    \ = head + i;\n\t\treturn n <= id ? id - n : id;\n\t}\n\tprivate final void extend()\
    \ {\n\t\tbuf = Arrays.copyOf(buf, n << 1);\n\t\tn = buf.length;\n\t}\n\tfinal\
    \ boolean isEmpty(){ return size() == 0; }\n\tfinal int size() {\n\t\tfinal int\
    \ size = tail - head;\n\t\treturn size < 0 ? size + n : size;\n\t}\n\tfinal void\
    \ addFirst(final T x) {\n\t\thead = prev(head);\n\t\tif(head == tail) {\n\t\t\t\
    extend();\n\t\t}\n\t\tbuf[head] = x;\n\t}\n\tfinal void addLast(final T x) {\n\
    \t\tif(next(tail) == head) {\n\t\t\textend();\n\t\t}\n\t\tbuf[tail] = x;\n\t\t\
    tail = next(tail);\n\t}\n\tfinal void removeFirst() {\n\t\tif(head == tail) {\n\
    \t\t\tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\t}\n\t\thead\
    \ = next(head);\n\t}\n\tfinal void removeLast() {\n\t\tif(head == tail) {\n\t\t\
    \tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\t}\n\t\ttail = prev(tail);\n\
    \t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T pollFirst() {\n\t\tif(head\
    \ == tail) {\n\t\t\tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\
    \t}\n\t\tfinal T ans = (T) buf[head];\n\t\thead = next(head);\n\t\treturn ans;\n\
    \t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T pollLast() {\n\t\tif(head ==\
    \ tail) {\n\t\t\tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\t\
    }\n\t\ttail = prev(tail);\n\t\treturn (T) buf[tail];\n\t}\n\tfinal T peekFirst(){\
    \ return get(0); }\n\tfinal T peekLast(){ return get(n - 1); }\n\t@SuppressWarnings(\"\
    unchecked\")\n\tfinal T get(final int i){ return (T) buf[index(i)]; }\n\tfinal\
    \ void set(final int i, final T x){ buf[index(i)] = x; }\n\tfinal void add(final\
    \ T x){ addLast(x); }\n\tfinal T poll(){ return pollFirst(); }\n\tfinal T peek(){\
    \ return peekFirst(); }\n\t@SuppressWarnings(\"unchecked\")\n\tfinal void swap(final\
    \ int a, final int b) {\n\t\tfinal int i = index(a);\n\t\tfinal int j = index(b);\n\
    \t\tfinal T num = (T) buf[i];\n\t\tbuf[i] = buf[j];\n\t\tbuf[j] = num;\n\t}\n\t\
    final void clear(){ head = tail = 0; }\n\t@SuppressWarnings(\"unchecked\")\n\t\
    final T[] toArray(){ return (T[]) Arrays.copyOf(buf, size()); }\n\t@Override\n\
    \tpublic final String toString(){ return Arrays.toString(toArray()); }\n\t@Override\n\
    \tpublic final Iterator<T> iterator(){ return new DequeIterator(); }\n\tprivate\
    \ class DequeIterator implements Iterator<T> {\n\t\tprivate int now = head;\n\t\
    \tprivate int rem = size();\n\t\t@Override\n\t\tpublic boolean hasNext(){ return\
    \ rem > 0; }\n\t\t@Override\n\t\tpublic final T next() {\n\t\t\tif(!hasNext())\
    \ {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\t@SuppressWarnings(\"\
    unchecked\")\n\t\t\tfinal T res = (T) buf[now];\n\t\t\tnow = (now + 1) % n;\n\t\
    \t\trem--;\n\t\t\treturn res;\n\t\t}\n\t\t@Override\n\t\tpublic final void remove()\
    \ {\n\t\t\tif(isEmpty()) {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t\
    }\n\t\t\tnow = (now - 1 + n) % n;\n\t\t\tbuf[now] = null;\n\t\t\thead = (head\
    \ + 1) % n;\n\t\t\trem++;\n\t\t}\n\t}\n}\nfinal class IntDeque {\n\tprivate int\
    \ n, head, tail;\n\tprivate long[] buf;\n\tIntDeque(){ this(1 << 17); }\n\tIntDeque(final\
    \ int n) {\n\t\tthis.n = n;\n\t\thead = tail = 0;\n\t\tbuf = new long[n];\n\t\
    }\n\tIntDeque(final int[] a) {\n\t\tthis(a.length);\n\t\tArrays.stream(a).forEach(i\
    \ -> add(i));\n\t}\n\tIntDeque(final long[] a) {\n\t\tthis(a.length);\n\t\tArrays.stream(a).forEach(i\
    \ -> add(i));\n\t}\n\tprivate final int next(final int index) {\n\t\tfinal int\
    \ next = index + 1;\n\t\treturn next == n ? 0 : next;\n\t}\n\tprivate final int\
    \ prev(final int index) {\n\t\tfinal int prev = index - 1;\n\t\treturn prev ==\
    \ -1 ? n - 1 : prev;\n\t}\n\tprivate final int index(final int i) {\n\t\tfinal\
    \ int size = size();\n\t\tif(i >= size) {\n\t\t\tthrow new IndexOutOfBoundsException(\"\
    Index \"+ i +\" out of bounds for length \" + size);\n\t\t}\n\t\tfinal int id\
    \ = head + i;\n\t\treturn n <= id ? id - n : id;\n\t}\n\tprivate final void extend()\
    \ {\n\t\tbuf = Arrays.copyOf(buf, n << 1);\n\t\tn = buf.length;\n\t}\n\tfinal\
    \ boolean isEmpty(){ return size() == 0; }\n\tfinal int size() {\n\t\tfinal int\
    \ size = tail - head;\n\t\treturn size < 0 ? size + n : size;\n\t}\n\tfinal void\
    \ addFirst(final long x) {\n\t\thead = prev(head);\n\t\tif(head == tail) {\n\t\
    \t\textend();\n\t\t}\n\t\tbuf[head] = x;\n\t}\n\tfinal void addLast(final long\
    \ x) {\n\t\tif(next(tail) == head) {\n\t\t\textend();\n\t\t}\n\t\tbuf[tail] =\
    \ x;\n\t\ttail = next(tail);\n\t}\n\tfinal void removeFirst() {\n\t\tif(head ==\
    \ tail) {\n\t\t\tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\t\
    }\n\t\thead = next(head);\n\t}\n\tfinal void removeLast() {\n\t\tif(head == tail)\
    \ {\n\t\t\tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\t}\n\t\t\
    tail = prev(tail);\n\t}\n\tfinal long pollFirst() {\n\t\tif(head == tail) {\n\t\
    \t\tthrow new NoSuchElementException(\"Buffer is empty\");\n\t\t}\n\t\tfinal long\
    \ ans = buf[head];\n\t\thead = next(head);\n\t\treturn ans;\n\t}\n\tfinal long\
    \ pollLast() {\n\t\tif(head == tail) {\n\t\t\tthrow new NoSuchElementException(\"\
    Buffer is empty\");\n\t\t}\n\t\ttail = prev(tail);\n\t\treturn buf[tail];\n\t\
    }\n\tfinal long peekFirst(){ return get(0); }\n\tfinal long peekLast(){ return\
    \ get(n - 1); }\n\tfinal long get(final int i){ return buf[index(i)]; }\n\tfinal\
    \ void set(final int i, final long x){ buf[index(i)] = x; }\n\tfinal void add(final\
    \ long x){ addLast(x); }\n\tfinal long poll(){ return pollFirst(); }\n\tfinal\
    \ long peek(){ return peekFirst(); }\n\tfinal void swap(final int a, final int\
    \ b) {\n\t\tfinal int i = index(a);\n\t\tfinal int j = index(b);\n\t\tfinal long\
    \ num = buf[i];\n\t\tbuf[i] = buf[j];\n\t\tbuf[j] = num;\n\t}\n\tfinal void clear(){\
    \ head = tail = 0; }\n\tfinal long[] toArray(){ return Arrays.copyOf(buf, size());\
    \ }\n\t@Override\n\tpublic final String toString(){ return Arrays.toString(toArray());\
    \ }\n}\n"
  dependsOn:
  - Java/extension/SparseTable.java
  - Java/extension/PrimeCounter.java
  - Java/extension/PrefixSum.java
  - Java/extension/SegmentTree.java
  - Java/extension/DoubleEndedPriorityQueue.java
  - Java/extension/WeightedGraph.java
  - Java/extension/PrimeFactor.java
  - Java/extension/Deque.java
  - Java/extension/UnionFind.java
  - Java/extension/EulerPhiTable.java
  - Java/extension/PrimeTable.java
  - Java/extension/Huitloxopetl.java
  - Java/extension/LowestCommonAncestor.java
  - Java/extension/WaveletMatrix.java
  - Java/extension/WeightedUnionFind.java
  - Java/extension/UndoUnionFind.java
  - Java/extension/LargePrime.java
  - Java/extension/FenwickTree.java
  - Java/extension/SuffixArray.java
  - Java/extension/AVLTree.java
  - Java/extension/Graph.java
  - Java/extension/Template.java
  isVerificationFile: false
  path: Java/all.java
  requiredBy:
  - Java/extension/SparseTable.java
  - Java/extension/PrimeCounter.java
  - Java/extension/PrefixSum.java
  - Java/extension/SegmentTree.java
  - Java/extension/DoubleEndedPriorityQueue.java
  - Java/extension/WeightedGraph.java
  - Java/extension/PrimeFactor.java
  - Java/extension/Deque.java
  - Java/extension/UnionFind.java
  - Java/extension/EulerPhiTable.java
  - Java/extension/PrimeTable.java
  - Java/extension/Huitloxopetl.java
  - Java/extension/LowestCommonAncestor.java
  - Java/extension/WaveletMatrix.java
  - Java/extension/WeightedUnionFind.java
  - Java/extension/UndoUnionFind.java
  - Java/extension/LargePrime.java
  - Java/extension/FenwickTree.java
  - Java/extension/SuffixArray.java
  - Java/extension/AVLTree.java
  - Java/extension/Graph.java
  - Java/extension/Template.java
  timestamp: '2024-01-01 11:04:48+09:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: Java/all.java
layout: document
redirect_from:
- /library/Java/all.java
- /library/Java/all.java.html
title: Java/all.java
---
