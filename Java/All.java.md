---
data:
  _extendedDependsOn:
  - icon: ':warning:'
    path: Java/AOJ.java
    title: Java/AOJ.java
  - icon: ':warning:'
    path: Java/CodeForces.java
    title: Java/CodeForces.java
  - icon: ':warning:'
    path: Java/library/core/Main.java
    title: Java/library/core/Main.java
  - icon: ':warning:'
    path: Java/library/core/Utility.java
    title: Java/library/core/Utility.java
  - icon: ':warning:'
    path: Java/library/core/VvyLw.java
    title: Java/library/core/VvyLw.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/DSU.java
    title: Java/library/core/interfaces/DSU.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/QuadFunction.java
    title: Java/library/core/interfaces/lambda/QuadFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBiConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveBiConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBiFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveBiFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBiPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveBiPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoublePredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveDoublePredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveIntBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveIntConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveIntFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveIntPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveIntUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveLongBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveLongConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveLongFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveLongPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveLongUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursivePredicate.java
    title: Java/library/core/interfaces/lambda/RecursivePredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveTriConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveTriConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveTriFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveTriFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveTriPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveTriPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/TriConsumer.java
    title: Java/library/core/interfaces/lambda/TriConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/TriFunction.java
    title: Java/library/core/interfaces/lambda/TriFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/TriPredicate.java
    title: Java/library/core/interfaces/lambda/TriPredicate.java
  - icon: ':warning:'
    path: Java/library/core/io/IO.java
    title: Java/library/core/io/IO.java
  - icon: ':warning:'
    path: Java/library/core/io/MyPrinter.java
    title: Java/library/core/io/MyPrinter.java
  - icon: ':warning:'
    path: Java/library/core/io/MyScanner.java
    title: Java/library/core/io/MyScanner.java
  - icon: ':warning:'
    path: Java/library/ds/AVLTree.java
    title: Java/library/ds/AVLTree.java
  - icon: ':warning:'
    path: Java/library/ds/ConvexHullTrick.java
    title: Java/library/ds/ConvexHullTrick.java
  - icon: ':warning:'
    path: Java/library/ds/DoubleEndedPriorityQueue.java
    title: Java/library/ds/DoubleEndedPriorityQueue.java
  - icon: ':warning:'
    path: Java/library/ds/DualSegmentTree.java
    title: Java/library/ds/DualSegmentTree.java
  - icon: ':warning:'
    path: Java/library/ds/SegmentTree.java
    title: Java/library/ds/SegmentTree.java
  - icon: ':warning:'
    path: Java/library/ds/SparseTable.java
    title: Java/library/ds/SparseTable.java
  - icon: ':warning:'
    path: Java/library/ds/deque/IntDeque.java
    title: Java/library/ds/deque/IntDeque.java
  - icon: ':warning:'
    path: Java/library/ds/deque/MyDeque.java
    title: Java/library/ds/deque/MyDeque.java
  - icon: ':warning:'
    path: Java/library/ds/fenwicktree/FenwickTree.java
    title: Java/library/ds/fenwicktree/FenwickTree.java
  - icon: ':warning:'
    path: Java/library/ds/fenwicktree/RangeBIT.java
    title: Java/library/ds/fenwicktree/RangeBIT.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/LazySegmentTree.java
    title: Java/library/ds/lazysegmenttree/LazySegmentTree.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RAMN.java
    title: Java/library/ds/lazysegmenttree/RAMN.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RAMX.java
    title: Java/library/ds/lazysegmenttree/RAMX.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RASM.java
    title: Java/library/ds/lazysegmenttree/RASM.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RUMN.java
    title: Java/library/ds/lazysegmenttree/RUMN.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RUMX.java
    title: Java/library/ds/lazysegmenttree/RUMX.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RUSM.java
    title: Java/library/ds/lazysegmenttree/RUSM.java
  - icon: ':warning:'
    path: Java/library/ds/pair/FloatPair.java
    title: Java/library/ds/pair/FloatPair.java
  - icon: ':warning:'
    path: Java/library/ds/pair/IntPair.java
    title: Java/library/ds/pair/IntPair.java
  - icon: ':warning:'
    path: Java/library/ds/pair/Pair.java
    title: Java/library/ds/pair/Pair.java
  - icon: ':warning:'
    path: Java/library/ds/pair/Zwei.java
    title: Java/library/ds/pair/Zwei.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/MergeUnionFind.java
    title: Java/library/ds/unionfind/MergeUnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/UndoUnionFind.java
    title: Java/library/ds/unionfind/UndoUnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/UnionFind.java
    title: Java/library/ds/unionfind/UnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/WeightedUnionFind.java
    title: Java/library/ds/unionfind/WeightedUnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/waveletmatrix/SuccinctIndexableDictionary.java
    title: Java/library/ds/waveletmatrix/SuccinctIndexableDictionary.java
  - icon: ':warning:'
    path: Java/library/ds/waveletmatrix/WaveletMatrix.java
    title: Java/library/ds/waveletmatrix/WaveletMatrix.java
  - icon: ':warning:'
    path: Java/library/ds/waveletmatrix/WaveletMatrixBeta.java
    title: Java/library/ds/waveletmatrix/WaveletMatrixBeta.java
  - icon: ':warning:'
    path: Java/library/graph/Edge.java
    title: Java/library/graph/Edge.java
  - icon: ':warning:'
    path: Java/library/graph/Graph.java
    title: Java/library/graph/Graph.java
  - icon: ':warning:'
    path: Java/library/graph/LowestCommonAncestor.java
    title: Java/library/graph/LowestCommonAncestor.java
  - icon: ':warning:'
    path: Java/library/graph/MST.java
    title: Java/library/graph/MST.java
  - icon: ':warning:'
    path: Java/library/graph/SCC.java
    title: Java/library/graph/SCC.java
  - icon: ':warning:'
    path: Java/library/graph/ShortestPath.java
    title: Java/library/graph/ShortestPath.java
  - icon: ':warning:'
    path: Java/library/graph/WeightedGraph.java
    title: Java/library/graph/WeightedGraph.java
  - icon: ':warning:'
    path: Java/library/math/EulerPhiTable.java
    title: Java/library/math/EulerPhiTable.java
  - icon: ':warning:'
    path: Java/library/math/Matrix.java
    title: Java/library/math/Matrix.java
  - icon: ':warning:'
    path: Java/library/math/ModPrime.java
    title: Java/library/math/ModPrime.java
  - icon: ':warning:'
    path: Java/library/math/PrimeCounter.java
    title: Java/library/math/PrimeCounter.java
  - icon: ':warning:'
    path: Java/library/math/PrimeFactor.java
    title: Java/library/math/PrimeFactor.java
  - icon: ':warning:'
    path: Java/library/math/PrimeTable.java
    title: Java/library/math/PrimeTable.java
  - icon: ':warning:'
    path: Java/library/math/largeprime/BigPrime.java
    title: Java/library/math/largeprime/BigPrime.java
  - icon: ':warning:'
    path: Java/library/math/largeprime/LongPrime.java
    title: Java/library/math/largeprime/LongPrime.java
  - icon: ':warning:'
    path: Java/library/math/prefixsum/PrefixSum.java
    title: Java/library/math/prefixsum/PrefixSum.java
  - icon: ':warning:'
    path: Java/library/math/prefixsum/PrefixSum2D.java
    title: Java/library/math/prefixsum/PrefixSum2D.java
  - icon: ':warning:'
    path: Java/library/other/DP.java
    title: Java/library/other/DP.java
  - icon: ':warning:'
    path: Java/library/other/InclusiveScan.java
    title: Java/library/other/InclusiveScan.java
  - icon: ':warning:'
    path: Java/library/other/SkewHeap.java
    title: Java/library/other/SkewHeap.java
  - icon: ':warning:'
    path: Java/library/other/SuffixArray.java
    title: Java/library/other/SuffixArray.java
  - icon: ':warning:'
    path: Java/library/other/Why.java
    title: Java/library/other/Why.java
  - icon: ':warning:'
    path: Java/yukicoder.java
    title: Java/yukicoder.java
  _extendedRequiredBy:
  - icon: ':warning:'
    path: Java/AOJ.java
    title: Java/AOJ.java
  - icon: ':warning:'
    path: Java/CodeForces.java
    title: Java/CodeForces.java
  - icon: ':warning:'
    path: Java/library/core/Main.java
    title: Java/library/core/Main.java
  - icon: ':warning:'
    path: Java/library/core/Utility.java
    title: Java/library/core/Utility.java
  - icon: ':warning:'
    path: Java/library/core/VvyLw.java
    title: Java/library/core/VvyLw.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/DSU.java
    title: Java/library/core/interfaces/DSU.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/QuadFunction.java
    title: Java/library/core/interfaces/lambda/QuadFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBiConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveBiConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBiFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveBiFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBiPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveBiPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoublePredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveDoublePredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveDoubleUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveDoubleUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveIntBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveIntConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveIntFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveIntPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveIntUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveIntUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongBinaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveLongBinaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveLongConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveLongFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveLongPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveLongUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveLongUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursivePredicate.java
    title: Java/library/core/interfaces/lambda/RecursivePredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveTriConsumer.java
    title: Java/library/core/interfaces/lambda/RecursiveTriConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveTriFunction.java
    title: Java/library/core/interfaces/lambda/RecursiveTriFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveTriPredicate.java
    title: Java/library/core/interfaces/lambda/RecursiveTriPredicate.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/RecursiveUnaryOperator.java
    title: Java/library/core/interfaces/lambda/RecursiveUnaryOperator.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/TriConsumer.java
    title: Java/library/core/interfaces/lambda/TriConsumer.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/TriFunction.java
    title: Java/library/core/interfaces/lambda/TriFunction.java
  - icon: ':warning:'
    path: Java/library/core/interfaces/lambda/TriPredicate.java
    title: Java/library/core/interfaces/lambda/TriPredicate.java
  - icon: ':warning:'
    path: Java/library/core/io/IO.java
    title: Java/library/core/io/IO.java
  - icon: ':warning:'
    path: Java/library/core/io/MyPrinter.java
    title: Java/library/core/io/MyPrinter.java
  - icon: ':warning:'
    path: Java/library/core/io/MyScanner.java
    title: Java/library/core/io/MyScanner.java
  - icon: ':warning:'
    path: Java/library/ds/AVLTree.java
    title: Java/library/ds/AVLTree.java
  - icon: ':warning:'
    path: Java/library/ds/ConvexHullTrick.java
    title: Java/library/ds/ConvexHullTrick.java
  - icon: ':warning:'
    path: Java/library/ds/DoubleEndedPriorityQueue.java
    title: Java/library/ds/DoubleEndedPriorityQueue.java
  - icon: ':warning:'
    path: Java/library/ds/DualSegmentTree.java
    title: Java/library/ds/DualSegmentTree.java
  - icon: ':warning:'
    path: Java/library/ds/SegmentTree.java
    title: Java/library/ds/SegmentTree.java
  - icon: ':warning:'
    path: Java/library/ds/SparseTable.java
    title: Java/library/ds/SparseTable.java
  - icon: ':warning:'
    path: Java/library/ds/deque/IntDeque.java
    title: Java/library/ds/deque/IntDeque.java
  - icon: ':warning:'
    path: Java/library/ds/deque/MyDeque.java
    title: Java/library/ds/deque/MyDeque.java
  - icon: ':warning:'
    path: Java/library/ds/fenwicktree/FenwickTree.java
    title: Java/library/ds/fenwicktree/FenwickTree.java
  - icon: ':warning:'
    path: Java/library/ds/fenwicktree/RangeBIT.java
    title: Java/library/ds/fenwicktree/RangeBIT.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/LazySegmentTree.java
    title: Java/library/ds/lazysegmenttree/LazySegmentTree.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RAMN.java
    title: Java/library/ds/lazysegmenttree/RAMN.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RAMX.java
    title: Java/library/ds/lazysegmenttree/RAMX.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RASM.java
    title: Java/library/ds/lazysegmenttree/RASM.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RUMN.java
    title: Java/library/ds/lazysegmenttree/RUMN.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RUMX.java
    title: Java/library/ds/lazysegmenttree/RUMX.java
  - icon: ':warning:'
    path: Java/library/ds/lazysegmenttree/RUSM.java
    title: Java/library/ds/lazysegmenttree/RUSM.java
  - icon: ':warning:'
    path: Java/library/ds/pair/FloatPair.java
    title: Java/library/ds/pair/FloatPair.java
  - icon: ':warning:'
    path: Java/library/ds/pair/IntPair.java
    title: Java/library/ds/pair/IntPair.java
  - icon: ':warning:'
    path: Java/library/ds/pair/Pair.java
    title: Java/library/ds/pair/Pair.java
  - icon: ':warning:'
    path: Java/library/ds/pair/Zwei.java
    title: Java/library/ds/pair/Zwei.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/MergeUnionFind.java
    title: Java/library/ds/unionfind/MergeUnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/UndoUnionFind.java
    title: Java/library/ds/unionfind/UndoUnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/UnionFind.java
    title: Java/library/ds/unionfind/UnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/unionfind/WeightedUnionFind.java
    title: Java/library/ds/unionfind/WeightedUnionFind.java
  - icon: ':warning:'
    path: Java/library/ds/waveletmatrix/SuccinctIndexableDictionary.java
    title: Java/library/ds/waveletmatrix/SuccinctIndexableDictionary.java
  - icon: ':warning:'
    path: Java/library/ds/waveletmatrix/WaveletMatrix.java
    title: Java/library/ds/waveletmatrix/WaveletMatrix.java
  - icon: ':warning:'
    path: Java/library/ds/waveletmatrix/WaveletMatrixBeta.java
    title: Java/library/ds/waveletmatrix/WaveletMatrixBeta.java
  - icon: ':warning:'
    path: Java/library/graph/Edge.java
    title: Java/library/graph/Edge.java
  - icon: ':warning:'
    path: Java/library/graph/Graph.java
    title: Java/library/graph/Graph.java
  - icon: ':warning:'
    path: Java/library/graph/LowestCommonAncestor.java
    title: Java/library/graph/LowestCommonAncestor.java
  - icon: ':warning:'
    path: Java/library/graph/MST.java
    title: Java/library/graph/MST.java
  - icon: ':warning:'
    path: Java/library/graph/SCC.java
    title: Java/library/graph/SCC.java
  - icon: ':warning:'
    path: Java/library/graph/ShortestPath.java
    title: Java/library/graph/ShortestPath.java
  - icon: ':warning:'
    path: Java/library/graph/WeightedGraph.java
    title: Java/library/graph/WeightedGraph.java
  - icon: ':warning:'
    path: Java/library/math/EulerPhiTable.java
    title: Java/library/math/EulerPhiTable.java
  - icon: ':warning:'
    path: Java/library/math/Matrix.java
    title: Java/library/math/Matrix.java
  - icon: ':warning:'
    path: Java/library/math/ModPrime.java
    title: Java/library/math/ModPrime.java
  - icon: ':warning:'
    path: Java/library/math/PrimeCounter.java
    title: Java/library/math/PrimeCounter.java
  - icon: ':warning:'
    path: Java/library/math/PrimeFactor.java
    title: Java/library/math/PrimeFactor.java
  - icon: ':warning:'
    path: Java/library/math/PrimeTable.java
    title: Java/library/math/PrimeTable.java
  - icon: ':warning:'
    path: Java/library/math/largeprime/BigPrime.java
    title: Java/library/math/largeprime/BigPrime.java
  - icon: ':warning:'
    path: Java/library/math/largeprime/LongPrime.java
    title: Java/library/math/largeprime/LongPrime.java
  - icon: ':warning:'
    path: Java/library/math/prefixsum/PrefixSum.java
    title: Java/library/math/prefixsum/PrefixSum.java
  - icon: ':warning:'
    path: Java/library/math/prefixsum/PrefixSum2D.java
    title: Java/library/math/prefixsum/PrefixSum2D.java
  - icon: ':warning:'
    path: Java/library/other/DP.java
    title: Java/library/other/DP.java
  - icon: ':warning:'
    path: Java/library/other/InclusiveScan.java
    title: Java/library/other/InclusiveScan.java
  - icon: ':warning:'
    path: Java/library/other/SkewHeap.java
    title: Java/library/other/SkewHeap.java
  - icon: ':warning:'
    path: Java/library/other/SuffixArray.java
    title: Java/library/other/SuffixArray.java
  - icon: ':warning:'
    path: Java/library/other/Why.java
    title: Java/library/other/Why.java
  - icon: ':warning:'
    path: Java/yukicoder.java
    title: Java/yukicoder.java
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: java
  _verificationStatusIcon: ':warning:'
  attributes: {}
  bundledCode: "Traceback (most recent call last):\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/documentation/build.py\"\
    , line 71, in _render_source_code_stat\n    bundled_code = language.bundle(stat.path,\
    \ basedir=basedir, options={'include_paths': [basedir]}).decode()\n  File \"/home/runner/.local/lib/python3.10/site-packages/onlinejudge_verify/languages/user_defined.py\"\
    , line 68, in bundle\n    raise RuntimeError('bundler is not specified: {}'.format(str(path)))\n\
    RuntimeError: bundler is not specified: Java/All.java\n"
  code: "import static java.lang.Math.*;\n\nimport java.io.Closeable;\nimport java.io.Flushable;\n\
    import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\
    import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\n\
    import java.util.Comparator;\nimport java.util.Formatter;\nimport java.util.HashMap;\n\
    import java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport\
    \ java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.PriorityQueue;\n\
    import java.util.Queue;\nimport java.util.Stack;\nimport java.util.TreeMap;\n\
    import java.util.function.BiFunction;\nimport java.util.function.BiPredicate;\n\
    import java.util.function.BinaryOperator;\nimport java.util.function.Consumer;\n\
    import java.util.function.DoublePredicate;\nimport java.util.function.IntPredicate;\n\
    import java.util.function.IntUnaryOperator;\nimport java.util.function.LongBinaryOperator;\n\
    import java.util.function.LongPredicate;\nimport java.util.function.LongUnaryOperator;\n\
    import java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\n\
    import java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nfinal\
    \ class Main {\n\tpublic static void main(final String[] args) {\n\t\tIntStream.range(0,\
    \ VvyLw.MULTI ? VvyLw.io.ni() : 1).forEach(i -> VvyLw.solve());\n\t\tVvyLw.io.close();\n\
    \t}\n}\n\nfinal class VvyLw extends Utility {\n\tstatic final IO io = new IO(System.in,\
    \ System.out, System.err, false);\n\tstatic final boolean MULTI = false;\n\tstatic\
    \ final int INF = 1 << 30;\n\tstatic final long LINF = (1L << 61) - 1;\n\tstatic\
    \ final double EPS = 1e-18;\n\tstatic final int MOD = 998244353;\n\tstatic final\
    \ int M0D = (int) 1e9 + 7;\n\tstatic final int[] dx = {0, -1, 1, 0, 0, -1, -1,\
    \ 1, 1};\n\tstatic final int[] dy = {0, 0, 0, -1, 1, -1, 1, -1, 1};\n\tstatic\
    \ final void solve() {\n\t\t\n\t}\n}\nclass Utility {\n\tprotected static final\
    \ String yes(final boolean ok){ return ok ? \"Yes\" : \"No\"; }\n\tprotected static\
    \ final String no(final boolean ok){ return yes(!ok); }\n\tprotected static final\
    \ long sqr(final long x){ return x * x; }\n\tprotected static final int mod(long\
    \ n, final int m) {\n\t\tn %= m;\n\t\treturn (int) (n < 0 ? n + m : n);\n\t}\n\
    \tprotected static final long mod(long n, final long m) {\n\t\tn %= m;\n\t\treturn\
    \ n < 0 ? n + m : n;\n\t}\n\tprotected static final long intCeil(final long a,\
    \ final long b){ return a == 0 ? 0 : (a - 1) / b + 1; }\n\tprotected static final\
    \ double intRound(final double a, final long b, final int c) {\n\t\tfinal long\
    \ d = intPow(10, c);\n\t\treturn rint((a * d) / b) / d;\n\t}\n\tprotected static\
    \ final long intPow(long a, int b) {\n\t\tlong res = 1;\n\t\twhile(b > 0) {\n\t\
    \t\tif(b % 2 == 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tb >>= 1;\n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final long intPow(long a, long\
    \ b, final long m) {\n\t\tlong res = 1;\n\t\twhile(b > 0) {\n\t\t\tif(b % 2 ==\
    \ 1) {\n\t\t\t\tres *= a;\n\t\t\t\tres = mod(res, m);\n\t\t\t}\n\t\t\ta *= a;\n\
    \t\t\ta = mod(a, m);\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected\
    \ static final long inv(long a, final long m) {\n\t\tlong b = m, u = 1, v = 0;\n\
    \t\twhile(b > 0) {\n\t\t\tfinal long t = a / b;\n\t\t\ta -= t * b;\n\t\t\ta ^=\
    \ b;\n\t\t\tb ^= a;\n\t\t\ta ^= b;\n\t\t\tu -= t * v;\n\t\t\tu ^= v;\n\t\t\tv\
    \ ^= u;\n\t\t\tu ^= v;\n\t\t}\n\t\treturn mod(u, m);\n\t}\n\tprotected static\
    \ final long lcm(final long a, final long b){ return a / gcd(a, b) * b; }\n\t\
    protected static final long lcm(final int... a){ return Arrays.stream(a).asLongStream().reduce(1,\
    \ (x, y) -> lcm(x, y)); }\n\tprotected static final long lcm(final long... a){\
    \ return Arrays.stream(a).reduce(1, (x, y) -> lcm(x, y)); }\n\tprotected static\
    \ final long gcd(final long a, final long b){ return b > 0 ? gcd(b, a % b) : a;\
    \ }\n\tprotected static final int gcd(final int... a){ return Arrays.stream(a).reduce(0,\
    \ (x, y) -> (int) gcd(x, y)); }\n\tprotected static final long gcd(final long...\
    \ a){ return Arrays.stream(a).reduce(0, (x, y) -> gcd(x, y)); }\n\tprotected static\
    \ final int min(final int... a){ return Arrays.stream(a).min().getAsInt(); }\n\
    \tprotected static final long min(final long... a){ return Arrays.stream(a).min().getAsLong();\
    \ }\n\tprotected static final double min(final double... a){ return Arrays.stream(a).min().getAsDouble();\
    \ }\n\tprotected static final int max(final int... a){ return Arrays.stream(a).max().getAsInt();\
    \ }\n\tprotected static final long max(final long... a){ return Arrays.stream(a).max().getAsLong();\
    \ }\n\tprotected static final double max(final double... a){ return Arrays.stream(a).max().getAsDouble();\
    \ }\n\tprotected static final long sum(final int... a){ return Arrays.stream(a).asLongStream().sum();\
    \ }\n\tprotected static final long sum(final long... a){ return Arrays.stream(a).sum();\
    \ }\n\tprotected static final double sum(final double... a){ return Arrays.stream(a).sum();\
    \ }\n\tprotected static final long prod(final int... a){ return Arrays.stream(a).asLongStream().reduce(1,\
    \ (x, y) -> x * y); }\n\tprotected static final long prod(final long... a){ return\
    \ Arrays.stream(a).reduce(1, (x, y) -> x * y); }\n\tprotected static final double\
    \ prod(final double... a){ return Arrays.stream(a).reduce(1, (x, y) -> x * y);\
    \ }\n\tprotected static final double ave(final int... a){ return Arrays.stream(a).average().getAsDouble();\
    \ }\n\tprotected static final double ave(final long... a){ return Arrays.stream(a).average().getAsDouble();\
    \ }\n\tprotected static final double ave(final double... a){ return Arrays.stream(a).average().getAsDouble();\
    \ }\n\tprotected static final double median(final int[] a) {\n\t\tassert isSorted(a);\n\
    \t\tfinal int m = a.length / 2;\n\t\treturn a.length % 2 != 0 ? a[m] : (a[m -\
    \ 1] + a[m]) / 2.0;\n\t}\n\tprotected static final double median(final long[]\
    \ a) {\n\t\tassert isSorted(a);\n\t\tfinal int m = a.length / 2;\n\t\treturn a.length\
    \ % 2 != 0 ? a[m] : (a[m - 1] + a[m]) / 2.0;\n\t}\n\tprotected static final double\
    \ median(final double[] a) {\n\t\tassert isSorted(a);\n\t\tfinal int m = a.length\
    \ / 2;\n\t\treturn a.length % 2 != 0 ? a[m] : (a[m - 1] + a[m]) / 2;\n\t}\n\t\
    protected static final long[] div(final long n) {\n\t\tfinal ArrayList<Long> d\
    \ = new ArrayList<>();\n\t\tfor(long i = 1; i * i <= n; ++i) {\n\t\t\tif(n % i\
    \ == 0) {\n\t\t\t\td.add(i);\n\t\t\t\tif(i * i != n) {\n\t\t\t\t\td.add(n / i);\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d.stream().mapToLong(i -> i).sorted().toArray();\n\
    \t}\n\tprotected static final IntPair[] primeFactor(long n) {\n\t\tfinal ArrayList<IntPair>\
    \ pf = new ArrayList<>();\n\t\tfor(long i = 2; i * i <= n; ++i) {\n\t\t\tif(n\
    \ % i != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\twhile(n %\
    \ i == 0) {\n\t\t\t\tcnt++;\n\t\t\t\tn /= i;\n\t\t\t}\n\t\t\tpf.add(IntPair.of(i,\
    \ cnt));\n\t\t}\n\t\tif(n != 1) {\n\t\t\tpf.add(IntPair.of(n, 1));\n\t\t}\n\t\t\
    return pf.toArray(IntPair[]::new);\n\t}\n\tprotected static final long eulerPhi(long\
    \ n) {\n\t\tlong res = n;\n\t\tfor(long i = 2; i * i <= n; ++i) {\n\t\t\tif(n\
    \ % i == 0) {\n\t\t\t\tres -= res / i;\n\t\t\t\twhile(n % i == 0) {\n\t\t\t\t\t\
    n /= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n > 1) {\n\t\t\tres -= res / n;\n\t\
    \t}\n\t\treturn res;\n\t}\n\tprotected static final long sigma(final long n){\
    \ return n * (n + 1) / 2; }\n\tprotected static final long sigma(final long a,\
    \ final long b){ return sigma(b) - sigma(a - 1); } \n\tprotected static final\
    \ long fact(int n) {\n\t\tlong res = 1;\n\t\twhile(n > 0) {\n\t\t\tres *= n--;\n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final long fact(int n, final long\
    \ mod) {\n\t\tlong res = 1;\n\t\twhile(n > 0) {\n\t\t\tres *= n--;\n\t\t\tres\
    \ %= mod;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static final long perm(final\
    \ int n, final int r) {\n\t\tint m = n;\n\t\tlong res = 1;\n\t\twhile(m > n -\
    \ r) {\n\t\t\tres *= m--;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static final\
    \ long perm(final int n, final int r, final long mod) {\n\t\tint m = n;\n\t\t\
    long res = 1;\n\t\twhile(m > n - r) {\n\t\t\tres *= m--;\n\t\t\tres %= mod; \n\
    \t\t}\n\t\treturn res;\n\t}\n\tprotected static final long binom(final int n,\
    \ final int r) {\n\t\tif(r < 0 || n < r) {\n\t\t\treturn 0;\n\t\t}\n\t\tint tmp\
    \ = n;\n\t\tlong res = 1;\n\t\tfor(int i = 1; i <= min(n - r, r); ++i) {\n\t\t\
    \tres *= tmp--;\n\t\t\tres /= i;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static\
    \ final long binom(final int n, final int r, final long mod) {\n\t\tif(r < 0 ||\
    \ n < r) {\n\t\t\treturn 0;\n\t\t}\n\t\tint tmp = n;\n\t\tlong res = 1;\n\t\t\
    for(int i = 1; i <= min(n - r, r); ++i) {\n\t\t\tres *= tmp--;\n\t\t\tres = mod;\n\
    \t\t\tres /= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}\n\tprotected static\
    \ final boolean isInt(final double n){ return n == (long) floor(n); }\n\tprotected\
    \ static final boolean isSqr(final long n){ return isInt(sqrt(n)); }\n\tprotected\
    \ static final boolean isPrime(final long n) {\n\t\tif(n == 1) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tfor(long i = 2; i * i <= n; ++i) {\n\t\t\tif(n % i == 0)\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprotected\
    \ static final boolean scope(final int l, final int x, final int r){ return l\
    \ <= x && x <= r; }\n\tprotected static final boolean scope(final long l, final\
    \ long x, final long r){ return l <= x && x <= r; }\n\tprotected static final\
    \ boolean scope(final double l, final double x, final double r){ return l <= x\
    \ && x <= r; }\n\tprotected static final int clamp(final int l, final int x, final\
    \ int r){ return x < l ? l : x > r ? r : x; }\n\tprotected static final long clamp(final\
    \ long l, final long x, final long r){ return x < l ? l : x > r ? r : x; }\n\t\
    protected static final double clamp(final double l, final double x, final double\
    \ r){ return x < l ? l : x > r ? r : x; }\n\tprotected static final boolean isBit(final\
    \ long i, final long j){ return (i >> j & 1) == 1; }\n\tprotected static final\
    \ boolean nextPerm(final int[] a) {\n\t\ttry {\n\t\t\tfinal int[] res = nextPermutation(a);\n\
    \t\t\tSystem.arraycopy(res, 0, a, 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final\
    \ NullPointerException e) {\n\t\t\tArrays.sort(a);\n\t\t\treturn false;\n\t\t\
    }\n\t}\n\tprotected static final boolean nextPerm(final long[] a) {\n\t\ttry {\n\
    \t\t\tfinal long[] res = nextPermutation(a);\n\t\t\tSystem.arraycopy(res, 0, a,\
    \ 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final NullPointerException e)\
    \ {\n\t\t\tArrays.sort(a);\n\t\t\treturn false;\n\t\t}\n\t}\n\tprotected static\
    \ final boolean nextPerm(final double[] a) {\n\t\ttry {\n\t\t\tfinal double[]\
    \ res = nextPermutation(a);\n\t\t\tSystem.arraycopy(res, 0, a, 0, a.length);\n\
    \t\t\treturn true;\n\t\t} catch(final NullPointerException e) {\n\t\t\tArrays.sort(a);\n\
    \t\t\treturn false;\n\t\t}\n\t}\n\tprotected static final boolean nextPerm(final\
    \ char[] a) {\n\t\ttry {\n\t\t\tfinal char[] res = nextPermutation(a);\n\t\t\t\
    System.arraycopy(res, 0, a, 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final\
    \ NullPointerException e) {\n\t\t\tArrays.sort(a);\n\t\t\treturn false;\n\t\t\
    }\n\t}\n\tprotected static final boolean prevPerm(final int[] a) {\n\t\ttry {\n\
    \t\t\tfinal int[] res = prevPermutation(a);\n\t\t\tSystem.arraycopy(res, 0, a,\
    \ 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final NullPointerException e)\
    \ {\n\t\t\tfinal int[] res = reverse(sorted(a));\n\t\t\tSystem.arraycopy(res,\
    \ 0, a, 0, a.length);\n\t\t\treturn false;\n\t\t}\n\t}\n\tprotected static final\
    \ boolean prevPerm(final long[] a) {\n\t\ttry {\n\t\t\tfinal long[] res = prevPermutation(a);\n\
    \t\t\tSystem.arraycopy(res, 0, a, 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final\
    \ NullPointerException e) {\n\t\t\tfinal long[] res = reverse(sorted(a));\n\t\t\
    \tSystem.arraycopy(res, 0, a, 0, a.length);\n\t\t\treturn false;\n\t\t}\n\t}\n\
    \tprotected static final boolean prevPerm(final double[] a) {\n\t\ttry {\n\t\t\
    \tfinal double[] res = prevPermutation(a);\n\t\t\tSystem.arraycopy(res, 0, a,\
    \ 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final NullPointerException e)\
    \ {\n\t\t\tfinal double[] res = reverse(sorted(a));\n\t\t\tSystem.arraycopy(res,\
    \ 0, a, 0, a.length);\n\t\t\treturn false;\n\t\t}\n\t}\n\tprotected static final\
    \ boolean prevPerm(final char[] a) {\n\t\ttry {\n\t\t\tfinal char[] res = prevPermutation(a);\n\
    \t\t\tSystem.arraycopy(res, 0, a, 0, a.length);\n\t\t\treturn true;\n\t\t} catch(final\
    \ NullPointerException e) {\n\t\t\tfinal char[] res = reverse(sorted(a));\n\t\t\
    \tSystem.arraycopy(res, 0, a, 0, a.length);\n\t\t\treturn false;\n\t\t}\n\t}\n\
    \tprivate static final int[] nextPermutation(final int[] a) {\n\t\tfor(int i =\
    \ a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i]) {\n\t\t\t\tfinal int j = find(a[i\
    \ - 1], a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\tArrays.sort(a,\
    \ i, a.length);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\
    private static final long[] nextPermutation(final long[] a) {\n\t\tfor(int i =\
    \ a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i]) {\n\t\t\t\tfinal int j = find(a[i\
    \ - 1], a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\tArrays.sort(a,\
    \ i, a.length);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\
    private static final double[] nextPermutation(final double[] a) {\n\t\tfor(int\
    \ i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i]) {\n\t\t\t\tfinal int j\
    \ = find(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\t\
    Arrays.sort(a, i, a.length);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\
    \t}\n\tprivate static final char[] nextPermutation(final char[] a) {\n\t\tfor(int\
    \ i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] < a[i]) {\n\t\t\t\tfinal int j\
    \ = find(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\t\
    Arrays.sort(a, i, a.length);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\
    \t}\n\tprivate static final int[] prevPermutation(final int[] a) {\n\t\tfor(int\
    \ i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] > a[i]) {\n\t\t\t\tfinal int j\
    \ = findRev(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\
    \tArrays.sort(a, i, a.length);\n\t\t\t\treverse(a, i, a.length - 1);\n\t\t\t\t\
    return a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate static final long[]\
    \ prevPermutation(final long[] a) {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\
    \t\tif(a[i - 1] > a[i]) {\n\t\t\t\tfinal int j = findRev(a[i - 1], a, i, a.length\
    \ - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\
    \t\treverse(a, i, a.length - 1);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ null;\n\t}\n\tprivate static final double[] prevPermutation(final double[] a)\
    \ {\n\t\tfor(int i = a.length; --i > 0;) {\n\t\t\tif(a[i - 1] > a[i]) {\n\t\t\t\
    \tfinal int j = findRev(a[i - 1], a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1,\
    \ j);\n\t\t\t\tArrays.sort(a, i, a.length);\n\t\t\t\treverse(a, i, a.length -\
    \ 1);\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate static\
    \ final char[] prevPermutation(final char[] a) {\n\t\tfor(int i = a.length; --i\
    \ > 0;) {\n\t\t\tif(a[i - 1] > a[i]) {\n\t\t\t\tfinal int j = findRev(a[i - 1],\
    \ a, i, a.length - 1);\n\t\t\t\tswap(a, i - 1, j);\n\t\t\t\tArrays.sort(a, i,\
    \ a.length);\n\t\t\t\treverse(a, i, a.length - 1);\n\t\t\t\treturn a;\n\t\t\t\
    }\n\t\t}\n\t\treturn null;\n\t}\n\tprivate static final int find(final int dest,\
    \ final int[] a, final int s, final int e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\
    \t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] <= dest ? find(dest,\
    \ a, s, m - 1) : find(dest, a, m, e);\n\t}\n\tprivate static final int find(final\
    \ long dest, final long[] a, final int s, final int e) {\n\t\tif(s == e) {\n\t\
    \t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] <= dest\
    \ ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n\t}\n\tprivate static final\
    \ int find(final double dest, final double[] a, final int s, final int e) {\n\t\
    \tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\
    \treturn a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n\t}\n\t\
    private static final int find(final char dest, final char[] a, final int s, final\
    \ int e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e\
    \ + 1) / 2;\n\t\treturn a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a,\
    \ m, e);\n\t}\n\tprivate static final int findRev(final int dest, final int[]\
    \ a, final int s, final int e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\
    \tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] > dest ? findRev(dest, a, s,\
    \ m - 1) : findRev(dest, a, m, e);\n\t}\n\tprivate static final int findRev(final\
    \ long dest, final long[] a, final int s, final int e) {\n\t\tif(s == e) {\n\t\
    \t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] > dest\
    \ ? findRev(dest, a, s, m - 1) : findRev(dest, a, m, e);\n\t}\n\tprivate static\
    \ final int findRev(final double dest, final double[] a, final int s, final int\
    \ e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tfinal int m = (s + e + 1)\
    \ / 2;\n\t\treturn a[m] > dest ? findRev(dest, a, s, m - 1) : findRev(dest, a,\
    \ m, e);\n\t}\n\tprivate static final int findRev(final char dest, final char[]\
    \ a, final int s, final int e) {\n\t\tif(s == e) {\n\t\t\treturn s;\n\t\t}\n\t\
    \tfinal int m = (s + e + 1) / 2;\n\t\treturn a[m] > dest ? findRev(dest, a, s,\
    \ m - 1) : findRev(dest, a, m, e);\n\t}\n\tprivate static void reverse(final int[]\
    \ arr, int start, int end) {\n\t\twhile(start < end) {\n\t\t\tswap(arr, start,\
    \ end);\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n\tprivate static void reverse(final\
    \ long[] arr, int start, int end) {\n\t\twhile(start < end) {\n\t\t\tswap(arr,\
    \ start, end);\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n\tprivate static void\
    \ reverse(final double[] arr, int start, int end) {\n\t\twhile(start < end) {\n\
    \t\t\tswap(arr, start, end);\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n\tprivate\
    \ static void reverse(final char[] arr, int start, int end) {\n\t\twhile(start\
    \ < end) {\n\t\t\tswap(arr, start, end);\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\
    \t}\n\tprotected static final int find(final int[] a, final int x) {\n\t\tfor(int\
    \ i = 0; i < a.length; ++i) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t\
    }\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int find(final long[]\
    \ a, final long x) {\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tif(a[i] ==\
    \ x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static\
    \ final int find(final double[] a, final double x) {\n\t\tfor(int i = 0; i < a.length;\
    \ ++i) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ -1;\n\t}\n\tprotected static final int find(final char[] s, final char c) {\n\
    \t\tfor(int i = 0; i < s.length; ++i) {\n\t\t\tif(s[i] == c) {\n\t\t\t\treturn\
    \ i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int find(final\
    \ Object[] a, final Object x) {\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\
    \tif(a[i].equals(x)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t\
    }\n\tprotected static final int findRev(final int[] a, final int x) {\n\t\tfor(int\
    \ i = a.length; --i >= 0;) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t\
    }\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int findRev(final long[]\
    \ a, final long x) {\n\t\tfor(int i = a.length; --i >= 0;) {\n\t\t\tif(a[i] ==\
    \ x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static\
    \ final int findRev(final double[] a, final double x) {\n\t\tfor(int i = a.length;\
    \ --i >= 0;) {\n\t\t\tif(a[i] == x) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\t\
    return -1;\n\t}\n\tprotected static final int findRev(final char[] s, final char\
    \ c) {\n\t\tfor(int i = s.length; --i >= 0;) {\n\t\t\tif(s[i] == c) {\n\t\t\t\t\
    return i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tprotected static final int findRev(final\
    \ Object[] a, final Object x) {\n\t\tfor(int i = a.length; --i >= 0;) {\n\t\t\t\
    if(a[i].equals(x)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\
    \tprotected static final boolean binarySearch(final int[] a, final int x){ return\
    \ Arrays.binarySearch(a, x) >= 0; }\n\tprotected static final boolean binarySearch(final\
    \ long[] a, final long x){ return Arrays.binarySearch(a, x) >= 0; }\n\tprotected\
    \ static final <T extends Comparable<? super T>> boolean binarySearch(final T[]\
    \ a, final T x){ return Arrays.binarySearch(a, x) >= 0; }\n\tprotected static\
    \ final <T extends Comparable<? super T>> boolean binarySearch(final List<T> a,\
    \ final T x){ return Collections.binarySearch(a, x, null) >= 0; }\n\tprotected\
    \ static final int lowerBound(final int[] a, final int x){ return bins(a.length,\
    \ -1, (IntPredicate) y -> a[y] >= x); }\n\tprotected static final int lowerBound(final\
    \ long[] a, final long x){ return bins(a.length, -1, (IntPredicate) y -> a[y]\
    \ >= x); }\n\tprotected static final <T extends Comparable<? super T>> int lowerBound(final\
    \ T[] a, final T x){ return lowerBound(Arrays.asList(a), x); }\n\tprotected static\
    \ final <T extends Comparable<? super T>> int lowerBound(final List<T> a, final\
    \ T x){ return ~Collections.binarySearch(a, x, (p, q) -> p.compareTo(q) >= 0 ?\
    \ 1 : -1); }\n\tprotected static final int upperBound(final int[] a, final int\
    \ x){ return bins(a.length, -1, (IntPredicate) y -> a[y] > x); }\n\tprotected\
    \ static final int upperBound(final long[] a, final long x){ return bins(a.length,\
    \ -1, (IntPredicate) y -> a[y] > x); }\n\tprotected static final <T extends Comparable<?\
    \ super T>> int upperBound(final T[] a, final T x){ return upperBound(Arrays.asList(a),\
    \ x); }\n\tprotected static final <T extends Comparable<? super T>> int upperBound(final\
    \ List<T> a, final T x){ return ~Collections.binarySearch(a, x, (p, q) -> p.compareTo(q)\
    \ > 0 ? 1 : -1); }\n\tprotected static final String sorted(final String s){ return\
    \ s.chars().sorted().mapToObj(Character::toString).collect(Collectors.joining());\
    \ }\n\tprotected static final int[] sorted(final int[] a){ return Arrays.stream(a).sorted().toArray();\
    \ }\n\tprotected static final long[] sorted(final long[] a){ return Arrays.stream(a).sorted().toArray();\
    \ }\n\tprotected static final double[] sorted(final double[] a){ return Arrays.stream(a).sorted().toArray();\
    \ }\n\tprotected static final char[] sorted(final char[] a){ return sorted(new\
    \ String(a)).toCharArray(); }\n\tprotected static final <T extends Comparable<?\
    \ super T>> T[] sorted(final T[] a){ return Arrays.stream(a).sorted().toArray(n\
    \ -> Arrays.copyOf(a, n)); }\n\tprotected static final boolean isSorted(final\
    \ String s){ return s.equals(sorted(s)); }\n\tprotected static final boolean isSorted(final\
    \ int[] a){ return Arrays.equals(a, sorted(a)); }\n\tprotected static final boolean\
    \ isSorted(final long[] a){ return Arrays.equals(a, sorted(a)); }\n\tprotected\
    \ static final boolean isSorted(final double[] a){ return Arrays.equals(a, sorted(a));\
    \ }\n\tprotected static final boolean isSorted(final char[] a){ return Arrays.equals(a,\
    \ sorted(a)); }\n\tprotected static final <T extends Comparable<? super T>> boolean\
    \ isSorted(final T[] a){ return Arrays.equals(a, sorted(a)); }\n\tprotected static\
    \ final String reverse(final String s){ return new StringBuilder(s).reverse().toString();\
    \ }\n\tprotected static final int[] reverse(final int[] a) {\n\t\tfinal int n\
    \ = a.length;\n\t\tfinal int[] b = new int[n];\n\t\tfor(int i = 0; i <= n / 2;\
    \ ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n - 1 - i] = a[i];\n\t\t}\n\t\t\
    return b;\n\t}\n\tprotected static final long[] reverse(final long[] a) {\n\t\t\
    final int n = a.length;\n\t\tfinal long[] b = new long[n];\n\t\tfor(int i = 0;\
    \ i <= n / 2; ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n - 1 - i] = a[i];\n\
    \t\t}\n\t\treturn b;\n\t}\n\tprotected static final double[] reverse(final double[]\
    \ a) {\n\t\tfinal int n = a.length;\n\t\tfinal double[] b = new double[n];\n\t\
    \tfor(int i = 0; i <= n / 2; ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n - 1\
    \ - i] = a[i];\n\t\t}\n\t\treturn b;\n\t}\n\tprotected static final char[] reverse(final\
    \ char[] a) {\n\t\tfinal int n = a.length;\n\t\tfinal char[] b = new char[n];\n\
    \t\tfor(int i = 0; i <= n / 2; ++i) {\n\t\t\tb[i] = a[n - 1 - i];\n\t\t\tb[n -\
    \ 1 - i] = a[i];\n\t\t}\n\t\treturn b;\n\t}\n\tprotected static final Object[]\
    \ reverse(final Object[] a) {\n\t\tfinal int n = a.length;\n\t\tfinal Object[]\
    \ b = new Object[n];\n\t\tfor(int i = 0; i <= n / 2; ++i) {\n\t\t\tb[i] = a[n\
    \ - 1 - i];\n\t\t\tb[n - 1 - i] = a[i];\n\t\t}\n\t\treturn b;\n\t}\n\tprotected\
    \ static final int[] rotate(final int[] a, final int id) {\n\t\tfinal int n =\
    \ a.length, k = (int) mod(id, n);\n\t\tfinal int[] res = new int[n];\n\t\tSystem.arraycopy(a,\
    \ k, res, 0, n - k);\n\t\tSystem.arraycopy(a, 0, res, n - k, k);\n\t\treturn res;\n\
    \t}\n\tprotected static final long[] rotate(final long[] a, final int id) {\n\t\
    \tfinal int n = a.length, k = (int) mod(id, n);\n\t\tfinal long[] res = new long[n];\n\
    \t\tSystem.arraycopy(a, k, res, 0, n - k);\n\t\tSystem.arraycopy(a, 0, res, n\
    \ - k, k);\n\t\treturn res;\n\t}\n\tprotected static final double[] rotate(final\
    \ double[] a, final int id) {\n\t\tfinal int n = a.length, k = (int) mod(id, n);\n\
    \t\tfinal double[] res = new double[n];\n\t\tSystem.arraycopy(a, k, res, 0, n\
    \ - k);\n\t\tSystem.arraycopy(a, 0, res, n - k, k);\n\t\treturn res;\n\t}\n\t\
    protected static final char[] rotate(final char[] a, final int id) {\n\t\tfinal\
    \ int n = a.length, k = (int) mod(id, n);\n\t\tfinal char[] res = new char[n];\n\
    \t\tSystem.arraycopy(a, k, res, 0, n - k);\n\t\tSystem.arraycopy(a, 0, res, n\
    \ - k, k);\n\t\treturn res;\n\t}\n\tprotected static final boolean[] rotate(final\
    \ boolean[] a, final int id) {\n\t\tfinal int n = a.length, k = (int) mod(id,\
    \ n);\n\t\tfinal boolean[] res = new boolean[n];\n\t\tSystem.arraycopy(a, k, res,\
    \ 0, n - k);\n\t\tSystem.arraycopy(a, 0, res, n - k, k);\n\t\treturn res;\n\t\
    }\n\tprotected static final Object[] rotate(final Object[] a, final int id) {\n\
    \t\tfinal int n = a.length, k = (int) mod(id, n);\n\t\tfinal Object[] res = new\
    \ Object[n];\n\t\tSystem.arraycopy(a, k, res, 0, n - k);\n\t\tSystem.arraycopy(a,\
    \ 0, res, n - k, k);\n\t\treturn res;\n\t}\n\tprotected static final String rotate(final\
    \ String s, final int id) {\n\t\tfinal List<Character> t = s.chars().mapToObj(i\
    \ -> (char) i).collect(Collectors.toList());\n\t\tCollections.rotate(t, -id);\n\
    \t\treturn t.stream().map(String::valueOf).collect(Collectors.joining());\n\t\
    }\n\tprotected static final int[][] rotateR(final int[][] a) {\n\t\tfinal int\
    \ h = a.length, w = a[0].length;\n\t\tfinal int[][] b = new int[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][i]);\n\t\t});\n\t\tIntStream.range(0,\
    \ w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn b;\n\t}\n\tprotected static\
    \ final long[][] rotateR(final long[][] a) {\n\t\tfinal int h = a.length, w =\
    \ a[0].length;\n\t\tfinal long[][] b = new long[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][i]);\n\t\t});\n\t\tIntStream.range(0,\
    \ w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn b;\n\t}\n\tprotected static\
    \ final double[][] rotateR(final double[][] a) {\n\t\tfinal int h = a.length,\
    \ w = a[0].length;\n\t\tfinal double[][] b = new double[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][i]);\n\t\t});\n\t\tIntStream.range(0,\
    \ w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn b;\n\t}\n\tprotected static\
    \ final char[][] rotateR(final char[][] a) {\n\t\tfinal int h = a.length, w =\
    \ a[0].length;\n\t\tfinal char[][] b = new char[w][h];\n\t\tIntStream.range(0,\
    \ h).forEach(i -> {\n\t\t\tIntStream.range(0, w).forEach(j -> b[j][i] = a[i][j]);\n\
    \t\t});\n\t\tIntStream.range(0, w).forEach(i -> b[i] = reverse(b[i]));\n\t\treturn\
    \ b;\n\t}\n\tprotected static final int[][] rotateL(final int[][] a) {\n\t\tfinal\
    \ int h = a.length, w = a[0].length;\n\t\tfinal int[][] b = new int[w][h];\n\t\
    \tIntStream.range(0, h).forEach(i -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][w\
    \ - i - 1]);\n\t\t});\n\t\treturn b;\n\t}\n\tprotected static final long[][] rotateL(final\
    \ long[][] a) {\n\t\tfinal int h = a.length, w = a[0].length;\n\t\tfinal long[][]\
    \ b = new long[w][h];\n\t\tIntStream.range(0, h).forEach(i -> {\n\t\t\tArrays.setAll(b[i],\
    \ j -> a[j][w - i - 1]);\n\t\t});\n\t\treturn b;\n\t}\n\tprotected static final\
    \ double[][] rotateL(final double[][] a) {\n\t\tfinal int h = a.length, w = a[0].length;\n\
    \t\tfinal double[][] b = new double[w][h];\n\t\tIntStream.range(0, h).forEach(i\
    \ -> {\n\t\t\tArrays.setAll(b[i], j -> a[j][w - i - 1]);\n\t\t});\n\t\treturn\
    \ b;\n\t}\n\tprotected static final char[][] rotateL(final char[][] a) {\n\t\t\
    final int h = a.length, w = a[0].length;\n\t\tfinal char[][] b = new char[w][h];\n\
    \t\tIntStream.range(0, h).forEach(i -> {\n\t\t\tIntStream.range(0, w).forEach(j\
    \ -> b[w - j - 1][i] = a[i][j]);\n\t\t});\n\t\treturn b;\n\t}\n\tprotected static\
    \ final void swap(final int[] a, final int i, final int j) {\n\t\ta[i] ^= a[j];\n\
    \t\ta[j] ^= a[i];\n\t\ta[i] ^= a[j];\n\t}\n\tprotected static final void swap(final\
    \ long[] a, final int i, final int j) {\n\t\ta[i] ^= a[j];\n\t\ta[j] ^= a[i];\n\
    \t\ta[i] ^= a[j];\n\t}\n\tprotected static final void swap(final double[] a, final\
    \ int i, final int j) {\n\t\tfinal double tmp = a[i];\n\t\ta[i] = a[j];\n\t\t\
    a[j] = tmp;\n\t}\n\tprotected static final void swap(final char[] a, final int\
    \ i, final int j) {\n\t\ta[i] ^= a[j];\n\t\ta[j] ^= a[i];\n\t\ta[i] ^= a[j];\n\
    \t}\n\tprotected static final void swap(final boolean[] a, final int i, final\
    \ int j) {\n\t\ta[i] ^= a[j];\n\t\ta[j] ^= a[i];\n\t\ta[i] ^= a[j];\n\t}\n\tprotected\
    \ static final void swap(final Object[] a, final int i, final int j) {\n\t\tfinal\
    \ Object tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n\tprotected static\
    \ final void swap(final int[] a, final int[] b) {\n\t\tassert a.length == b.length;\n\
    \t\tfinal int n = a.length;\n\t\tfinal int[] c = a.clone();\n\t\tSystem.arraycopy(b,\
    \ 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0, b, 0, n);\n\t}\n\tprotected static\
    \ final void swap(final long[] a, final long[] b) {\n\t\tassert a.length == b.length;\n\
    \t\tfinal int n = a.length;\n\t\tfinal long[] c = a.clone();\n\t\tSystem.arraycopy(b,\
    \ 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0, b, 0, n);\n\t}\n\tprotected static\
    \ final void swap(final double[] a, final double[] b) {\n\t\tassert a.length ==\
    \ b.length;\n\t\tfinal int n = a.length;\n\t\tfinal double[] c = a.clone();\n\t\
    \tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0, b, 0, n);\n\t}\n\
    \tprotected static final void swap(final char[] a, final char[] b) {\n\t\tassert\
    \ a.length == b.length;\n\t\tfinal int n = a.length;\n\t\tfinal char[] c = a.clone();\n\
    \t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c, 0, b, 0, n);\n\t\
    }\n\tprotected static final void swap(final boolean[] a, final boolean[] b) {\n\
    \t\tassert a.length == b.length;\n\t\tfinal int n = a.length;\n\t\tfinal boolean[]\
    \ c = a.clone();\n\t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\tSystem.arraycopy(c,\
    \ 0, b, 0, n);\n\t}\n\tprotected static final void swap(final Object[] a, final\
    \ Object[] b) {\n\t\tassert a.length == b.length;\n\t\tfinal int n = a.length;\n\
    \t\tfinal Object[] c = a.clone();\n\t\tSystem.arraycopy(b, 0, a, 0, n);\n\t\t\
    System.arraycopy(c, 0, b, 0, n);\n\t}\n\tprotected static final <F extends Comparable<?\
    \ super F>, S extends Comparable<? super S>> Pair<S, F>[] swap(final Pair<F, S>[]\
    \ p) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tfinal Pair<S, F>[] q = new Pair[p.length];\n\
    \t\tArrays.setAll(q, i -> p[i].swap());\n\t\treturn q;\n\t}\n\tprotected static\
    \ final IntPair[] swap(final IntPair[] p) {\n\t\tfinal IntPair[] q = new IntPair[p.length];\n\
    \t\tArrays.setAll(q, i -> p[i].swap());\n\t\treturn q;\n\t}\n\tprotected static\
    \ final FloatPair[] swap(final FloatPair[] p) {\n\t\tfinal FloatPair[] q = new\
    \ FloatPair[p.length];\n\t\tArrays.setAll(q, i -> p[i].swap());\n\t\treturn q;\n\
    \t}\n\t@SuppressWarnings(\"unchecked\")\n\tprotected static final <F extends Comparable<?\
    \ super F>, S extends Comparable<? super S>> F[] first(final Pair<F, S>[] p){\
    \ return (F[]) Arrays.stream(p).map(i -> i.first).toArray(); }\n\tprotected static\
    \ final long[] first(final IntPair[] p){ return Arrays.stream(p).mapToLong(i ->\
    \ i.first).toArray(); }\n\tprotected static final double[] first(final FloatPair[]\
    \ p){ return Arrays.stream(p).mapToDouble(i -> i.first).toArray(); }\n\t@SuppressWarnings(\"\
    unchecked\")\n\tprotected static final <F extends Comparable<? super F>, S extends\
    \ Comparable<? super S>> S[] second(final Pair<F, S>[] p){ return (S[]) Arrays.stream(p).map(i\
    \ -> i.second).toArray(); }\n\tprotected static final long[] second(final IntPair[]\
    \ p){ return Arrays.stream(p).mapToLong(i -> i.second).toArray(); }\n\tprotected\
    \ static final double[] second(final FloatPair[] p){ return Arrays.stream(p).mapToDouble(i\
    \ -> i.second).toArray(); }\n\tprotected static final IntStream iota(final int\
    \ n){ return IntStream.range(0, n); }\n\tprotected static final IntStream iota(final\
    \ int n, final int init){ return IntStream.range(0 + init, n + init); }\n\tprotected\
    \ static final int bins(int ok, int ng, final IntPredicate fn) {\n\t\twhile(abs(ok\
    \ - ng) > 1) {\n\t\t\tfinal int mid = (ok + ng) / 2;\n\t\t\tif(fn.test(mid)) {\n\
    \t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\
    \treturn ok;\n\t}\n\tprotected static final long bins(long ok, long ng, final\
    \ LongPredicate fn) {\n\t\twhile(abs(ok - ng) > 1) {\n\t\t\tfinal long mid = (ok\
    \ + ng) / 2;\n\t\t\tif(fn.test(mid)) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tprotected static\
    \ final double bins(double ok, double ng, final DoublePredicate fn) {\n\t\twhile(abs(ok\
    \ - ng) > VvyLw.EPS) {\n\t\t\tfinal double mid = (ok + ng) / 2;\n\t\t\tif(fn.test(mid))\
    \ {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t\
    }\n\t\treturn ok;\n\t}\n\tprotected static final Map<Integer, Integer> counter(final\
    \ int[] a) {\n\t\tfinal Map<Integer, Integer> res = new HashMap<>();\n\t\tfor(final\
    \ int i: a) {\n\t\t\tres.merge(i, 1, (x, y) -> x + y);\n\t\t}\n\t\treturn res;\n\
    \t}\n\tprotected static final Map<Long, Integer> counter(final long[] a) {\n\t\
    \tfinal Map<Long, Integer> res = new HashMap<>();\n\t\tfor(final long i: a) {\n\
    \t\t\tres.merge(i, 1, (x, y) -> x + y);\n\t\t}\n\t\treturn res;\n\t}\n\tprotected\
    \ static final long innerProd(final IntPair... p){ return iota(p.length).mapToLong(i\
    \ -> p[i].first.longValue() * p[i].second.longValue()).sum(); }\n\tprotected static\
    \ final double innerProd(final FloatPair... p){ return iota(p.length).mapToDouble(i\
    \ -> p[i].first.doubleValue() * p[i].second.doubleValue()).sum(); }\n\tprotected\
    \ static final FloatPair intersection(final IntPair a, final long sec1, final\
    \ IntPair b, final long sec2) {\n\t\tdouble m1, m2, b1, b2;\n\t\tif(a.first.longValue()\
    \ == 0 && b.first.longValue() == 0) {\n\t\t\treturn null;\n\t\t} else if(a.second.longValue()\
    \ == 0) {\n\t\t\tm2 = -b.first.doubleValue() / b.second.longValue();\n\t\t\tb2\
    \ = -sec2 / b.second.doubleValue();\n\t\t\tfinal double x = -sec1 / a.first.doubleValue(),\
    \ y = b2 + m2 * x; \n\t\t\treturn FloatPair.of(x, y);\n\t\t} else if(b.second.longValue()\
    \ == 0) {\n\t\t\tm1 = -a.first.doubleValue() / a.second.longValue();\n\t\t\tb1\
    \ = -sec1 / a.second.doubleValue();\n\t\t\tfinal double x = -sec2 / b.first.doubleValue(),\
    \ y = b1 + m1 * x;\n\t\t\treturn FloatPair.of(x, y);\n\t\t}\n\t\tm1 = -a.first.doubleValue()\
    \ / a.second.longValue();\n\t\tm2 = -b.first.doubleValue() / b.second.longValue();\n\
    \t\tb1 = -sec1 / a.second.doubleValue();\n\t\tb2 = -sec2 / b.second.doubleValue();\n\
    \t\tassert m1 != m2;\n\t\tfinal double x = (b1 - b2) / (m2 - m1), y = m1 * x +\
    \ b1;\n\t\treturn FloatPair.of(x, y);\n\t}\n\tprotected static final FloatPair\
    \ intersection(final FloatPair a, final double sec1, final FloatPair b, final\
    \ double sec2) {\n\t\tdouble m1, m2, b1, b2;\n\t\tif(a.first.doubleValue() ==\
    \ 0 && b.first.doubleValue() == 0) {\n\t\t\treturn null;\n\t\t} else if(a.second.doubleValue()\
    \ == 0) {\n\t\t\tm2 = -b.first.doubleValue() / b.second.doubleValue();\n\t\t\t\
    b2 = -sec2 / b.second.doubleValue();\n\t\t\tfinal double x = -sec1 / a.first.doubleValue(),\
    \ y = b2 + m2 * x; \n\t\t\treturn FloatPair.of(x, y);\n\t\t} else if(b.second.doubleValue()\
    \ == 0) {\n\t\t\tm1 = -a.first.doubleValue() / a.second.doubleValue();\n\t\t\t\
    b1 = -sec1 / a.second.doubleValue();\n\t\t\tfinal double x = -sec2 / b.first.doubleValue(),\
    \ y = b1 + m1 * x;\n\t\t\treturn FloatPair.of(x, y);\n\t\t}\n\t\tm1 = -a.first.doubleValue()\
    \ / a.second.doubleValue();\n\t\tm2 = -b.first.doubleValue() / b.second.doubleValue();\n\
    \t\tb1 = -sec1 / a.second.doubleValue();\n\t\tb2 = -sec2 / b.second.doubleValue();\n\
    \t\tassert m1 != m2;\n\t\tfinal double x = (b1 - b2) / (m2 - m1), y = m1 * x +\
    \ b1;\n\t\treturn FloatPair.of(x, y);\n\t}\n\tprotected static final int[] corPress(final\
    \ int[] a) {\n\t\tfinal int[] res = new int[a.length];\n\t\tfinal int[] x = Arrays.stream(a).sorted().distinct().toArray();\n\
    \t\tArrays.setAll(res, i -> lowerBound(x, a[i]));\n\t\treturn res;\n\t}\n\tprotected\
    \ static final int[] corPress(final long[] a) {\n\t\tfinal int[] res = new int[a.length];\n\
    \t\tfinal long[] x = Arrays.stream(a).sorted().distinct().toArray();\n\t\tArrays.setAll(res,\
    \ i -> lowerBound(x, a[i]));\n\t\treturn res;\n\t}\n\tprotected static final String\
    \ runLenPress(final String s) {\n\t\tfinal int n = s.length();\n\t\tfinal StringBuilder\
    \ sb = new StringBuilder();\n\t\tfor(int l = 0; l < n;) {\n\t\t\tint r = l + 1;\n\
    \t\t\tfor(; r < n && s.charAt(l) == s.charAt(r); ++r){}\n\t\t\tsb.append(s.charAt(l));\n\
    \t\t\tsb.append(r - l);\n\t\t\tl = r;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\
    \tprotected static final String runLenRev(final String s) {\n\t\tfinal int n =\
    \ s.length();\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tfor(int\
    \ l = 0; l < n;) {\n\t\t\tint r = l + 1;\n\t\t\tfor(; r < n && scope('0', s.charAt(r),\
    \ '9'); ++r){}\n\t\t\tsb.append(String.valueOf(s.charAt(l)).repeat(Integer.parseInt(s.substring(l\
    \ + 1, r))));\n\t\t\tl = r;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprotected\
    \ static final int[] zAlgorithm(final String s) {\n\t\tfinal int n = s.length();\n\
    \t\tint j = 0;\n\t\tfinal int[] pre = new int[n];\n\t\tfor(int i = 0; ++i < n;)\
    \ {\n\t\t\tif(i + pre[i - j] < j + pre[j]) {\n\t\t\t\tpre[i] = pre[i - j];\n\t\
    \t\t}\n\t\t\telse {\n\t\t\t\tint k = max(0, j + pre[j] - i);\n\t\t\t\twhile(i\
    \ + k < n && s.charAt(k) == s.charAt(i + k)) {\n\t\t\t\t\t++k;\n\t\t\t\t}\n\t\t\
    \t\tpre[i] = k;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\tpre[0] = n;\n\t\treturn pre;\n\
    \t}\n\tprotected static final int[] manacher(final String s_, final boolean calcEven)\
    \ {\n\t\tint n = s_.length();\n\t\tfinal char[] s;\n\t\tif(calcEven) {\n\t\t\t\
    s = new char[2 * n - 1];\n\t\t\tIntStream.range(0, n).forEach(i -> s[i] = s_.charAt(i));\n\
    \t\t\tfor(int i = n; --i >= 0;) {\n\t\t\t\ts[2 * i] = s_.charAt(i);\n\t\t\t}\n\
    \t\t\tfinal char d = Collections.min(s_.chars().mapToObj(c -> (char) c).collect(Collectors.toList()));\n\
    \t\t\tfor(int i = 0; i < n - 1; ++i) {\n\t\t\t\ts[2 * i + 1] = d;\n\t\t\t}\n\t\
    \t} else {\n\t\t\ts = new char[n];\n\t\t\tIntStream.range(0, n).forEach(i -> s[i]\
    \ = s_.charAt(i));\n\t\t}\n\t\tn = s.length;\n\t\tfinal int[] rad = new int[n];\n\
    \t\tfor(int i = 0, j = 0; i < n;) {\n\t\t\twhile(i - j >= 0 && i + j < n && s[i\
    \ - j] == s[i + j]) {\n\t\t\t\t++j;\n\t\t\t}\n\t\t\trad[i] = j;\n\t\t\tint k =\
    \ 1;\n\t\t\twhile(i - k >= 0 && i + k < n && k + rad[i - k] < j) {\n\t\t\t\trad[i\
    \ + k] = rad[i - k];\n\t\t\t\t++k;\n\t\t\t}\n\t\t\ti += k;\n\t\t\tj -= k;\n\t\t\
    }\n\t\tif(calcEven) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(((i ^ rad[i])\
    \ & 1) == 0) {\n\t\t\t\t\trad[i]--;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t\
    for(int x: rad) {\n\t\t\t\tx = 2 * x - 1;\n\t\t\t}\n\t\t}\n\t\treturn rad;\n\t\
    }\n\tprotected static final long kthRoot(final long n, final int k) {\n\t\tif(k\
    \ == 1) {\n\t\t\treturn n;\n\t\t}\n\t\tfinal LongPredicate chk = x -> {\n\t\t\t\
    long mul = 1;\n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\ttry {\n\t\t\t\t\tmul\
    \ = multiplyExact(mul, x);\n\t\t\t\t} catch(final ArithmeticException e) {\n\t\
    \t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mul <= n;\n\t\t};\n\t\t\
    long ret = 0;\n\t\tfor(int i = 32; --i >= 0;) {\n\t\t\tif(chk.test(ret | (1L <<\
    \ i))) {\n\t\t\t\tret |= 1L << i;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tprotected\
    \ static final long tetration(final long a, final long b, final long m) {\n\t\t\
    if(m == 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(a == 0) {\n\t\t\treturn (b & 1) ==\
    \ 0 ? 1 : 0;\n\t\t}\n\t\tif(b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif(b == 1)\
    \ {\n\t\t\treturn a % m;\n\t\t}\n\t\tif(b == 2) {\n\t\t\treturn intPow(a, a, m);\n\
    \t\t}\n\t\tfinal long phi = eulerPhi(m);\n\t\tlong tmp = tetration(a, b - 1, phi);\n\
    \t\tif(tmp == 0) {\n\t\t\ttmp += phi;\n\t\t}\n\t\treturn intPow(a, tmp, m);\n\t\
    }\n\tprotected static final long floorSum(final long n, final long m, long a,\
    \ long b) {\n\t\tlong ans = 0;\n\t\tif(a >= m) {\n\t\t\tans += (n - 1) * n * (a\
    \ / m) / 2;\n\t\t\ta %= m;\n\t\t}\n\t\tif(b >= m) {\n\t\t\tans += n * (b / m);\n\
    \t\t\tb %= m;\n\t\t}\n\t\tfinal long ym = (a * n + b) / m, xm = (ym * m - b);\n\
    \t\tif(ym == 0) {\n\t\t\treturn ans;\n\t\t}\n\t\tans += (n - (xm + a - 1) / a)\
    \ * ym;\n\t\tans += floorSum(ym, a, m, (a - xm % a) % a);\n\t\treturn ans;\n\t\
    }\n}\n\ninterface TriFunction<T, U, V, R> {\n\tR apply(final T a, final U b, final\
    \ V c);\n}\ninterface QuadFunction<A, B, C, D, R> {\n\tR apply(final A a, final\
    \ B b, final C c, final D d);\n}\ninterface TriConsumer<T, U, V> {\n\tvoid accept(final\
    \ T a, final U b, final V c);\n}\ninterface TriPredicate<T, U, V> {\n\tboolean\
    \ test(final T a, final U b, final V c);\n}\ninterface RecursiveFunction<T, R>\
    \ {\n\tR apply(final RecursiveFunction<T, R> rec, final T n);\n}\ninterface RecursiveBiFunction<T,\
    \ U, R> {\n\tR apply(final RecursiveBiFunction<T, U, R> rec, final T n, final\
    \ U m);\n}\ninterface RecursiveTriFunction<T, U, V, R> {\n\tR apply(final RecursiveTriFunction<T,\
    \ U, V, R> rec, final T p, final U q, final V r);\n}\ninterface RecursiveUnaryOperator<T>\
    \ {\n\tT apply(final RecursiveUnaryOperator<T> rec, final T n);\n}\ninterface\
    \ RecursiveBinaryOperator<T> {\n\tT apply(final RecursiveBinaryOperator<T> rec,\
    \ final T a, final T b);\n}\ninterface RecursiveConsumer<T> {\n\tvoid accept(final\
    \ RecursiveConsumer<T> rec, final T x);\n}\ninterface RecursiveBiConsumer<T, U>\
    \ {\n\tvoid accept(final RecursiveBiConsumer<T, U> rec, final T x, final U y);\n\
    }\ninterface RecursiveTriConsumer<T, U, V> {\n\tvoid accept(final RecursiveTriConsumer<T,\
    \ U, V> rec, final T x, final U y, final V z);\n}\ninterface RecursivePredicate<T>\
    \ {\n\tboolean test(final RecursivePredicate<T> rec, final T n);\n}\ninterface\
    \ RecursiveBiPredicate<T, U> {\n\tboolean test(final RecursiveBiPredicate<T, U>\
    \ rec, final T x, final U y);\n}\ninterface RecursiveTriPredicate<T, U, V> {\n\
    \tboolean test(final RecursiveTriPredicate<T, U, V> rec, final T x, final U y,\
    \ final V z);\n}\ninterface RecursiveIntFunction<R> {\n\tR apply(final RecursiveIntFunction<R>\
    \ rec, final int n);\n}\ninterface RecursiveLongFunction<R> {\n\tR apply(final\
    \ RecursiveLongFunction<R> rec, final long n);\n}\ninterface RecursiveDoubleFunction<R>\
    \ {\n\tR apply(final RecursiveDoubleFunction<R> rec, final double n);\n}\ninterface\
    \ RecursiveIntUnaryOperator {\n\tint apply(final RecursiveIntUnaryOperator rec,\
    \ final int n);\n}\ninterface RecursiveLongUnaryOperator {\n\tlong apply(final\
    \ RecursiveLongUnaryOperator rec, final long n);\n}\ninterface RecursiveDoubleUnaryOperator\
    \ {\n\tdouble apply(final RecursiveDoubleUnaryOperator rec, final double n);\n\
    }\ninterface RecursiveIntBinaryOperator {\n\tint apply(final RecursiveIntBinaryOperator\
    \ rec, final int a, final int b);\n}\ninterface RecursiveLongBinaryOperator {\n\
    \tlong apply(final RecursiveLongBinaryOperator rec, final long a, final long b);\n\
    }\ninterface RecursiveDoubleBinaryOperator {\n\tdouble apply(final RecursiveDoubleBinaryOperator\
    \ rec, final double a, final double b);\n}\ninterface RecursiveIntConsumer {\n\
    \tvoid accept(final RecursiveIntConsumer rec, final int n);\n}\ninterface RecursiveLongConsumer\
    \ {\n\tvoid accept(final RecursiveLongConsumer rec, final long n);\n}\ninterface\
    \ RecursiveDoubleConsumer {\n\tvoid accept(final RecursiveDoubleConsumer rec,\
    \ final double n);\n}\ninterface RecursiveIntPredicate {\n\tboolean test(final\
    \ RecursiveIntPredicate rec, final int n);\n}\ninterface RecursiveLongPredicate\
    \ {\n\tboolean test(final RecursiveLongPredicate rec, final long n);\n}\ninterface\
    \ RecursiveDoublePredicate {\n\tboolean test(final RecursiveDoublePredicate rec,\
    \ final double n);\n}\n\nfinal class IO implements Closeable, AutoCloseable {\n\
    \tprivate final MyScanner in;\n\tprivate final MyPrinter out, err;\n\tprivate\
    \ final boolean autoFlush;\n\tIO(final InputStream in, final OutputStream out,\
    \ final OutputStream err, final boolean autoFlush) {\n\t\tthis.in = new MyScanner(in);\n\
    \t\tthis.out = new MyPrinter(out, this.autoFlush = autoFlush);\n\t\tthis.err =\
    \ new MyPrinter(err, true);\n\t}\n\tfinal int ni(){ return in.ni(); }\n\tfinal\
    \ long nl(){ return in.nl(); }\n\tfinal double nd(){ return in.nd(); }\n\tfinal\
    \ char nc(){ return in.nc(); }\n\tfinal String ns(){ return in.ns(); }\n\tfinal\
    \ char[] nt(){ return in.nt(); }\n\tfinal BigInteger nb(){ return in.nb(); }\n\
    \tfinal IntPair pi(){ return in.pi(); }\n\tfinal FloatPair pf(){ return in.pf();\
    \ }\n\tfinal int[] ni(final int n) {\n\t\tfinal int[] a = new int[n];\n\t\tArrays.setAll(a,\
    \ i -> ni());\n\t\treturn a;\n\t}\n\tfinal int[] ni(final int n, final IntUnaryOperator\
    \ f){ return Arrays.stream(ni(n)).map(f).toArray(); }\n\tfinal long[] nl(final\
    \ int n) {\n\t\tfinal long[] a = new long[n];\n\t\tArrays.setAll(a, i -> nl());\n\
    \t\treturn a;\n\t}\n\tfinal long[] nl(final int n, final LongUnaryOperator f){\
    \ return Arrays.stream(nl(n)).map(f).toArray(); }\n\tfinal double[] nd(final int\
    \ n) {\n\t\tfinal double[] a = new double[n];\n\t\tArrays.setAll(a, i -> nd());\n\
    \t\treturn a;\n\t}\n\tfinal char[] nc(final int n) {\n\t\tfinal char[] a = new\
    \ char[n];\n\t\tIntStream.range(0, n).forEach(i -> a[i] = nc());\n\t\treturn a;\n\
    \t}\n\tfinal String[] ns(final int n) {\n\t\tfinal String[] a = new String[n];\n\
    \t\tArrays.setAll(a, i -> ns());\n\t\treturn a;\n\t}\n\tfinal char[][] nt(final\
    \ int n) {\n\t\tfinal char[][] a = new char[n][];\n\t\tArrays.setAll(a, i -> nt());\n\
    \t\treturn a;\n\t}\n\tfinal BigInteger[] nb(final int n) {\n\t\tfinal BigInteger[]\
    \ a = new BigInteger[n];\n\t\tArrays.setAll(a, i -> nb());\n\t\treturn a;\n\t\
    }\n\tfinal IntPair[] pi(final int n) {\n\t\tfinal IntPair[] a = new IntPair[n];\n\
    \t\tArrays.setAll(a, i -> pi());\n\t\treturn a;\n\t}\n\tfinal IntPair[] pi(final\
    \ int n, final UnaryOperator<IntPair> f){ return Arrays.stream(pi(n)).map(f).toArray(IntPair[]::new);\
    \ }\n\tfinal FloatPair[] pf(final int n) {\n\t\tfinal FloatPair[] a = new FloatPair[n];\n\
    \t\tArrays.setAll(a, i -> pf());\n\t\treturn a;\n\t}\n\tfinal int[][] ni(final\
    \ int h, final int w) {\n\t\tfinal int[][] a = new int[h][w];\n\t\tArrays.setAll(a,\
    \ i -> ni(w));\n\t\treturn a;\n\t}\n\tfinal long[][] nl(final int h, final int\
    \ w) {\n\t\tfinal long[][] a = new long[h][w];\n\t\tArrays.setAll(a, i -> nl(w));\n\
    \t\treturn a;\n\t}\n\tfinal double[][] nd(final int h, final int w) {\n\t\tfinal\
    \ double[][] a = new double[h][w];\n\t\tArrays.setAll(a, i -> nd(w));\n\t\treturn\
    \ a;\n\t}\n\tfinal char[][] nc(final int h, final int w) {\n\t\tfinal char[][]\
    \ a = new char[h][w];\n\t\tArrays.setAll(a, i -> nc(w));\n\t\treturn a;\n\t}\n\
    \tfinal String[][] ns(final int h, final int w) {\n\t\tfinal String[][] a = new\
    \ String[h][w];\n\t\tArrays.setAll(a, i -> ns(w));\n\t\treturn a;\n\t}\n\tfinal\
    \ BigInteger[][] nb(final int h, final int w) {\n\t\tfinal BigInteger[][] a =\
    \ new BigInteger[h][w];\n\t\tArrays.setAll(a, i -> nb(w));\n\t\treturn a;\n\t\
    }\n\tfinal String line(){ return in.line(); }\n\tfinal void print(final Object\
    \ arg){ out.print(arg); }\n\tfinal void printf(final String fmt, final Object...\
    \ args){ out.printf(fmt, args); }\n\tfinal void out(){ out.out(); }\n\tfinal void\
    \ out(final Object head, final Object... tail){ out.out(head, tail); }\n\tfinal\
    \ <F extends Comparable<? super F>, S extends Comparable<? super S>> void out(final\
    \ Pair<F, S> p){ out.out(p); }\n\tfinal <E> void out(final Collection<E> a){ out.out(a);\
    \ }\n\tfinal void out(final int[] head, final int[]...tail){ out.out(head, tail);\
    \ }\n\tfinal void out(final long[] head, final long[]...tail){ out.out(head, tail);\
    \ }\n\tfinal void out(final double[] head, final double[]...tail){ out.out(head,\
    \ tail); }\n\tfinal void out(final boolean[] head, final boolean[]...tail){ out.out(head,\
    \ tail); }\n\tfinal void out(final char[] head, final char[]...tail){ out.out(head,\
    \ tail); }\n\tfinal void out(final Object[] head, final Object[]...tail){ out.out(head,\
    \ tail); }\n\tfinal <F extends Comparable<? super F>, S extends Comparable<? super\
    \ S>> void out(final Pair<F, S>[] args){ Arrays.stream(args).forEach(this::out);\
    \ }\n\tfinal void out(final int[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> out(args[i])); }\n\tfinal void out(final long[][] args){ IntStream.range(0,\
    \ args.length).forEach(i -> out(args[i])); }\n\tfinal void out(final double[][]\
    \ args){ IntStream.range(0, args.length).forEach(i -> out(args[i])); }\n\tfinal\
    \ void out(final boolean[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> out(args[i])); }\n\tfinal void out(final char[][] args){ IntStream.range(0,\
    \ args.length).forEach(i -> out(args[i])); }\n\tfinal void out(final Object[][]\
    \ args){ IntStream.range(0, args.length).forEach(i -> out(args[i])); }\n\tfinal\
    \ void outl(final Object head, final Object... tail) {\n\t\tout(head);\n\t\tArrays.stream(tail).forEach(this::out);\n\
    \t}\n\tfinal void fin(final Object head, final Object... tail) {\n\t\tout(head,\
    \ tail);\n\t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\
    \t}\n\tfinal <F extends Comparable<? super F>, S extends Comparable<? super S>>\
    \ void fin(final Pair<F, S> arg) {\n\t\tout(arg);\n\t\tif(!autoFlush) {\n\t\t\t\
    out.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal <E> void fin(final Collection<E>\
    \ args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\
    \tSystem.exit(0);\n\t}\n\tfinal void fin(final int[] args) {\n\t\tout(args);\n\
    \t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\
    final void fin(final long[] args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\
    \tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final double[]\
    \ args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\
    \tSystem.exit(0);\n\t}\n\tfinal void fin(final boolean[] args) {\n\t\tout(args);\n\
    \t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\
    final void fin(final char[] args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\
    \tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final Object[]\
    \ args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\
    \tSystem.exit(0);\n\t}\n\tfinal <F extends Comparable<? super F>, S extends Comparable<?\
    \ super S>> void fin(final Pair<F, S>[] args) {\n\t\tout(args);\n\t\tif(!autoFlush)\
    \ {\n\t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final\
    \ int[][] args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\
    \t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final long[][] args) {\n\t\tout(args);\n\
    \t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\
    final void fin(final double[][] args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\
    \t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void fin(final boolean[][]\
    \ args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\
    \tSystem.exit(0);\n\t}\n\tfinal void fin(final char[][] args) {\n\t\tout(args);\n\
    \t\tif(!autoFlush) {\n\t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\t\
    final void fin(final Object[][] args) {\n\t\tout(args);\n\t\tif(!autoFlush) {\n\
    \t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void ende(final Object\
    \ head, final Object... tail) {\n\t\toutl(head, tail);\n\t\tif(!autoFlush) {\n\
    \t\t\tout.flush();\n\t\t}\n\t\tSystem.exit(0);\n\t}\n\tfinal void dump(final Object\
    \ head, final Object... tail){ err.out(head, tail); }\n\tfinal void dump(final\
    \ int[] head, final int[]...tail){ err.out(head, tail); }\n\tfinal void dump(final\
    \ long[] head, final long[]...tail){ err.out(head, tail); }\n\tfinal void dump(final\
    \ double[] head, final double[]...tail){ err.out(head, tail); }\n\tfinal void\
    \ dump(final boolean[] head, final boolean[]...tail){ err.out(head, tail); }\n\
    \tfinal void dump(final char[] head, final char[]...tail){ err.out(head, tail);\
    \ }\n\tfinal void dump(final Object[] head, final Object[]...tail){ err.out(head,\
    \ tail); }\n\tfinal <F extends Comparable<? super F>, S extends Comparable<? super\
    \ S>> void dump(final Pair<F, S>[] args){ Arrays.stream(args).forEach(this::dump);\
    \ }\n\tfinal void dump(final int[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> dump(args[i])); }\n\tfinal void dump(final long[][] args){ IntStream.range(0,\
    \ args.length).forEach(i -> dump(args[i])); }\n\tfinal void dump(final double[][]\
    \ args){ IntStream.range(0, args.length).forEach(i -> dump(args[i])); }\n\tfinal\
    \ void dump(final boolean[][] args){ IntStream.range(0, args.length).forEach(i\
    \ -> dump(args[i])); }\n\tfinal void dump(final char[][] args){ IntStream.range(0,\
    \ args.length).forEach(i -> dump(args[i])); }\n\tfinal void dump(final Object[][]\
    \ args){ IntStream.range(0, args.length).forEach(i -> dump(args[i])); }\n\t@Override\n\
    \tpublic final void close() {\n\t\tout.flush();\n\t\tin.close();\n\t\tout.close();\n\
    \t\terr.close();\n\t}\n\tprivate final class MyScanner implements Closeable, AutoCloseable\
    \ {\n\t\tprivate int pos, lim;\n\t\tprivate final byte[] buf;\n\t\tprivate final\
    \ InputStream is;\n\t\tprivate boolean check;\n\t\tMyScanner(final InputStream\
    \ is) {\n\t\t\tthis.is = is;\n\t\t\tpos = lim = 0;\n\t\t\tbuf = new byte[1 <<\
    \ 17];\n\t\t\tcheck = false;\n\t\t}\n\t\tprivate final boolean isPunct(final byte\
    \ bt){ return !Utility.scope(33, bt, 126); }\n\t\tprivate final boolean isNum(final\
    \ byte bt){ return Utility.scope('0', bt, '9'); }\n\t\tprivate final byte read()\
    \ {\n\t\t\tif(pos == lim && lim != -1) {\n\t\t\t\ttry {\n\t\t\t\t\tlim = is.read(buf);\n\
    \t\t\t\t\tpos = 0;\n\t\t\t\t} catch(final IOException e) {\n\t\t\t\t\te.printStackTrace();\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[pos++];\n\t\t}\n\t\tprivate final byte next()\
    \ {\n\t\t\tbyte bt;\n\t\t\tif(check) {\n\t\t\t\tcheck = false;\n\t\t\t\tbt = buf[pos\
    \ - 1];\n\t\t\t\tif(!isPunct(bt)) {\n\t\t\t\t\treturn bt;\n\t\t\t\t}\n\t\t\t}\n\
    \t\t\twhile(isPunct(bt = read())){}\n\t\t\treturn bt;\n\t\t}\n\t\tfinal int ni(){\
    \ return toIntExact(nl()); }\n\t\tfinal long nl() {\n\t\t\tbyte c = next();\n\t\
    \t\tfinal boolean neg = c == '-';\n\t\t\tif(neg) {\n\t\t\t\tc = next();\n\t\t\t\
    }\n\t\t\tassert isNum(c);\n\t\t\tlong res = c - '0';\n\t\t\twhile(isNum(c = read()))\
    \ {\n\t\t\t\tres = 10 * res + c - '0';\n\t\t\t}\n\t\t\tcheck = !isNum(c);\n\t\t\
    \treturn neg ? -res : res;\n\t\t}\n\t\tfinal double nd() {\n\t\t\tbyte c = next();\n\
    \t\t\tfinal boolean neg = c == '-';\n\t\t\tif(neg) {\n\t\t\t\tc = next();\n\t\t\
    \t}\n\t\t\tassert isNum(c);\n\t\t\tdouble res = c - '0';\n\t\t\twhile(isNum(c\
    \ = read())) {\n\t\t\t\tres = 10 * res + c - '0';\n\t\t\t}\n\t\t\tif(c != '.')\
    \ {\n\t\t\t\tcheck = true;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tint i;\n\t\t\t\
    for(i = 0; isNum(c = read()); ++i) {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\
    }\n\t\t\tres /= pow(10, i);\n\t\t\tcheck = true;\n\t\t\treturn neg ? -res : res;\n\
    \t\t}\n\t\tfinal char nc(){ return (char) next(); }\n\t\tfinal String ns() {\n\
    \t\t\tfinal StringBuilder sb = new StringBuilder();\n\t\t\tbyte c = next();\n\t\
    \t\twhile(!isPunct(c)) {\n\t\t\t\tsb.append((char) c);\n\t\t\t\tc = read();\n\t\
    \t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tfinal char[] nt(){ return ns().toCharArray();\
    \ }\n\t\tfinal BigInteger nb(){ return new BigInteger(ns()); }\n\t\tfinal IntPair\
    \ pi(){ return IntPair.of(nl(), nl()); }\n\t\tfinal FloatPair pf(){ return FloatPair.of(nd(),\
    \ nd()); }\n\t\tfinal String line() {\n\t\t\tfinal StringBuilder sb = new StringBuilder();\n\
    \t\t\tbyte c;\n\t\t\twhile((c = read()) != '\\n') {\n\t\t\t\tsb.append((char)\
    \ c);\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\t@Override\n\t\tpublic\
    \ final void close() {\n\t\t\ttry {\n\t\t\t\tis.close();\n\t\t\t} catch(final\
    \ IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tprivate\
    \ final class MyPrinter implements Closeable, Flushable, AutoCloseable {\n\t\t\
    private OutputStream os;\n\t\tprivate final boolean autoFlush;\n\t\tprivate final\
    \ byte[] buf;\n\t\tprivate int pos;\n\t\tprivate final boolean debug;\n\t\tMyPrinter(final\
    \ OutputStream os, final boolean autoFlush){\n\t\t\tthis.os = os;\n\t\t\tthis.autoFlush\
    \ = autoFlush;\n\t\t\tbuf = new byte[1 << 17];\n\t\t\tpos = 0;\n\t\t\tdebug =\
    \ os == System.err;\n\t\t}\n\t\tprivate final void write(final byte bt) {\n\t\t\
    \tbuf[pos++] = bt;\n\t\t\tif(pos == buf.length) {\n\t\t\t\tflush();\n\t\t\t}\n\
    \t\t}\n\t\tprivate final void newLine() {\n\t\t\twrite((byte) '\\n');\n\t\t\t\
    if(autoFlush) {\n\t\t\t\tflush();\n\t\t\t}\n\t\t}\n\t\tfinal void print(final\
    \ Object arg) {\n\t\t\tif(arg instanceof final String s) {\n\t\t\t\tfor(final\
    \ char c: s.toCharArray()) {\n\t\t\t\t\twrite((byte) c);\n\t\t\t\t}\n\t\t\t} else\
    \ {\n\t\t\t\tprint(String.valueOf(arg));\n\t\t\t}\n\t\t\tif(autoFlush) {\n\t\t\
    \t\tflush();\n\t\t\t}\n\t\t}\n\t\tfinal void printf(final String fmt, final Object...\
    \ args) {\n\t\t\tprint(new Formatter().format(fmt, args));\n\t\t\tif(autoFlush)\
    \ {\n\t\t\t\tflush();\n\t\t\t}\n\t\t}\n\t\tfinal void out(){ newLine(); }\n\t\t\
    final void out(final Object head, final Object... tail) {\n\t\t\tprint(head);\n\
    \t\t\tfor(final var el: tail) {\n\t\t\t\tprint(\" \" + el);\n\t\t\t}\n\t\t\tnewLine();\n\
    \t\t}\n\t\tfinal <F extends Comparable<? super F>, S extends Comparable<? super\
    \ S>> void out(final Pair<F, S> arg) {\n\t\t\tif(debug) {\n\t\t\t\tprint(arg.toString());\n\
    \t\t\t} else {\n\t\t\t\tprint(arg.first + \" \" + arg.second);\n\t\t\t}\n\t\t\t\
    newLine();\n\t\t}\n\t\tfinal <E> void out(final Collection<E> args) {\n\t\t\t\
    if(debug) {\n\t\t\t\tprint(args.toString());\n\t\t\t} else {\n\t\t\t\tint i =\
    \ 0;\n\t\t\t\tfor(final var el: args) {\n\t\t\t\t\tprint(el);\n\t\t\t\t\tif(++i\
    \ != args.size()) {\n\t\t\t\t\t\tprint(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\
    }\n\t\t\tnewLine();\n\t\t}\n\t\tprivate final void out(final int[] args) {\n\t\
    \t\tif(debug) {\n\t\t\t\tprint(Arrays.toString(args));\n\t\t\t} else if(args.length\
    \ > 0) {\n\t\t\t\tprint(args[0]);\n\t\t\t\tfor(int i = 0; ++i < args.length;)\
    \ {\n\t\t\t\t\tprint(\" \" + args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewLine();\n\
    \t\t}\n\t\tfinal void out(final int[] head, final int[]... tail) {\n\t\t\tout(head);\n\
    \t\t\tfor(final int[] a: tail) {\n\t\t\t\tout(a);\n\t\t\t}\n\t\t}\n\t\tprivate\
    \ final void out(final long[] args) {\n\t\t\tif(debug) {\n\t\t\t\tprint(Arrays.toString(args));\n\
    \t\t\t} else if(args.length > 0) {\n\t\t\t\tprint(args[0]);\n\t\t\t\tfor(int i\
    \ = 0; ++i < args.length;) {\n\t\t\t\t\tprint(\" \" + args[i]);\n\t\t\t\t}\n\t\
    \t\t}\n\t\t\tnewLine();\n\t\t}\n\t\tfinal void out(final long[] head, final long[]...\
    \ tail) {\n\t\t\tout(head);\n\t\t\tfor(final long[] a: tail) {\n\t\t\t\tout(a);\n\
    \t\t\t}\n\t\t}\n\t\tprivate final void out(final double[] args) {\n\t\t\tif(debug)\
    \ {\n\t\t\t\tprint(Arrays.toString(args));\n\t\t\t} else if(args.length > 0) {\n\
    \t\t\t\tprint(args[0]);\n\t\t\t\tfor(int i = 0; ++i < args.length;) {\n\t\t\t\t\
    \tprint(\" \" + args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewLine();\n\t\t}\n\t\tfinal\
    \ void out(final double[] head, final double[]... tail) {\n\t\t\tout(head);\n\t\
    \t\tfor(final double[] a: tail) {\n\t\t\t\tout(a);\n\t\t\t}\n\t\t}\n\t\tprivate\
    \ final void out(final boolean[] args) {\n\t\t\tif(debug) {\n\t\t\t\tprint(Arrays.toString(args));\n\
    \t\t\t} else if(args.length > 0) {\n\t\t\t\tprint(args[0]);\n\t\t\t\tfor(int i\
    \ = 0; ++i < args.length;) {\n\t\t\t\t\tprint(\" \" + args[i]);\n\t\t\t\t}\n\t\
    \t\t}\n\t\t\tnewLine();\n\t\t}\n\t\tfinal void out(final boolean[] head, final\
    \ boolean[]... tail) {\n\t\t\tout(head);\n\t\t\tfor(final boolean[] a: tail) {\n\
    \t\t\t\tout(a);\n\t\t\t}\n\t\t}\n\t\tprivate final void out(final char[] args)\
    \ {\n\t\t\tif(args.length > 0) {\n\t\t\t\tprint(args[0]);\n\t\t\t\tfor(int i =\
    \ 0; ++i < args.length;) {\n\t\t\t\t\tprint(\" \" + args[i]);\n\t\t\t\t}\n\t\t\
    \t}\n\t\t\tnewLine();\n\t\t}\n\t\tfinal void out(final char[] head, final char[]...\
    \ tail) {\n\t\t\tout(head);\n\t\t\tfor(final char[] a: tail) {\n\t\t\t\tout(a);\n\
    \t\t\t}\n\t\t}\n\t\tprivate final void out(final Object[] args) {\n\t\t\tif(debug)\
    \ {\n\t\t\t\tprint(Arrays.toString(args));\n\t\t\t} else if(args.length > 0) {\n\
    \t\t\t\tprint(args[0]);\n\t\t\t\tfor(int i = 0; ++i < args.length;) {\n\t\t\t\t\
    \tprint(\" \" + args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewLine();\n\t\t}\n\t\tfinal\
    \ void out(final Object[] head, final Object[]... tail) {\n\t\t\tout(head);\n\t\
    \t\tfor(final Object[] a: tail) {\n\t\t\t\tout(a);\n\t\t\t}\n\t\t}\n\t\t@Override\n\
    \t\tpublic final void flush() {\n\t\t\ttry {\n\t\t\t\tos.write(buf, 0, pos);\n\
    \t\t\t\tpos = 0;\n\t\t\t} catch(final IOException e) {\n\t\t\t\te.printStackTrace();\n\
    \t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic final void close() {\n\t\t\tif(os ==\
    \ null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tos.close();\n\t\t\t\t\
    os = null;\n\t\t\t} catch(final IOException e) {\n\t\t\t\te.printStackTrace();\n\
    \t\t\t}\n\t\t}\n\t}\n}\n\nclass Pair<F extends Comparable<? super F>, S extends\
    \ Comparable<? super S>> implements Comparable<Pair<F, S>>, Cloneable {\n\tpublic\
    \ F first;\n\tpublic S second;\n\tprotected Pair(final F first, final S second)\
    \ {\n\t\tthis.first = first;\n\t\tthis.second = second;\n\t}\n\tstatic final <F\
    \ extends Comparable<? super F>, S extends Comparable<? super S>> Pair<F, S> of(final\
    \ F a, final S b){ return new Pair<>(a, b); }\n\tPair<S, F> swap(){ return Pair.of(second,\
    \ first); }\n\t@Override\n\tpublic final boolean equals(final Object o) {\n\t\t\
    if(this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif(o == null || getClass() !=\
    \ o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal Pair<?, ?> p = (Pair<?,\
    \ ?>) o;\n\t\treturn first.equals(p.first) && second.equals(p.second);\n\t}\n\t\
    @Override\n\tpublic final int hashCode(){ return Objects.hash(first, second);\
    \ }\n\t@Override\n\tpublic final String toString(){ return \"(\" + first + \"\
    , \" + second + \")\"; }\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\t\
    public final Pair<F, S> clone() {\n\t\ttry {\n\t\t\treturn (Pair<F, S>) super.clone();\n\
    \t\t} catch(final CloneNotSupportedException e){\n\t\t\te.printStackTrace();\n\
    \t\t}\n\t\tthrow new Error();\n\t}\n\t@Override\n\tpublic final int compareTo(final\
    \ Pair<F, S> p) {\n\t\tif(first.compareTo(p.first) == 0) {\n\t\t\treturn second.compareTo(p.second);\n\
    \t\t}\n\t\treturn first.compareTo(p.first);\n\t}\n}\nfinal class IntPair extends\
    \ Pair<Long, Long> {\n\tprivate IntPair(final long first, final long second){\
    \ super(first, second); }\n\tstatic final IntPair of(final long a, final long\
    \ b){ return new IntPair(a, b); }\n\t@Override\n\tfinal IntPair swap(){ return\
    \ new IntPair(second, first); }\n\tfinal IntPair add(final IntPair p){ return\
    \ new IntPair(first + p.first, second + p.second); }\n\tfinal IntPair sub(final\
    \ IntPair p){ return new IntPair(first - p.first, second - p.second); }\n\tfinal\
    \ IntPair mul(final IntPair p){ return new IntPair(first * p.first, second * p.second);\
    \ }\n\tfinal IntPair div(final IntPair p){ return new IntPair(first / p.first,\
    \ second / p.second); }\n\tfinal IntPair mod(final IntPair p){ return new IntPair(first\
    \ % p.first, second % p.second); }\n\tfinal IntPair rotate(){ return new IntPair(-second,\
    \ first); } \n\tfinal FloatPair rotate(final int ang) {\n\t\tfinal double rad\
    \ = toRadians(Utility.mod(ang, 360));\n\t\treturn FloatPair.of(first * cos(rad)\
    \ - second * sin(rad), first * sin(rad) + second * cos(rad));\n\t}\n\tfinal long\
    \ dot(final IntPair p){ return first * p.first + second * p.second; }\n\tfinal\
    \ long cross(final IntPair p){ return rotate().dot(p); }\n\tfinal long sqr(){\
    \ return dot(this); }\n\tfinal double grad() {\n\t\ttry {\n\t\t\treturn 1.0 *\
    \ second / first;\n\t\t} catch(final ArithmeticException e) {\n\t\t\te.printStackTrace();\n\
    \t\t}\n\t\tthrow new Error();\n\t}\n\tfinal double abs(){ return hypot(first,\
    \ second); }\n\tfinal long lcm(){ return Utility.lcm(first, second); }\n\tfinal\
    \ long gcd(){ return Utility.gcd(first, second); }\n\tfinal IntPair extgcd() {\n\
    \t\tlong x = 1, y = 0, t1 = 0, t2 = 0, t3 = 1, a = first, b = second;\n\t\twhile(b\
    \ > 0) {\n\t\t\tt1 = a / b;\n\t\t\ta -= t1 * b;\n\t\t\ta ^= b;\n\t\t\tb ^= a;\n\
    \t\t\ta ^= b;\n\t\t\tx -= t1 * t2;\n\t\t\tx ^= t2;\n\t\t\tt2 ^= x;\n\t\t\tx ^=\
    \ t2;\n\t\t\ty -= t1 * t3;\n\t\t\ty ^= t3;\n\t\t\tt3 ^= y;\n\t\t\ty ^= t3;\n\t\
    \t}\n\t\treturn new IntPair(x, y);\n\t}\n}\nfinal class FloatPair extends Pair<Double,\
    \ Double> {\n\tprivate FloatPair(final double first, final double second){ super(first,\
    \ second); }\n\tstatic final FloatPair of(final double a, final double b){ return\
    \ new FloatPair(a, b); }\n\t@Override\n\tfinal FloatPair swap(){ return new FloatPair(second,\
    \ first); }\n\tfinal FloatPair add(final FloatPair p){ return new FloatPair(first\
    \ + p.first, second + p.second); }\n\tfinal FloatPair sub(final FloatPair p){\
    \ return new FloatPair(first - p.first, second - p.second); }\n\tfinal FloatPair\
    \ mul(final FloatPair p){ return new FloatPair(first * p.first, second * p.second);\
    \ }\n\tfinal FloatPair div(final FloatPair p){ return new FloatPair(first / p.first,\
    \ second / p.second); }\n\tfinal FloatPair rotate(){ return new FloatPair(-second,\
    \ first); } \n\tfinal FloatPair rotate(final int ang) {\n\t\tfinal double rad\
    \ = toRadians(Utility.mod(ang, 360));\n\t\treturn FloatPair.of(first * cos(rad)\
    \ - second * sin(rad), first * sin(rad) + second * cos(rad));\n\t}\n\tfinal double\
    \ dot(final FloatPair p){ return first * p.first + second * p.second; }\n\tfinal\
    \ double cross(final FloatPair p){ return rotate().dot(p); }\n\tfinal double sqr(){\
    \ return dot(this); }\n\tfinal double grad() { \n\t\ttry {\n\t\t\treturn second\
    \ / first;\n\t\t} catch(final ArithmeticException e) {\n\t\t\te.printStackTrace();\n\
    \t\t}\n\t\tthrow new Error();\n\t}\n\tfinal double abs(){ return hypot(first,\
    \ second); }\n}\n\nfinal class Why {\n\tstatic final boolean isBipartite(final\
    \ UnionFind uf) {\n\t\tassert uf.size() % 2 == 0;\n\t\tfinal int n = uf.size()\
    \ / 2;\n\t\tboolean ok = true;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tok &=\
    \ !uf.same(i, i + n);\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic final long invNum(final\
    \ int[] a) {\n\t\tfinal int[] b = Utility.sorted(a);\n\t\tfinal Map<Integer, Integer>\
    \ id = new HashMap<>();\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tid.put(b[i],\
    \ i);\n\t\t}\n\t\tfinal FenwickTree bit = new FenwickTree(a.length);\n\t\tlong\
    \ res = 0;\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres += i - bit.sum(id.get(a[i]));\n\
    \t\t\tbit.add(id.get(a[i]), 1);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic final long\
    \ invNum(final long[] a) {\n\t\tfinal long[] b = Utility.sorted(a);\n\t\tfinal\
    \ Map<Long, Integer> id = new HashMap<>();\n\t\tfor(int i = 0; i < a.length; ++i)\
    \ {\n\t\t\tid.put(b[i], i);\n\t\t}\n\t\tfinal FenwickTree bit = new FenwickTree(a.length);\n\
    \t\tlong res = 0;\n\t\tfor(int i = 0; i < a.length; ++i) {\n\t\t\tres += i - bit.sum(id.get(a[i]));\n\
    \t\t\tbit.add(id.get(a[i]), 1);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nfinal class\
    \ Edge {\n\tpublic int src, to, id;\n\tpublic long cost;\n\tEdge(final int src,\
    \ final int to, final int id) {\n\t\tthis.src = src;\n\t\tthis.to = to;\n\t\t\
    this.id = id;\n\t}\n\tEdge(final int src, final int to, final long cost, final\
    \ int id) {\n\t\tthis.src = src;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t\
    \tthis.id = id;\n\t}\n\t@Override\n\tpublic final boolean equals(final Object\
    \ o) {\n\t\tif(this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif(o == null || getClass()\
    \ != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal Edge e = (Edge) o;\n\
    \t\treturn src == e.src && to == e.to && cost == e.cost;\n\t}\n\t@Override\n\t\
    public final int hashCode(){ return Objects.hash(src, to, cost, id); }\n\t@Override\n\
    \tpublic final String toString(){ return String.valueOf(to); }\n}\nclass Graph\
    \ extends ArrayList<ArrayList<Edge>> {\n\tprotected final boolean undirected;\n\
    \tprotected final int n, indexed;\n\tprotected int id;\n\tprotected final ArrayList<Edge>\
    \ edge;\n\tGraph(final int n, final boolean undirected){ this(n, 1, undirected);\
    \ }\n\tGraph(final int n, final int indexed, final boolean undirected) {\n\t\t\
    this.n = n;\n\t\tthis.indexed = indexed;\n\t\tthis.undirected = undirected;\n\t\
    \tid = 0;\n\t\tedge = new ArrayList<>();\n\t\tIntStream.range(0, n).forEach(i\
    \ -> add(new ArrayList<>()));\n\t}\n\tstatic Graph of(final List<ArrayList<Edge>>\
    \ g, final boolean undirected) {\n\t\tint max = 0, min = Integer.MAX_VALUE;\n\t\
    \tfor(int i = 0; i < g.size(); ++i) {\n\t\t\tfor(final Edge e: g.get(i)) {\n\t\
    \t\t\tmax = max(e.src, e.to);\n\t\t\t\tmin = min(e.src, e.to);\n\t\t\t}\n\t\t\
    }\n\t\tfinal Graph gp = new Graph(max, min, undirected);\n\t\tfor(int i = 0; i\
    \ < g.size(); ++i) {\n\t\t\tfor(final Edge e: g.get(i)) {\n\t\t\t\tgp.addEdge(e.src,\
    \ e.to);\n\t\t\t}\n\t\t}\n\t\treturn gp;\n\t}\n\tfinal void addEdge(int a, int\
    \ b) {\n\t\ta -= indexed;\n\t\tb -= indexed;\n\t\tthis.get(a).add(new Edge(a,\
    \ b, id));\n\t\tedge.add(new Edge(a, b, id++));\n\t\tif(undirected) {\n\t\t\t\
    this.get(b).add(new Edge(b, a, --id));\n\t\t\tedge.add(new Edge(b, a, id++));\n\
    \t\t}\n\t}\n\tvoid input(final int m){ IntStream.range(0, m).forEach(i -> addEdge(VvyLw.io.ni(),\
    \ VvyLw.io.ni())); }\n\tprotected final ArrayList<Edge> getEdge(){ return edge;\
    \ }\n\tprotected final int[] allDist(final int v) {\n\t\tfinal int[] d = new int[n];\n\
    \t\tArrays.fill(d, -1);\n\t\tfinal Queue<Integer> q = new ArrayDeque<>();\n\t\t\
    d[v] = 0;\n\t\tq.add(v);\n\t\twhile(!q.isEmpty()) {\n\t\t\tfinal int tmp = q.poll();\n\
    \t\t\tfor(final Edge el: this.get(tmp)) {\n\t\t\t\tif(d[el.to] != -1) {\n\t\t\t\
    \t\tcontinue;\n\t\t\t\t}\n\t\t\t\td[el.to] = d[tmp] + 1;\n\t\t\t\tq.add(el.to);\n\
    \t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tprotected final int dist(final int u, final\
    \ int v){ return allDist(u)[v]; }\n\tprotected final ArrayList<Integer> topologicalSort()\
    \ {\n\t\tfinal int[] deg = new int[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\
    \tfor(final Edge ed: this.get(i)) {\n\t\t\t\tdeg[ed.to]++;\n\t\t\t}\n\t\t}\n\t\
    \tfinal Stack<Integer> sk = new Stack<>();\n\t\tfor(int i = 0; i < n; ++i) {\n\
    \t\t\tif(deg[i] == 0) {\n\t\t\t\tsk.add(i);\n\t\t\t}\n\t\t}\n\t\tfinal ArrayList<Integer>\
    \ ord = new ArrayList<>();\n\t\twhile(!sk.isEmpty()) {\n\t\t\tfinal int tmp =\
    \ sk.pop();\n\t\t\tord.add(tmp);\n\t\t\tfor(final Edge ed: this.get(tmp)) {\n\t\
    \t\t\tif(--deg[ed.to] == 0) {\n\t\t\t\t\tsk.add(ed.to);\n\t\t\t\t}\n\t\t\t}\n\t\
    \t}\n\t\treturn n == ord.size() ? ord : null;\n\t}\n\tprotected final int[] cycleDetector()\
    \ {\n\t\tfinal int[] used = new int[n];\n\t\tfinal Edge[] pre = new Edge[n];\n\
    \t\tfinal ArrayList<Edge> cycle = new ArrayList<>();\n\t\tfinal RecursiveIntPredicate\
    \ dfs = (rec, i) -> {\n\t\t\tused[i] = 1;\n\t\t\tfor(final Edge e: get(i)) {\n\
    \t\t\t\tif(used[e.to] == 0) {\n\t\t\t\t\tpre[e.to] = e;\n\t\t\t\t\tif(rec.test(rec,\
    \ e.to)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else if(used[e.to]\
    \ == 1) {\n\t\t\t\t\tint now = i;\n\t\t\t\t\twhile(now != e.to) {\n\t\t\t\t\t\t\
    cycle.add(pre[now]);\n\t\t\t\t\t\tnow = pre[now].src;\n\t\t\t\t\t}\n\t\t\t\t\t\
    cycle.add(e);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[i] = 2;\n\
    \t\t\treturn false;\n\t\t};\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(used[i]\
    \ == 0 && dfs.test(dfs, i)) {\n\t\t\t\tCollections.reverse(cycle);\n\t\t\t\treturn\
    \ cycle.stream().mapToInt(e -> e.to).toArray();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\
    \t}\n\t@Override\n\tpublic String toString() {\n\t\tfinal StringBuilder sb = new\
    \ StringBuilder();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfinal int m = get(i).size();\n\
    \t\t\tsb.append(i + \": [\");\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tsb.append(get(i).get(j).to);\n\
    \t\t\t\tif(j + 1 < m) {\n\t\t\t\t\tsb.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\
    \tsb.append(']');\n\t\t\tif(i + 1 < n) {\n\t\t\t\tsb.append('\\n');\n\t\t\t}\n\
    \t\t}\n\t\treturn sb.toString();\n\t}\n}\n\nfinal class ShortestPath {\n\tprivate\
    \ final long[] cost;\n\tprivate final int[] src;\n\tShortestPath(final long[]\
    \ cost, final int[] src) {\n\t\tthis.cost = cost;\n\t\tthis.src = src;\n\t}\n\t\
    final boolean isThru(final int i){ return src[i] != -1; }\n\tfinal int[] path(int\
    \ i) {\n\t\tfinal List<Integer> res = new ArrayList<>();\n\t\tfor(; i != -1; i\
    \ = src[i]) {\n\t\t\tres.add(i);\n\t\t}\n\t\tCollections.reverse(res);\n\t\treturn\
    \ res.stream().mapToInt(k -> k).toArray();\n\t}\n\tfinal long[] get(){ return\
    \ cost; }\n}\nfinal class MST {\n\tpublic final ArrayList<Edge> tree;\n\tpublic\
    \ final long cost;\n\tMST(final ArrayList<Edge> tree, final long cost) {\n\t\t\
    this.tree = tree;\n\t\tthis.cost = cost;\n\t}\n}\nfinal class WeightedGraph extends\
    \ Graph {\n\tWeightedGraph(final int n, final boolean undirected){ super(n, undirected);\
    \ }\n\tWeightedGraph(final int n, final int indexed, final boolean undirected){\
    \ super(n, indexed, undirected); }\n\tstatic final WeightedGraph of(final List<ArrayList<Edge>>\
    \ g, final boolean undirected) {\n\t\tint max = 0, min = Integer.MAX_VALUE;\n\t\
    \tfor(int i = 0; i < g.size(); ++i) {\n\t\t\tfor(final Edge e: g.get(i)) {\n\t\
    \t\t\tmax = max(e.src, e.to);\n\t\t\t\tmin = min(e.src, e.to);\n\t\t\t}\n\t\t\
    }\n\t\tfinal WeightedGraph gp = new WeightedGraph(max, min, undirected);\n\t\t\
    for(int i = 0; i < g.size(); ++i) {\n\t\t\tfor(final Edge e: g.get(i)) {\n\t\t\
    \t\tgp.addEdge(e.src, e.to, e.cost);\n\t\t\t}\n\t\t}\n\t\treturn gp;\n\t}\n\t\
    final void addEdge(int a, int b, final long cost) {\n\t\ta -= indexed;\n\t\tb\
    \ -= indexed;\n\t\tthis.get(a).add(new Edge(a, b, cost, id));\n\t\tedge.add(new\
    \ Edge(a, b, cost, id++));\n\t\tif(undirected) {\n\t\t\tthis.get(b).add(new Edge(b,\
    \ a, cost, --id));\n\t\t\tedge.add(new Edge(b, a, cost, id++));\n\t\t}\n\t}\n\t\
    final void input(final int m){ IntStream.range(0, m).forEach(i -> addEdge(VvyLw.io.ni(),\
    \ VvyLw.io.ni(), VvyLw.io.nl())); }\n\tfinal ShortestPath dijkstra(final int v)\
    \ {\n\t\tfinal long[] cost = new long[n];\n\t\tfinal int[] src = new int[n];\n\
    \t\tArrays.fill(cost, Long.MAX_VALUE);\n\t\tArrays.fill(src, -1);\n\t\tfinal Queue<IntPair>\
    \ dj = new PriorityQueue<>();\n\t\tcost[v] = 0;\n\t\tdj.add(IntPair.of(cost[v],\
    \ v));\n\t\twhile(!dj.isEmpty()) {\n\t\t\tfinal IntPair tmp = dj.poll();\n\t\t\
    \tif(cost[tmp.second.intValue()] < tmp.first.longValue()) {\n\t\t\t\tcontinue;\n\
    \t\t\t}\n\t\t\tfor(final Edge ed: this.get(tmp.second.intValue())) {\n\t\t\t\t\
    final long next = tmp.first.longValue() + ed.cost;\n\t\t\t\tif(cost[ed.to] <=\
    \ next) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcost[ed.to] = next;\n\t\t\t\
    \tsrc[ed.to] = tmp.second.intValue();\n\t\t\t\tdj.add(IntPair.of(cost[ed.to],\
    \ ed.to));\n\t\t\t}\n\t\t}\n\t\treturn new ShortestPath(cost, src);\n\t}\n\tfinal\
    \ long[] spfa(final int v) {\n\t\tfinal long[] cost = new long[n];\n\t\tArrays.fill(cost,\
    \ Long.MAX_VALUE);\n\t\tfinal boolean[] pend = new boolean[n];\n\t\tfinal int[]\
    \ cnt = new int[n];\n\t\tfinal Queue<Integer> q = new ArrayDeque<>();\n\t\tq.add(v);\n\
    \t\tpend[v] = true;\n\t\tcnt[v]++;\n\t\tcost[v] = 0;\n\t\twhile(!q.isEmpty())\
    \ {\n\t\t\tfinal int p = q.poll();\n\t\t\tpend[p] = false;\n\t\t\tfor(final Edge\
    \ e: this.get(p)) {\n\t\t\t\tfinal long next = cost[p] + e.cost;\n\t\t\t\tif(next\
    \ >= cost[e.to]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcost[e.to] = next;\n\
    \t\t\t\tif(!pend[e.to]) {\n\t\t\t\t\tif(++cnt[e.to] >= n) {\n\t\t\t\t\t\treturn\
    \ null;\n\t\t\t\t\t}\n\t\t\t\t\tpend[e.to] = true;\n\t\t\t\t\tq.add(e.to);\n\t\
    \t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n\tfinal long[][] floydWarshall()\
    \ {\n\t\tfinal long[][] cost = new long[n][n];\n\t\tIntStream.range(0, n).forEach(i\
    \ -> Arrays.fill(cost[i], VvyLw.LINF));\n\t\tIntStream.range(0, n).forEach(i ->\
    \ cost[i][i] = 0);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(final Edge j:\
    \ this.get(i)) {\n\t\t\t\tcost[i][j.to] = j.cost;\n\t\t\t}\n\t\t}\n\t\tfor(int\
    \ k = 0; k < n; ++k) {\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tfor(int j\
    \ = 0; j < n; ++j) {\n\t\t\t\t\tif(cost[i][k] == VvyLw.LINF || cost[k][j] == VvyLw.LINF)\
    \ {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(cost[i][j] > cost[i][k]\
    \ + cost[k][j]) {\n\t\t\t\t\t\tcost[i][j] = cost[i][k] + cost[k][j];\n\t\t\t\t\
    \t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n\tfinal MST kruskal() {\n\
    \t\tfinal UnionFind uf = new UnionFind(n);\n\t\tfinal ArrayList<Edge> e = new\
    \ ArrayList<>();\n\t\tlong res = 0;\n\t\tfor(final Edge ed: edge.stream().sorted(Comparator.comparing(ed\
    \ -> ed.cost)).collect(Collectors.toList())) {\n\t\t\tif(uf.unite(ed.src, ed.to))\
    \ {\n\t\t\t\te.add(ed);\n\t\t\t\tres += ed.cost;\n\t\t\t}\n\t\t}\n\t\treturn new\
    \ MST(e, res);\n\t}\n\tfinal MST directed(final int v) {\n\t\t@SuppressWarnings(\"\
    unchecked\")\n\t\tfinal ArrayList<Edge> ed = (ArrayList<Edge>) edge.clone();\n\
    \t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(i != v) {\n\t\t\t\ted.add(new Edge(i,\
    \ v, 0));\n\t\t\t}\n\t\t}\n\t\tint x = 0;\n\t\tfinal int[] par = new int[2 * n],\
    \ vis = new int[2 * n], link = new int[2 * n];\n\t\tArrays.fill(par, -1);\n\t\t\
    Arrays.fill(vis, -1);\n\t\tArrays.fill(link, -1);\n\t\tfinal SkewHeap heap = new\
    \ SkewHeap(true);\n\t\tfinal SkewHeap.Node[] ins = new SkewHeap.Node[2 * n];\n\
    \t\tArrays.fill(ins, null);\n\t\tfor(int i = 0; i < ed.size(); i++) {\n\t\t\t\
    final Edge e = ed.get(i);\n\t\t\tins[e.to] = heap.push(ins[e.to], e.cost, i);\n\
    \t\t}\n\t\tfinal ArrayList<Integer> st = new ArrayList<>();\n\t\tfinal IntUnaryOperator\
    \ go = z -> {\n\t\t\tz = ed.get(ins[z].idx).src;\n\t\t\twhile(link[z] != -1) {\n\
    \t\t\t\tst.add(z);\n\t\t\t\tz = link[z];\n\t\t\t}\n\t\t\tfor(final int p: st)\
    \ {\n\t\t\t\tlink[p] = z;\n\t\t\t}\n\t\t\tst.clear();\n\t\t\treturn z;\n\t\t};\n\
    \t\tfor(int i = n; ins[x] != null; ++i) {\n\t\t\twhile(vis[x] == -1) {\n\t\t\t\
    \tvis[x] = 0;\n\t\t\t\tx = go.applyAsInt(x);\n\t\t\t}\n\t\t\twhile(x != i) {\n\
    \t\t\t\tfinal long w = ins[x].key;\n\t\t\t\tSkewHeap.Node z = heap.pop(ins[x]);\n\
    \t\t\t\tz = heap.add(z, -w);\n\t\t\t\tins[i] = heap.meld(ins[i], z);\n\t\t\t\t\
    par[x] = i;\n\t\t\t\tlink[x] = i;\n\t\t\t\tx = go.applyAsInt(x);\n\t\t\t}\n\t\t\
    \twhile(ins[x] != null && go.applyAsInt(x) == x) {\n\t\t\t\tins[x] = heap.pop(ins[x]);\n\
    \t\t\t}\n\t\t}\n\t\tfor(int i = v; i != -1; i = par[i]) {\n\t\t\tvis[i] = 1;\n\
    \t\t}\n\t\tlong cost = 0;\n\t\tfinal ArrayList<Edge> e = new ArrayList<>();\n\t\
    \tfor(int i = x; i >= 0; i--) {\n\t\t\tif(vis[i] == 1) {\n\t\t\t\tcontinue;\n\t\
    \t\t}\n\t\t\tcost += ed.get(ins[i].idx).cost;\n\t\t\te.add(ed.get(ins[i].idx));\n\
    \t\t\tfor(int j = ed.get(ins[i].idx).to; j != -1 && vis[j] == 0; j = par[j]) {\n\
    \t\t\t\tvis[j] = 1;\n\t\t\t}\n\t\t}\n\t\treturn new MST(e, cost);\n\t}\n\t@Override\n\
    \tpublic final String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\
    \t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfinal int m = get(i).size();\n\t\t\tsb.append(i\
    \ + \": [\");\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tsb.append(\"(to: \"\
    \ + get(i).get(j).to + \", cost: \" + get(i).get(j).cost + ')');\n\t\t\t\tif(j\
    \ + 1 < m) {\n\t\t\t\t\tsb.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(']');\n\
    \t\t\tif(i + 1 < n) {\n\t\t\t\tsb.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\
    \t}\n}\nfinal class SkewHeap {\n\tstatic final class Node {\n\t\tlong key, lazy;\n\
    \t\tNode l, r;\n\t\tfinal int idx;\n\t\tNode(final long key, final int idx) {\n\
    \t\t\tthis.key = key;\n\t\t\tthis.idx = idx;\n\t\t\tlazy = 0;\n\t\t\tl = null;\n\
    \t\t\tr = null;\n\t\t}\n\t}\n\tprivate final boolean isMin;\n\tSkewHeap(final\
    \ boolean isMin){ this.isMin = isMin; }\n\tprivate final Node alloc(final long\
    \ key, final int idx){ return new Node(key, idx); }\n\tprivate final Node propagate(final\
    \ Node t) {\n\t\tif(t != null && t.lazy != 0) {\n\t\t\tif(t.l != null) {\n\t\t\
    \t\tt.l.lazy += t.lazy;\n\t\t\t}\n\t\t\tif(t.r != null) {\n\t\t\t\tt.r.lazy +=\
    \ t.lazy;\n\t\t\t}\n\t\t\tt.key += t.lazy;\n\t\t\tt.lazy = 0;\n\t\t}\n\t\treturn\
    \ t;\n\t}\n\tfinal Node meld(Node x, Node y) {\n\t\tpropagate(x);\n\t\tpropagate(y);\n\
    \t\tif(x == null || y == null) {\n\t\t\treturn x != null ? x : y;\n\t\t}\n\t\t\
    if((x.key < y.key) ^ isMin) {\n\t\t\tfinal Node tmp = x;\n\t\t\tx = y;\n\t\t\t\
    y = tmp;\n\t\t}\n\t\tx.r = meld(y, x.r);\n\t\tfinal Node tmp = x.l;\n\t\tx.l =\
    \ x.r;\n\t\tx.r = tmp;\n\t\treturn x;\n\t}\n\tfinal Node push(final Node t, final\
    \ long key, final int idx){ return meld(t, alloc(key, idx)); }\n\tfinal Node pop(final\
    \ Node t) {\n\t\tif(t == null) {\n\t\t\tthrow new NullPointerException();\n\t\t\
    }\n\t\treturn meld(t.l, t.r);\n\t}\n\tfinal Node add(final Node t, final long\
    \ lazy) {\n\t\tif(t != null) {\n\t\t\tt.lazy += lazy;\n\t\t\tpropagate(t);\n\t\
    \t}\n\t\treturn t;\n\t}\n}\n\nfinal class SCC {\n\tprivate final int n, indexed;\n\
    \tprivate int m;\n\tprivate final ArrayList<Edge> edge;\n\tprivate final int[]\
    \ start, ids;\n\tprivate int[][] groups;\n\tprivate boolean notBuilt;\n\tSCC(final\
    \ int n){ this(n, 1); }\n\tSCC(final int n, final int indexed) {\n\t\tthis.n =\
    \ n;\n\t\tthis.indexed = indexed;\n\t\tedge = new ArrayList<>();\n\t\tstart =\
    \ new int[n + 1];\n\t\tids = new int[n];\n\t\tm = 0;\n\t\tnotBuilt = true;\n\t\
    }\n\tfinal void addEdge(int from, int to) {\n\t\tfrom -= indexed;\n\t\tto -= indexed;\n\
    \t\trangeCheck(from);\n\t\trangeCheck(to);\n\t\tedge.add(new Edge(from, to, m++));\n\
    \t\tstart[from + 1]++;\n\t}\n\tfinal void input(final int m){ IntStream.range(0,\
    \ m).forEach(i -> addEdge(VvyLw.io.ni(), VvyLw.io.ni())); }\n\tfinal int id(final\
    \ int i) {\n\t\tif(notBuilt) {\n\t\t\tthrow new UnsupportedOperationException(\"\
    Graph hasn't been built.\");\n\t\t}\n\t\trangeCheck(i);\n\t\treturn ids[i];\n\t\
    }\n\tfinal void build() {\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tstart[i] +=\
    \ start[i - 1];\n\t\t}\n\t\tfinal Edge[] ed = new Edge[m];\n\t\tfinal int[] count\
    \ = new int[n + 1];\n\t\tSystem.arraycopy(start, 0, count, 0, n + 1);\n\t\tfor(final\
    \ Edge e: edge) {\n\t\t\ted[count[e.src]++] = e;\n\t\t}\n\t\tint nowOrd = 0, groupNum\
    \ = 0, k = 0, ptr = 0;\n\t\tfinal int[] par = new int[n], vis = new int[n], low\
    \ = new int[n], ord = new int[n];\n\t\tArrays.fill(ord, -1);\n\t\tfinal long[]\
    \ stack = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(ord[i] >= 0)\
    \ {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpar[i] = -1;\n\t\t\tstack[ptr++] = 0L <<\
    \ 32 | i;\n\t\t\twhile(ptr > 0) {\n\t\t\t\tlong p = stack[--ptr];\n\t\t\t\tint\
    \ u = (int) (p & 0xffff_ffffl);\n\t\t\t\tint j = (int) (p >>> 32);\n\t\t\t\tif(j\
    \ == 0) {\n\t\t\t\t\tlow[u] = ord[u] = nowOrd++;\n\t\t\t\t\tvis[k++] = u;\n\t\t\
    \t\t}\n\t\t\t\tif(start[u] + j < count[u]) {\n\t\t\t\t\tint to = ed[start[u] +\
    \ j].to;\n\t\t\t\t\tstack[ptr++] += 1l << 32;\n\t\t\t\t\tif(ord[to] == -1) {\n\
    \t\t\t\t\t\tstack[ptr++] = 0l << 32 | to;\n\t\t\t\t\t\tpar[to] = u;\n\t\t\t\t\t\
    } else {\n\t\t\t\t\t\tlow[u] = min(low[u], ord[to]);\n\t\t\t\t\t}\n\t\t\t\t} else\
    \ {\n\t\t\t\t\twhile(j --> 0) {\n\t\t\t\t\t\tfinal int to = ed[start[u] + j].to;\n\
    \t\t\t\t\t\tif(par[to] == u) {\n\t\t\t\t\t\t\tlow[u] = min(low[u], low[to]);\n\
    \t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(low[u] == ord[u]) {\n\t\t\t\t\t\twhile(true)\
    \ {\n\t\t\t\t\t\t\tfinal int v = vis[--k];\n\t\t\t\t\t\t\tord[v] = n;\n\t\t\t\t\
    \t\t\tids[v] = groupNum;\n\t\t\t\t\t\t\tif(v == u) {\n\t\t\t\t\t\t\t\tbreak;\n\
    \t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgroupNum++;\n\t\t\t\t\t}\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tids[i] = groupNum -\
    \ 1 - ids[i];\n\t\t}\n\t\tfinal int[] counts = new int[groupNum];\n\t\tfor(final\
    \ int x: ids) {\n\t\t\tcounts[x]++;\n\t\t}\n\t\tgroups = new int[groupNum][];\n\
    \t\tfor(int i = 0; i < groupNum; i++) {\n\t\t\tgroups[i] = new int[counts[i]];\n\
    \t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint cmp = ids[i];\n\t\t\tgroups[cmp][--counts[cmp]]\
    \ = i;\n\t\t}\n\t\tnotBuilt = false;\n\t}\n\tfinal int[][] groups() {\n\t\tif(notBuilt)\
    \ {\n\t\t\tthrow new UnsupportedOperationException(\"Graph hasn't been built.\"\
    );\n\t\t}\n\t\treturn groups;\n\t}\n\tprivate final void rangeCheck(final int\
    \ i) {\n\t\tif(!Utility.scope(0, i, n - 1)) {\n\t\t\tthrow new IndexOutOfBoundsException(String.format(\"\
    Index %d out of bounds for length %d\", i, n));\n\t\t}\n\t}\n}\n\nfinal class\
    \ LowestCommonAncestor {\n\tprivate final int log;\n\tprivate final int[] dep,\
    \ sum;\n\tprivate final Graph g;\n\tprivate final int[][] table;\n\tLowestCommonAncestor(final\
    \ Graph g) {\n\t\tthis.g = g;\n\t\tfinal int n = g.size();\n\t\tdep = new int[n];\n\
    \t\tsum = new int[n];\n\t\tlog = Integer.toBinaryString(n).length();\n\t\ttable\
    \ = new int[log][n];\n\t\tIntStream.range(0, log).forEach(i -> Arrays.fill(table[i],\
    \ -1));\n\t\tbuild();\n\t}\n\tprivate final void dfs(final int idx, final int\
    \ par, final int d) {\n\t\ttable[0][idx] = par;\n\t\tdep[idx] = d;\n\t\tfor(final\
    \ Edge el: g.get(idx)) {\n\t\t\tif(el.to != par) {\n\t\t\t\tsum[el.to] = (int)\
    \ (sum[idx] + el.cost); \n\t\t\t\tdfs(el.to, idx, d + 1);\n\t\t\t}\n\t\t}\n\t\
    }\n\tprivate final void build() {\n\t\tdfs(0, -1, 0);\n\t\tfor(int k = 0; k <\
    \ log - 1; ++k) {\n\t\t\tfor(int i = 0; i < table[k].length; ++i) {\n\t\t\t\t\
    if(table[k][i] == -1) {\n\t\t\t\t\ttable[k + 1][i] = -1;\n\t\t\t\t} else {\n\t\
    \t\t\t\ttable[k + 1][i] = table[k][table[k][i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\tfinal int query(int u, int v) {\n\t\tif(dep[u] > dep[v]) {\n\t\t\tu ^= v;\n\
    \t\t\tv ^= u;\n\t\t\tu ^= v;\n\t\t}\n\t\tv = climb(v, dep[v] - dep[u]);\n\t\t\
    if(u == v) {\n\t\t\treturn u;\n\t\t}\n\t\tfor(int i = log; --i >= 0;) {\n\t\t\t\
    if(table[i][u] != table[i][v]) {\n\t\t\t\tu = table[i][u];\n\t\t\t\tv = table[i][v];\n\
    \t\t\t}\n\t\t}\n\t\treturn table[0][u];\n\t}\n\tfinal int climb(int u, final int\
    \ k) {\n\t\tif(dep[u] < k) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int i = log; --i\
    \ >= 0;) {\n\t\t\tif(((k >> i) % 2) == 1) {\n\t\t\t\tu = table[i][u];\n\t\t\t\
    }\n\t\t}\n\t\treturn u;\n\t}\n\tfinal int dist(final int u, final int v){ return\
    \ sum[u] + sum[v] - 2 * sum[query(u, v)]; }\n}\n\ninterface DSU {\n\tint root(final\
    \ int i);\n\tint size(final int i);\n\tint size();\n\tdefault boolean same(final\
    \ int i, final int j){ return root(i) == root(j); }\n\tboolean unite(int i, int\
    \ j);\n\tArrayList<ArrayList<Integer>> groups();\n}\n\nclass UnionFind implements\
    \ DSU {\n\tprotected final int[] par;\n\tUnionFind(final int n) {\n\t\tpar = new\
    \ int[n];\n\t\tArrays.fill(par, -1);\n\t}\n\t@Override\n\tpublic final int root(final\
    \ int i){ return par[i] >= 0 ? par[i] = root(par[i]) : i; }\n\t@Override\n\tpublic\
    \ final int size(final int i){ return -par[root(i)]; }\n\t@Override\n\tpublic\
    \ final int size(){ return par.length; }\n\t@Override\n\tpublic boolean unite(int\
    \ i, int j) {\n\t\ti = root(i);\n\t\tj = root(j);\n\t\tif(i == j) {\n\t\t\treturn\
    \ false;\n\t\t}\n\t\tif(i > j) {\n\t\t\ti ^= j;\n\t\t\tj ^= i;\n\t\t\ti ^= j;\n\
    \t\t}\n\t\tpar[i] += par[j];\n\t\tpar[j] = i;\n\t\treturn true;\n\t}\n\t@Override\n\
    \tpublic final ArrayList<ArrayList<Integer>> groups() {\n\t\tfinal int n = par.length;\n\
    \t\tfinal ArrayList<ArrayList<Integer>> res = new ArrayList<>(n);\n\t\tIntStream.range(0,\
    \ n).forEach(i -> res.add(new ArrayList<>()));\n\t\tIntStream.range(0, n).forEach(i\
    \ -> res.get(root(i)).add(i));\n\t\tres.removeIf(ArrayList::isEmpty);\n\t\treturn\
    \ res;\n\t}\n}\n\nabstract class MergeUnionFind<T> extends UnionFind {\n\tMergeUnionFind(final\
    \ int n){ super(n); }\n\tabstract void merge(final int i, final int j);\n\tabstract\
    \ T get(final int i);\n\t@Override\n\tpublic final boolean unite(int i, int j)\
    \ {\n\t\ti = root(i);\n\t\tj = root(j);\n\t\tif(i == j) {\n\t\t\treturn false;\n\
    \t\t}\n\t\tif(i > j) {\n\t\t\ti ^= j;\n\t\t\tj ^= i;\n\t\t\ti ^= j;\n\t\t}\n\t\
    \tpar[i] += par[j];\n\t\tpar[j] = i;\n\t\tmerge(i, j);\n\t\treturn true;\n\t}\n\
    }\n\nfinal class WeightedUnionFind implements DSU {\n\tprivate final int[] par;\n\
    \tprivate final long[] weight;\n\tWeightedUnionFind(final int n) {\n\t\tpar =\
    \ new int[n];\n\t\tweight = new long[n];\n\t\tArrays.fill(par, -1);\n\t}\n\t@Override\n\
    \tpublic final int root(final int i) {\n\t\tif(par[i] < 0) {\n\t\t\treturn i;\n\
    \t\t}\n\t\tfinal int r = root(par[i]);\n\t\tweight[i] += weight[par[i]];\n\t\t\
    return par[i] = r;\n\t}\n\tfinal long get(final int i) {\n\t\troot(i);\n\t\treturn\
    \ weight[i];\n\t}\n\tfinal long diff(final int x, final int y){ return get(y)\
    \ - get(x); }\n\tfinal int unite(int x, int y, long w) {\n\t\tw += diff(y, x);\n\
    \t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x == y) {\n\t\t\treturn w == 0 ? 0\
    \ : -1;\n\t\t}\n\t\tif(par[x] > par[y]) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\t\
    x ^= y;\n\t\t\tw = -w;\n\t\t}\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\tweight[y]\
    \ = w;\n\t\treturn 1;\n\t}\n\t@Override\n\tpublic final int size(final int i){\
    \ return -par[root(i)]; }\n\t@Override\n\tpublic final int size(){ return par.length;\
    \ }\n\t@Override\n\tpublic final ArrayList<ArrayList<Integer>> groups() {\n\t\t\
    final int n = par.length;\n\t\tfinal ArrayList<ArrayList<Integer>> res = new ArrayList<>();\n\
    \t\tIntStream.range(0, n).forEach(i -> res.add(new ArrayList<>()));\n\t\tIntStream.range(0,\
    \ n).forEach(i -> res.get(root(i)).add(i));\n\t\tres.removeIf(ArrayList::isEmpty);\n\
    \t\treturn res;\n\t}\n\t// deprecated\n\t@Override\n\tpublic final boolean unite(final\
    \ int i, final int j){ return unite(i, j, 0) > 0; }\n}\n\nfinal class UndoUnionFind\
    \ implements DSU {\n\tprivate final int[] par;\n\tprivate final Stack<Pair<Integer,\
    \ Integer>> his;\n\tUndoUnionFind(final int n) {\n\t    par = new int[n];\n\t\
    \    Arrays.fill(par, -1);\n\t    his = new Stack<>();\n\t}\n\t@Override\n\tpublic\
    \ final boolean unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\t\
    his.add(Pair.of(x, par[x]));\n\t\this.add(Pair.of(y, par[y]));\n\t\tif(x == y)\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tif(par[x] > par[y]) {\n\t\t\tx ^= y;\n\t\t\
    \ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\t\
    return true;\n\t}\n\t@Override\n\tpublic final int root(final int i) {\n\t\tif(par[i]\
    \ < 0) {\n\t\t\treturn i;\n\t\t}\n\t\treturn root(par[i]);\n\t}\n\t@Override\n\
    \tpublic final int size(final int i){ return -par[root(i)]; }\n\t@Override\n\t\
    public final int size(){ return par.length; }\n\t@Override\n\tpublic final ArrayList<ArrayList<Integer>>\
    \ groups() {\n\t\tfinal int n = par.length;\n\t\tfinal ArrayList<ArrayList<Integer>>\
    \ res = new ArrayList<>();\n\t\tIntStream.range(0, n).forEach(i -> res.add(new\
    \ ArrayList<>()));\n\t\tIntStream.range(0, n).forEach(i -> res.get(root(i)).add(i));\n\
    \t\tres.removeIf(ArrayList::isEmpty);\n\t\treturn res;\n\t}\n\tfinal void undo()\
    \ {\n\t\tfinal Pair<Integer, Integer> pop1 = his.pop(), pop2 = his.pop();\n\t\t\
    par[pop1.first] = pop1.second;\n\t\tpar[pop2.first] = pop2.second;\n\t}\n\tfinal\
    \ void snapshot() {\n\t\twhile(!his.empty()) {\n\t\t\this.pop();\n\t\t}\n\t}\n\
    \tfinal void rollback() {\n\t\twhile(!his.empty()) {\n\t\t\tundo();\n\t\t}\n\t\
    }\n}\n\nfinal class PrimeTable {\n\tprivate final int[] p;\n\tprivate final boolean[]\
    \ sieve;\n\tPrimeTable(final int n) {\n\t\tsieve = new boolean[n + 1];\n\t\tArrays.fill(sieve,\
    \ true);\n\t\tsieve[0] = sieve[1] = false;\n\t\tfor(int i = 2; i <= n; ++i) {\n\
    \t\t\tif(!sieve[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(long j = (long) i\
    \ * i; j <= n; j += i) {\n\t\t\t\tsieve[(int) j] = false;\n\t\t\t}\n\t\t}\n\t\t\
    final int size = (int) IntStream.rangeClosed(0, n).filter(i -> sieve[i]).count();\n\
    \t\tint j = 0;\n\t\tp = new int[size];\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\
    \tif(sieve[i]) {\n\t\t\t\tp[j++] = i; \n\t\t\t}\n\t\t}\n\t}\n\tfinal boolean[]\
    \ table(){ return sieve; }\n\tfinal int[] get(){ return p; }\n}\n\nfinal class\
    \ PrimeFactor {\n\tprivate final int[] spf;\n\tPrimeFactor(final int n) {\n\t\t\
    spf = Utility.iota(n + 1).toArray();\n\t\tfor(int i = 2; i * i <= n; ++i) {\n\t\
    \t\tif(spf[i] != i) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j = i * i; j\
    \ <= n; j += i) {\n\t\t\t\tif(spf[j] == j) {\n\t\t\t\t\tspf[j] = i;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\tfinal TreeMap<Integer, Integer> get(int n) {\n\t\tfinal\
    \ TreeMap<Integer, Integer> m = new TreeMap<>();\n\t\twhile(n != 1) {\n\t\t\t\
    m.merge(spf[n], 1, (a, b) -> (a + b));\n\t\t\tn /= spf[n];\n\t\t}\n\t\treturn\
    \ m;\n\t}\n}\n\nfinal class PrimeCounter {\n\tprivate final int sq;\n\tprivate\
    \ final boolean[] p;\n\tprivate final int[] psum;\n\tprivate final ArrayList<Integer>\
    \ ps;\n\tPrimeCounter(final long n) {\n\t\tsq = (int) kthRooti(n, 2);\n\t\tpsum\
    \ = new int[sq + 1];\n\t\tp = new PrimeTable(sq).table();\n\t\tfor(int i = 1;\
    \ i <= sq; ++i) {\n\t\t\tpsum[i] = psum[i - 1] + (p[i] ? 1 : 0);\n\t\t}\n\t\t\
    ps = new ArrayList<>();\n\t\tfor(int i = 1; i <= sq; ++i) {\n\t\t\tif(p[i]) {\n\
    \t\t\t\tps.add(i);\n\t\t\t}\n\t\t}\n\t}\n\tprivate final long kthRooti(final long\
    \ n, final int k){ return Utility.kthRoot(n, k); }\n\tprivate final long p2(final\
    \ long x, final long y) {\n\t\tif(x < 4) {\n\t\t\treturn 0;\n\t\t}\n\t\tfinal\
    \ long a = pi(y);\n\t\tfinal long b = pi(kthRooti(x, 2));\n\t\tif(a >= b) {\n\t\
    \t\treturn 0;\n\t\t}\n\t\tlong sum = (long) (a - 2) * (a + 1) / 2 - (b - 2) *\
    \ (b + 1) / 2;\n\t\tfor(long i = a; i < b; ++i) {\n\t\t\tsum += pi(x / ps.get((int)\
    \ i));\n\t\t}\n\t\treturn sum;\n\t}\n\tprivate final long phi(final long m, final\
    \ long a) {\n\t\tif(m < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(a > m) {\n\t\t\t\
    return 1;\n\t\t}\n\t\tif(a < 1) {\n\t\t\treturn m;\n\t\t}\n\t\tif(m <= (long)\
    \ ps.get((int) (a - 1)) * ps.get((int) (a - 1))) {\n\t\t\treturn pi(m) - a + 1;\n\
    \t\t}\n\t\tif(m <= (long) ps.get((int) (a - 1)) * ps.get((int) (a - 1)) * ps.get((int)\
    \ (a - 1)) && m <= sq) {\n\t\t\tfinal long sx = pi(kthRooti(m, 2));\n\t\t\tlong\
    \ ans = pi(m) - (long) (sx + a - 2) * (sx - a + 1) / 2;\n\t\t\tfor(long i = a;\
    \ i < sx; ++i) {\n\t\t\t\tans += pi(m / ps.get((int) i));\n\t\t\t}\n\t\t\treturn\
    \ ans;\n\t\t}\n\t\treturn phi(m, a - 1) - phi(m / ps.get((int) (a - 1)), a - 1);\n\
    \t}\n\tfinal long pi(final long n) {\n\t\tif(n <= sq) {\n\t\t\treturn psum[(int)\
    \ n];\n\t\t}\n\t\tfinal long m = kthRooti(n, 3);\n\t\tfinal long a = pi(m);\n\t\
    \treturn phi(n, a) + a - 1 - p2(n, m);\n\t}\n}\n\n// N <= 1e18;\nfinal class LongPrime\
    \ {\n\tprivate static final int bsf(final long x){ return Long.numberOfTrailingZeros(x);\
    \ }\n\tprivate static final long gcd(long a, long b) {\n\t\ta = abs(a);\n\t\t\
    b = abs(b);\n\t\tif(a == 0) {\n\t\t\treturn b;\n\t\t}\n\t\tif(b == 0) {\n\t\t\t\
    return a;\n\t\t}\n\t\tfinal int shift = bsf(a|b);\n\t\ta >>= bsf(a);\n\t\tdo {\n\
    \t\t\tb >>= bsf(b);\n\t\t\tif(a > b) {\n\t\t\t\ta ^= b;\n\t\t\t\tb ^= a;\n\t\t\
    \t\ta ^= b;\n\t\t\t}\n\t\t\tb -= a;\n\t\t} while(b > 0);\n\t\treturn a << shift;\n\
    \t}\n\tstatic final boolean isPrime(final long n) {\n\t\tif(n <= 1) {\n\t\t\t\
    return false;\n\t\t}\n\t\tif(n == 2) {\n\t\t\treturn true;\n\t\t}\n\t\tif(n %\
    \ 2 == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tlong d = n - 1;\n\t\twhile(d % 2\
    \ == 0) {\n\t\t\td /= 2;\n\t\t}\n\t\tfinal long[] sample = {2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37};\n\t\tfor(final long a: sample) {\n\t\t\tif(n <= a)\
    \ {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlong t = d;\n\t\t\tBigInteger y = BigInteger.valueOf(a).modPow(BigInteger.valueOf(t),\
    \ BigInteger.valueOf(n));\n\t\t\twhile(t != n - 1 && !y.equals(BigInteger.ONE)\
    \ && !y.equals(BigInteger.valueOf(n).subtract(BigInteger.ONE))) {\n\t\t\t\ty =\
    \ y.multiply(y).mod(BigInteger.valueOf(n));\n\t\t\t\tt <<= 1;\n\t\t\t}\n\t\t\t\
    if(!y.equals(BigInteger.valueOf(n).subtract(BigInteger.ONE)) && t % 2 == 0) {\n\
    \t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate static\
    \ final long find(final long n) {\n\t\tif(isPrime(n)) {\n\t\t\treturn n;\n\t\t\
    }\n\t\tif(n % 2 == 0) {\n\t\t\treturn 2;\n\t\t}\n\t\tlong st = 0;\n\t\tfinal LongBinaryOperator\
    \ f = (x, y) -> { return BigInteger.valueOf(x).multiply(BigInteger.valueOf(x)).add(BigInteger.valueOf(y)).mod(BigInteger.valueOf(n)).longValue();\
    \ };\n\t\twhile(true) {\n\t\t\tst++;\n\t\t\tlong x = st, y = f.applyAsLong(x,\
    \ st);\n\t\t\twhile(true) {\n\t\t\t\tfinal long p = gcd(y - x + n, n);\n\t\t\t\
    \tif(p == 0 || p == n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(p != 1) {\n\t\
    \t\t\t\treturn p;\n\t\t\t\t}\n\t\t\t\tx = f.applyAsLong(x, st);\n\t\t\t\ty = f.applyAsLong(f.applyAsLong(y,\
    \ st), st);\n\t\t\t}\n\t\t}\n\t}\n\tstatic final ArrayList<Long> primeFactor(final\
    \ long n) {\n\t\tif(n == 1) return new ArrayList<>();\n\t\tfinal long x = find(n);\n\
    \t\tif(x == n) return new ArrayList<>(Arrays.asList(x));\n\t\tfinal ArrayList<Long>\
    \ l = primeFactor(x), r = primeFactor(n / x);\n\t\tl.addAll(r);\n\t\tCollections.sort(l);\n\
    \t\treturn l;\n\t}\n}\n// N > 1e18\nfinal class BigPrime {\n\tprivate static final\
    \ int bsf(final long x){ return Long.numberOfTrailingZeros(x); }\n\tprivate static\
    \ final BigInteger gcd(BigInteger a, BigInteger b) {\n\t\ta = a.abs();\n\t\tb\
    \ = b.abs();\n\t\tif(a.equals(BigInteger.ZERO)) {\n\t\t\treturn b;\n\t\t}\n\t\t\
    if(b.equals(BigInteger.ZERO)) {\n\t\t\treturn a;\n\t\t}\n\t\tfinal int shift =\
    \ bsf(a.or(b).longValue());\n\t\ta = a.shiftRight(bsf(a.longValue()));\n\t\tdo\
    \ {\n\t\t\tb = b.shiftRight(bsf(b.longValue()));\n\t\t\tif(a.compareTo(b) > 0)\
    \ {\n\t\t\t\tfinal BigInteger tmp = b;\n\t\t\t\tb = a;\n\t\t\t\ta = tmp;\n\t\t\
    \t}\n\t\t\tb = b.subtract(a);\n\t\t} while(b.compareTo(BigInteger.ZERO) > 0);\n\
    \t\treturn a.shiftLeft(shift);\n\t}\n\tstatic final boolean isPrime(final BigInteger\
    \ n) {\n\t\tif(n.compareTo(BigInteger.ONE) <= 0) {\n\t\t\treturn false;\n\t\t\
    }\n\t\tif(n.equals(BigInteger.TWO)) {\n\t\t\treturn true;\n\t\t}\n\t\tif(n.and(BigInteger.ONE).equals(BigInteger.valueOf(0)))\
    \ {\n\t\t\treturn false;\n\t\t}\n\t\tBigInteger d = n.subtract(BigInteger.ONE);\n\
    \t\twhile(d.and(BigInteger.ONE).equals(BigInteger.valueOf(0))) {\n\t\t\td = d.shiftRight(1);\n\
    \t\t}\n\t\tfinal long[] sample = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n\
    \t\tfor(final long a: sample) {\n\t\t\tif(n.compareTo(BigInteger.valueOf(a)) <=\
    \ 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tBigInteger t = d;\n\t\t\tBigInteger y =\
    \ BigInteger.valueOf(a).modPow(t, n);\n\t\t\twhile(!t.equals(n.subtract(BigInteger.ONE))\
    \ && !y.equals(BigInteger.ONE) && !y.equals(n.subtract(BigInteger.ONE))) {\n\t\
    \t\t\ty = y.multiply(y).mod(n);\n\t\t\t\tt = t.shiftLeft(1);\n\t\t\t}\n\t\t\t\
    if(!y.equals(n.subtract(BigInteger.ONE)) && t.and(BigInteger.ONE).equals(BigInteger.ZERO))\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate static\
    \ final BigInteger find(final BigInteger n) {\n\t\tif(isPrime(n)) {\n\t\t\treturn\
    \ n;\n\t\t}\n\t\tif(n.and(BigInteger.ONE).equals(BigInteger.ZERO)) {\n\t\t\treturn\
    \ BigInteger.TWO;\n\t\t}\n\t\tint st = 0;\n\t\tfinal BiFunction<BigInteger, Integer,\
    \ BigInteger> f = (x, y) -> { return x.multiply(x).add(BigInteger.valueOf(y)).mod(n);\
    \ };\n\t\twhile(true) {\n\t\t\tst++;\n\t\t\tBigInteger x = BigInteger.valueOf(st),\
    \ y = f.apply(x, st);\n\t\t\twhile(true) {\n\t\t\t\tfinal BigInteger p = gcd(y.subtract(x).add(n),\
    \ n);\n\t\t\t\tif(p.equals(BigInteger.ZERO) || p.equals(n)) {\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t\tif(!p.equals(BigInteger.ONE)) {\n\t\t\t\t\treturn p;\n\t\t\t\
    \t}\n\t\t\t\tx = f.apply(x, st);\n\t\t\t\ty = f.apply(f.apply(y, st), st);\n\t\
    \t\t}\n\t\t}\n\t}\n\tstatic final ArrayList<BigInteger> primeFactor(final BigInteger\
    \ n) {\n\t\tif(n.equals(BigInteger.ONE)) {\n\t\t\treturn new ArrayList<>();\n\t\
    \t}\n\t\tfinal BigInteger x = find(n);\n\t\tif(x.equals(n)) {\n\t\t\treturn new\
    \ ArrayList<>(Arrays.asList(x));\n\t\t}\n\t\tfinal ArrayList<BigInteger> l = primeFactor(x),\
    \ r = primeFactor(n.divide(x));\n\t\tl.addAll(r);\n\t\tCollections.sort(l);\n\t\
    \treturn l;\n\t}\n}\n\nfinal class ModPrime {\n\tprivate final int len, mod;\n\
    \tprivate final long[] f, rf;\n\tModPrime(final int mod, final int sz) {\n\t\t\
    this.mod = mod;\n\t\tlen = min(sz + 1, mod);\n\t\tf = new long[len];\n\t\trf =\
    \ new long[len];\n\t\tinit();\n\t}\n\tprivate final long inv(long x) {\n\t\tlong\
    \ res = 1, k = mod - 2;\n\t\twhile(k > 0) {\n\t\t\tif(k % 2 == 1) {\n\t\t\t\t\
    res = (res * x) % mod;\n\t\t\t}\n\t\t\tx = (x * x) % mod;\n\t\t\tk >>= 1;\n\t\t\
    }\n\t\treturn res;\n\t}\n\tprivate final void init() {\n\t\tf[0] = 1;\n\t\tfor(int\
    \ i = 0; ++i < len;) {\n\t\t\tf[i] = (f[i - 1] * i) % mod;\n\t\t}\n\t\trf[len\
    \ - 1] = inv(f[len - 1]);\n\t\tfor(int i = len; --i > 0;) {\n\t\t\trf[i - 1] =\
    \ (rf[i] * i) % mod;\n\t\t}\n\t}\n\tfinal long C(final int n, final int k) {\n\
    \t\tif(k < 0 || n < k) {\n\t\t\treturn 0;\n\t\t}\n\t\tfinal long a = f[n], b =\
    \ rf[n - k], c = rf[k], bc = (b * c) % mod;\n\t\treturn (a * bc) % mod;\n\t}\n\
    \tfinal long P(final int n, final int k) {\n\t\tif (k < 0 || n < k) {\n\t\t\t\
    return 0;\n\t\t}\n\t\tfinal long a = f[n], b = rf[n - k];\n\t\treturn (a * b)\
    \ % mod;\n\t}\n\tfinal long H(final int n, final int k) {\n\t\tif (n == 0 && k\
    \ == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn C(n + k - 1, k);\n\t}\n\tfinal long\
    \ fact(final int n){ return f[n]; }\n}\n\nfinal class EulerPhiTable {\n\tprivate\
    \ final int[] euler;\n\tEulerPhiTable(final int n) {\n\t\teuler = Utility.iota(n\
    \ + 1).toArray();\n\t\tfor(int i = 2; i <= n; ++i) {\n\t\t\tif(euler[i] == i)\
    \ {\n\t\t\t\tfor(int j = i; j <= n; j += i) {\n\t\t\t\t\teuler[j] = euler[j] /\
    \ i * (i - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfinal int[] get(){ return euler;\
    \ }\n}\n\nfinal class DP {\n\tstatic final long knapsack01(final int[] a, final\
    \ long[] v, final int w) {\n\t\tfinal int n = a.length;\n\t\tfinal long[] dp =\
    \ new long[w + 1];\n\t\tArrays.fill(dp, Long.MIN_VALUE);\n\t\tdp[0] = 0;\n\t\t\
    for(int i = 0; i < n; i++) {\n\t\t\tfor(int j = w; j >= a[i]; j--) {\n\t\t\t\t\
    if(dp[j - a[i]] != Long.MIN_VALUE) {\n\t\t\t\t\tif(dp[j - a[i]] + v[i] > dp[j])\
    \ {\n\t\t\t\t\t\tdp[j] = dp[j - a[i]] + v[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\
    }\n\t\t}\n\t\treturn Utility.max(dp);\n\t}\n\tstatic final int knapsack01(final\
    \ long[] a, final int[] v, final long w) {\n\t\tfinal int n = a.length;\n\t\t\
    final int s = (int) Utility.sum(v);\n\t\tfinal long[] dp = new long[s + 1];\n\t\
    \tArrays.fill(dp, w + 1);\n\t\tdp[0] = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\
    \t\tfor(int j = s; j >= v[i]; j--) {\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j - v[i]]\
    \ + a[i]);\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i <= s; i++)\
    \ {\n\t\t\tif(dp[i] <= w) {\n\t\t\t\tres = i;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\
    \t}\n\tprivate static final long[] knapsack(final int[] a, final long[] v, final\
    \ int[] m, final int w, final boolean less) {\n\t\tfinal int n = a.length;\n\t\
    \tfinal long[] dp = new long[w + 1], deqv = new long[w + 1];\n\t\tArrays.fill(dp,\
    \ Long.MIN_VALUE);\n\t\tdp[0] = 0;\n\t\tfinal int[] deq = new int[w + 1];\n\t\t\
    for(int i = 0; i < n; ++i) {\n\t\t\tif(a[i] == 0) {\n\t\t\t\tfor(int j = 0; j\
    \ <= w; ++j) {\n\t\t\t\t\tif(dp[j] != Long.MIN_VALUE && (less ? dp[j] + v[i] *\
    \ m[i] < dp[j] : dp[j] + v[i] * m[i] > dp[j])) {\n\t\t\t\t\t\tdp[j] = dp[j] +\
    \ v[i] * m[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int k = 0;\
    \ k < a[i]; ++k) {\n\t\t\t\t\tint s = 0, t = 0;\n\t\t\t\t\tfor(int j = 0; a[i]\
    \ * j + k <= w; ++j) {\n\t\t\t\t\t\tif(dp[a[i] * j + k] != Long.MIN_VALUE) {\n\
    \t\t\t\t\t\t\tfinal long val = dp[a[i] * j + k] - j * v[i];\n\t\t\t\t\t\t\twhile(s\
    \ < t && (less ? val < deqv[t - 1] : val > deqv[t - 1])) {\n\t\t\t\t\t\t\t\tt--;\n\
    \t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdeq[t] = j;\n\t\t\t\t\t\t\tdeqv[t++] = val;\n\t\
    \t\t\t\t\t}\n\t\t\t\t\t\tif(s < t) {\n\t\t\t\t\t\t\tdp[j * a[i] + k] = deqv[s]\
    \ + j * v[i];\n\t\t\t\t\t\t\tif(deq[s] == j - m[i]) {\n\t\t\t\t\t\t\t\ts++;\n\t\
    \t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\
    \ dp;\n\t}\n\tstatic final long knapsack(final int[] a, final long[] v, final\
    \ int[] m, final int w){ return Utility.max(knapsack(a, v, m, w, false)); }\n\t\
    static final long knapsack(final long[] a, final int[] v, final long[] m, final\
    \ long w) {\n\t\tfinal int n = a.length;\n\t\tfinal int max = Utility.max(v);\n\
    \t\tif(max == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tfinal int[] ma = new int[n];\n\
    \t\tfinal long[] mb = new long[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tma[i]\
    \ = (int) Math.min(m[i], max - 1);\n\t\t\tmb[i] = m[i] - ma[i];\n\t\t}\n\t\tint\
    \ sum = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tsum += ma[i] * v[i];\n\t\t\
    }\n\t\tfinal long[] dp = knapsack(v, a, ma, sum, true);\n\t\tfinal int[] id =\
    \ Utility.iota(n).boxed().sorted((i, j) -> -Long.compare(v[i] * a[j], v[j] * a[i])).mapToInt(i\
    \ -> i).toArray();\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < dp.length; ++i)\
    \ {\n\t\t\tif(dp[i] > w || dp[i] == Long.MIN_VALUE) {\n\t\t\t\tcontinue;\n\t\t\
    \t}\n\t\t\tlong rest = w - dp[i], cost = i;\n\t\t\tfor(final int j: id) {\n\t\t\
    \t\tfinal long get = Math.min(mb[j], rest / a[j]);\n\t\t\t\tif(get <= 0) {\n\t\
    \t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcost += get * v[j];\n\t\t\t\trest -= get\
    \ * a[j];\n\t\t\t}\n\t\t\tres = Math.max(res, cost);\n\t\t}\n\t\treturn res;\n\
    \t}\n\tstatic final long knapsack(final int[] a, final long[] v, final int w)\
    \ {\n\t\tfinal int n = a.length;\n\t\tfinal long[] dp = new long[w + 1];\n\t\t\
    Arrays.fill(dp, Long.MIN_VALUE);\n\t\tdp[0] = 0;\n\t\tfor(int i = 0; i < n; i++)\
    \ {\n\t\t\tfor(int j = a[i]; j <= w; j++) {\n\t\t\t\tif(dp[j - a[i]] != Long.MIN_VALUE)\
    \ {\n\t\t\t\t\tif(dp[j - a[i]] + v[i] > dp[j]) {\n\t\t\t\t\t\tdp[j] = dp[j - a[i]]\
    \ + v[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Utility.max(dp);\n\
    \t}\n\tstatic final long maxRectangle(final int[] a) {\n\t\tfinal Stack<Integer>\
    \ sk = new Stack<>();\n\t\tfinal long[] h = new long[a.length + 1];\n\t\tfor(int\
    \ i = 0; i < a.length; ++i) {\n\t\t\th[i] = a[i];\n\t\t}\n\t\tfinal int[] l =\
    \ new int[h.length];\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < h.length; i++)\
    \ {\n\t\t\twhile(!sk.isEmpty() && h[sk.peek()] >= h[i]) {\n\t\t\t\tres = max(res,\
    \ (i - l[sk.peek()] - 1) * h[sk.pop()]);\n\t\t\t}\n\t\t\tl[i] = sk.isEmpty() ?\
    \ -1 : sk.peek();\n\t\t\tsk.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic final\
    \ long maxRectangle(final long[] a) {\n\t\tfinal Stack<Integer> sk = new Stack<>();\n\
    \t\tfinal long[] h = Arrays.copyOf(a, a.length + 1);\n\t\tfinal int[] l = new\
    \ int[h.length];\n\t\tlong res = 0;\n\t\tfor(int i = 0; i < h.length; i++) {\n\
    \t\t\twhile(!sk.isEmpty() && h[sk.peek()] >= h[i]) {\n\t\t\t\tres = max(res, (i\
    \ - l[sk.peek()] - 1) * h[sk.pop()]);\n\t\t\t}\n\t\t\tl[i] = sk.isEmpty() ? -1\
    \ : sk.peek();\n\t\t\tsk.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic final\
    \ int lcs(final String s, final String t) {\n\t\tfinal int n = s.length();\n\t\
    \tfinal int[] dp = new int[n + 1], ndp = new int[n + 1];\n\t\tfor(int i = 0; i\
    \ < t.length(); ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tif(s.charAt(j)\
    \ == t.charAt(i)) {\n\t\t\t\t\tndp[j + 1] = dp[j] + 1;\n\t\t\t\t} else {\n\t\t\
    \t\t\tndp[j + 1] = max(ndp[j], dp[j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tUtility.swap(dp,\
    \ ndp);\n\t\t}\n\t\treturn dp[n];\n\t}\n\tstatic final int[] lis(final int[] a)\
    \ {\n\t\tfinal int n = a.length;\n\t\tList<IntPair> dp = new ArrayList<IntPair>();\n\
    \t\tfinal int[] p = new int[n];\n\t\tArrays.fill(p, -1);\n\t\tfor(int i = 0; i\
    \ < n; ++i) {\n\t\t\tfinal int id = Utility.lowerBound(dp, IntPair.of(a[i], -i));\n\
    \t\t\tif(id != 0) {\n\t\t\t\tp[i] = -dp.get(id - 1).second.intValue();\n\t\t\t\
    }\n\t\t\tif(id == dp.size()) {\n\t\t\t\tdp.add(IntPair.of(a[i], -i));\n\t\t\t\
    } else {\n\t\t\t\tdp.set(id, IntPair.of(a[i], -i));\n\t\t\t}\n\t\t}\n\t\tfinal\
    \ List<Integer> res = new ArrayList<Integer>();\n\t\tfor(int i = -dp.get(dp.size()\
    \ - 1).second.intValue(); i != -1; i = p[i]) {\n\t\t\tres.add(i);\n\t\t}\n\t\t\
    Collections.reverse(res);\n\t\treturn res.stream().mapToInt(i -> i).toArray();\n\
    \t}\n\tstatic final int[] lis(final long[] a) {\n\t\tfinal int n = a.length;\n\
    \t\tList<IntPair> dp = new ArrayList<IntPair>();\n\t\tfinal int[] p = new int[n];\n\
    \t\tArrays.fill(p, -1);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfinal int id\
    \ = Utility.lowerBound(dp, IntPair.of(a[i], -i));\n\t\t\tif(id != 0) {\n\t\t\t\
    \tp[i] = -dp.get(id - 1).second.intValue();\n\t\t\t}\n\t\t\tif(id == n) {\n\t\t\
    \t\tdp.add(IntPair.of(a[i], -i));\n\t\t\t} else {\n\t\t\t\tdp.set(id, IntPair.of(a[i],\
    \ -i));\n\t\t\t}\n\t\t}\n\t\tfinal List<Integer> res = new ArrayList<Integer>();\n\
    \t\tfor(int i = -dp.get(dp.size() - 1).second.intValue(); i != -1; i = p[i]) {\n\
    \t\t\tres.add(i);\n\t\t}\n\t\tCollections.reverse(res);\n\t\treturn res.stream().mapToInt(i\
    \ -> i).toArray();\n\t}\n}\n\nfinal class Matrix implements Cloneable {\n\tprivate\
    \ final int h, w;\n\tprivate final long[][] mat;\n\tMatrix(final int n){ this(n,\
    \ n); }\n\tMatrix(final int h, final int w) {\n\t\tthis.h = h;\n\t\tthis.w = w;\n\
    \t\tmat = new long[h][w];\n\t}\n\tMatrix(final int[][] m) {\n\t\tthis(m.length,\
    \ m[0].length);\n\t\tIntStream.range(0, h).forEach(i -> Arrays.setAll(mat[i],\
    \ j -> m[i][j]));\n\t}\n\tMatrix(final long[][] m) {\n\t\tthis(m.length, m[0].length);\n\
    \t\tIntStream.range(0, h).forEach(i -> Arrays.setAll(mat[i], j -> m[i][j]));\n\
    \t}\n\tstatic final Matrix E(final int n) {\n\t\tfinal Matrix m = new Matrix(n);\n\
    \t\tIntStream.range(0, n).forEach(i -> m.set(i, i, 1));\n\t\treturn m;\n\t}\n\t\
    final long[] getH(final int i){ return mat[i]; }\n\tfinal long[] getW(final int\
    \ i){ return IntStream.range(0, h).mapToLong(j -> mat[j][i]).toArray(); }\n\t\
    final long[][] get(){ return mat; }\n\tfinal long get(final int i, final int j){\
    \ return mat[i][j]; }\n\tfinal void set(final int i, final int j, final long x){\
    \ mat[i][j] = x; }\n\tfinal Matrix add(final Matrix m) {\n\t\tassert h == m.h\
    \ && w == m.w;\n\t\tfinal Matrix mt = new Matrix(h, w);\n\t\tfor(int i = 0; i\
    \ < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tmt.set(i, j, mat[i][j]\
    \ + m.get(i, j));\n\t\t\t}\n\t\t}\n\t\treturn mt;\n\t}\n\tfinal Matrix add(final\
    \ Matrix m, final long mod) {\n\t\tassert h == m.h && w == m.w;\n\t\tfinal Matrix\
    \ mt = new Matrix(h, w);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j =\
    \ 0; j < w; ++j) {\n\t\t\t\tmt.set(i, j, Utility.mod(mat[i][j] + m.get(i, j),\
    \ mod));\n\t\t\t}\n\t\t}\n\t\treturn mt;\n\t}\n\tfinal Matrix sub(final Matrix\
    \ m) {\n\t\tassert h == m.h && w == m.w;\n\t\tfinal Matrix mt = new Matrix(h,\
    \ w);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\
    \t\t\tmt.set(i, j, mat[i][j] - m.get(i, j));\n\t\t\t}\n\t\t}\n\t\treturn mt;\n\
    \t}\n\tfinal Matrix sub(final Matrix m, final long mod) {\n\t\tassert h == m.h\
    \ && w == m.w;\n\t\tfinal Matrix mt = new Matrix(h, w);\n\t\tfor(int i = 0; i\
    \ < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tmt.set(i, j, Utility.mod(mat[i][j]\
    \ - m.get(i, j), mod));\n\t\t\t}\n\t\t}\n\t\treturn mt;\n\t}\n\tfinal Matrix mul(final\
    \ Matrix m) {\n\t\tassert w == m.h;\n\t\tfinal Matrix mt = new Matrix(h, m.w);\n\
    \t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < m.w; ++j) {\n\t\t\t\
    \tfor(int k = 0; k < w; ++k) {\n\t\t\t\t\tmt.set(i, j, mt.get(i, j) + mat[i][k]\
    \ * m.get(k, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mt;\n\t}\n\tfinal Matrix\
    \ mul(final Matrix m, final long mod) {\n\t\tassert w == m.h;\n\t\tfinal Matrix\
    \ mt = new Matrix(h, m.w);\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j\
    \ = 0; j < m.w; ++j) {\n\t\t\t\tfor(int k = 0; k < w; ++k) {\n\t\t\t\t\tmt.set(i,\
    \ j, Utility.mod(mt.get(i, j) + mat[i][k] * m.get(k, j), mod));\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t\treturn mt;\n\t}\n\tfinal Matrix pow(int k) {\n\t\tMatrix n =\
    \ clone();\n\t\tMatrix m = Matrix.E(h);\n\t\twhile(k > 0) {\n\t\t\tif(k % 2 ==\
    \ 1) {\n\t\t\t\tm = m.mul(n);\n\t\t\t}\n\t\t\tn = n.mul(n);\n\t\t\tk >>= 1;\n\t\
    \t}\n\t\treturn m;\n\t}\n\tfinal Matrix pow(long k, final long mod) {\n\t\tMatrix\
    \ n = clone();\n\t\tMatrix m = Matrix.E(h);\n\t\twhile(k > 0) {\n\t\t\tif(k %\
    \ 2 == 1) {\n\t\t\t\tm = m.mul(n, mod);\n\t\t\t}\n\t\t\tn = n.mul(n, mod);\n\t\
    \t\tk >>= 1L;\n\t\t}\n\t\treturn m;\n\t}\n\t@Override\n\tpublic final boolean\
    \ equals(final Object o) {\n\t\tif(this == o) {\n\t\t\treturn true;\n\t\t}\n\t\
    \tif(o == null || getClass() != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\
    \tfinal Matrix m = (Matrix) o;\n\t\tif(h != m.h || w != m.w) {\n\t\t\treturn false;\n\
    \t\t}\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\
    \t\t\tif(mat[i][j] != m.get(i, j)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\
    \t}\n\t\t}\n\t\treturn true;\n\t}\n\t@Override\n\tpublic final Matrix clone()\
    \ {\n\t\tfinal Matrix m = new Matrix(h, w);\n\t\tfor(int i = 0; i < h; ++i) {\n\
    \t\t\tm.mat[i] = Arrays.copyOf(mat[i], w);\n\t\t}\n\t\treturn m;\n\t}\n\t@Override\n\
    \tpublic final String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\
    \t\tfinal int interval = String.valueOf(IntStream.range(0, h).mapToLong(i -> IntStream.range(0,\
    \ w).mapToLong(j -> mat[i][j]).max().getAsLong()).max().getAsLong()).length()\
    \ + 1;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tsb.append(\"[\");\n\t\t\tfor(int\
    \ j = 0; j < w; ++j) {\n\t\t\t\tsb.append(String.format(\"%\" + interval + \"\
    d\", mat[i][j]));\n\t\t\t\tif(j + 1 == w) {\n\t\t\t\t\tsb.append(\"]\");\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\tif(i + 1 != h) {\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\
    \t\t}\n\t\treturn sb.toString();\n\t}\n}\n\nclass InclusiveScan {\n\tprotected\
    \ final int n;\n\tprotected long[] s;\n\tprotected InclusiveScan(final int n){\
    \ this.n = n; }\n\tInclusiveScan(final int[] a, final LongBinaryOperator op) {\n\
    \t\tn = a.length;\n\t\ts = Arrays.stream(a).asLongStream().toArray();\n\t\tArrays.parallelPrefix(s,\
    \ op);\n\t}\n\tInclusiveScan(final long[] a, final LongBinaryOperator op) {\n\t\
    \tn = a.length;\n\t\ts = a.clone();\n\t\tArrays.parallelPrefix(s, op);\n\t}\n\t\
    protected final long[] get(){ return s; }\n}\nfinal class PrefixSum extends InclusiveScan\
    \ {\n\tprivate long[] imos;\n\tprivate boolean built;\n\tPrefixSum(final int n)\
    \ {\n\t\tsuper(n);\n\t\timos = new long[n + 1];\n\t\tbuilt = false;\n\t}\n\tPrefixSum(final\
    \ int[] a) {\n\t\tsuper(a, Long::sum);\n\t\ts = Utility.rotate(Arrays.copyOf(s,\
    \ n + 1), -1);\n\t}\n\tPrefixSum(final long[] a) {\n\t\tsuper(a, Long::sum);\n\
    \t\ts = Utility.rotate(Arrays.copyOf(s, n + 1), -1);\n\t}\n\tfinal long query(final\
    \ int l, final int r){ return s[r] - s[l]; }\n\tfinal void add(final int l, final\
    \ int r, final long x) {\n\t\tif(built) {\n\t\t\tthrow new UnsupportedOperationException(\"\
    Prefix Sum has been built.\");\n\t\t}\n\t\timos[l] += x;\n\t\timos[r] -= x;\n\t\
    }\n\tfinal void add(final int l, final int r){ add(l, r, 1); }\n\tfinal long[]\
    \ build() {\n\t\tassert !built;\n\t\tArrays.parallelPrefix(imos, Long::sum);\n\
    \t\tbuilt = true;\n\t\treturn Arrays.copyOf(imos, n);\n\t}\n}\nfinal class PrefixSum2D\
    \ {\n\tprivate final int h, w;\n\tprivate final long[][] data;\n\tprivate boolean\
    \ built;\n\tPrefixSum2D(final int h, final int w) {\n\t\tthis.h = h + 3;\n\t\t\
    this.w = w + 3;\n\t\tdata = new long[this.h][this.w];\n\t\tbuilt = false;\n\t\
    }\n\tPrefixSum2D(final int[][] a) {\n\t\tthis(a.length, a[0].length);\n\t\tfor(int\
    \ i = 0; i < a.length; ++i) {\n\t\t\tfor(int j = 0; j < a[i].length; ++j) {\n\t\
    \t\t\tadd(i, j, a[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tPrefixSum2D(final long[][] a)\
    \ {\n\t\tthis(a.length, a[0].length);\n\t\tfor(int i = 0; i < a.length; ++i) {\n\
    \t\t\tfor(int j = 0; j < a[i].length; ++j) {\n\t\t\t\tadd(i, j, a[i][j]);\n\t\t\
    \t}\n\t\t}\n\t}\n\tfinal void add(int i, int j, final long x) {\n\t\tif(built)\
    \ {\n\t\t\tthrow new UnsupportedOperationException(\"Prefix Sum 2D has been built.\"\
    );\n\t\t}\n\t\ti++;\n\t\tj++;\n\t\tif(i >= h || j >= w) {\n\t\t\treturn;\n\t\t\
    }\n\t\tdata[i][j] += x;\n\t}\n\tfinal void add(final int i1, final int j1, final\
    \ int i2, final int j2, final long x) {\n\t\tadd(i1, j1, x);\n\t\tadd(i1, j2,\
    \ -x);\n\t\tadd(i2, j1, -x);\n\t\tadd(i2, j2, x);\n\t}\n\tfinal void build() {\n\
    \t\tassert !built;\n\t\tfor(int i = 0; ++i < h;) {\n\t\t\tfor(int j = 0; ++j <\
    \ w;) {\n\t\t\t\tdata[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j\
    \ - 1];\n\t\t\t}\n\t\t}\n\t\tbuilt = true;\n\t}\n\tfinal long get(final int i1,\
    \ final int j1, final int i2, final int j2) {\n\t\tif(!built) {\n\t\t\tthrow new\
    \ UnsupportedOperationException(\"Prefix Sum 2D hasn't been built.\");\n\t\t}\n\
    \t\treturn data[i2][j2] - data[i1][j2] - data[i2][j1] + data[i1][j1];\n\t}\n\t\
    final long get(final int i, final int j) {\n\t\tif(!built) {\n\t\t\tthrow new\
    \ UnsupportedOperationException(\"Prefix Sum 2D hasn't been built.\");\n\t\t}\n\
    \t\treturn data[i + 1][j + 1];\n\t}\n\t@Override\n\tpublic final String toString()\
    \ {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i <\
    \ h - 3; ++i) {\n\t\t\tsb.append(get(i, 0));\n\t\t\tfor(int j = 0; ++j < w - 3;)\
    \ {\n\t\t\t\tsb.append(\" \" + get(i, j));\n\t\t\t}\n\t\t\tif(i + 1 < h) {\n\t\
    \t\t\tsb.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n\n\
    final class SuffixArray extends ArrayList<Integer> {\n\tprivate final String vs;\n\
    \tSuffixArray(final String vs, final boolean compress) {\n\t\tthis.vs = vs;\n\t\
    \tfinal int[] newVS = new int[vs.length() + 1];\n\t\tif(compress) {\n\t\t\tfinal\
    \ List<Integer> xs = vs.chars().sorted().distinct().boxed().collect(Collectors.toList());\n\
    \t\t\tfor(int i = 0; i < vs.length(); ++i) {\n\t\t\t\tnewVS[i] = Utility.lowerBound(xs,\
    \ (int) vs.charAt(i)) + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tfinal int d = vs.chars().min().getAsInt();\n\
    \t\t\tfor(int i = 0; i < vs.length(); ++i) {\n\t\t\t\tnewVS[i] = vs.charAt(i)\
    \ - d + 1;\n\t\t\t}\n\t\t}\n\t\tthis.addAll(Arrays.stream(SAIS(newVS)).boxed().collect(Collectors.toList()));\n\
    \t}\n\tprivate final int[] SAIS(final int[] s) {\n\t\tfinal int n = s.length;\n\
    \t\tfinal int[] ret = new int[n];\n\t\tfinal boolean[] isS = new boolean[n], isLMS\
    \ = new boolean[n];\n\t\tint m = 0;\n\t\tfor(int i = n - 2; i >= 0; i--) {\n\t\
    \t\tisS[i] = (s[i] > s[i + 1]) || (s[i] == s[i + 1] && isS[i + 1]);\n\t\t\tm +=\
    \ (isLMS[i + 1] = isS[i] && !isS[i + 1]) ? 1 : 0;\n\t\t}\n\t\tfinal Consumer<ArrayList<Integer>>\
    \ inducedSort = (lms) -> {\n\t\t\tfinal int upper = Arrays.stream(s).max().getAsInt();\n\
    \t\t\tfinal int[] l = new int[upper + 2], r = new int[upper + 2];\n\t\t\tfor(final\
    \ int v: s) {\n\t\t\t\t++l[v + 1];\n\t\t\t\t++r[v];\n\t\t\t}\n\t\t\tArrays.parallelPrefix(l,\
    \ (x, y) -> x + y);\n\t\t\tArrays.parallelPrefix(r, (x, y) -> x + y);\n\t\t\t\
    Arrays.fill(ret, -1);\n\t\t\tfor(int i = lms.size(); --i >= 0;) {\n\t\t\t\tret[--r[s[lms.get(i)]]]\
    \ = lms.get(i);\n\t\t\t}\n\t\t\tfor(final int v: ret) {\n\t\t\t\tif(v >= 1 &&\
    \ isS[v - 1]) {\n\t\t\t\t\tret[l[s[v - 1]]++] = v - 1;\n\t\t\t\t}\n\t\t\t}\n\t\
    \t\tArrays.fill(r, 0);\n\t\t\tfor(final int v: s) {\n\t\t\t\t++r[v];\n\t\t\t}\n\
    \t\t\tArrays.parallelPrefix(r, (x, y) -> x + y);\n\t\t\tfor(int k = ret.length\
    \ - 1, i = ret[k]; k >= 1; i = ret[--k]) {\n\t\t\t\tif(i >= 1 && !isS[i - 1])\
    \ {\n\t\t\t\t\tret[--r[s[i - 1]]] = i - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfinal\
    \ ArrayList<Integer> lms = new ArrayList<>(), newLMS = new ArrayList<>();\n\t\t\
    for(int i = 0; ++i < n;) {\n\t\t\tif(isLMS[i]) {\n\t\t\t\tlms.add(i);\n\t\t\t\
    }\n\t\t}\n\t\tinducedSort.accept(lms);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\
    \tif(!isS[ret[i]] && ret[i] > 0 && isS[ret[i] - 1]) {\n\t\t\t\tnewLMS.add(ret[i]);\n\
    \t\t\t}\n\t\t}\n\t\tfinal BiPredicate<Integer, Integer> same = (a, b) -> {\n\t\
    \t\tif(s[a++] != s[b++]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\twhile(true)\
    \ {\n\t\t\t\tif(s[a] != s[b]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\
    if(isLMS[a] || isLMS[b]) {\n\t\t\t\t\treturn isLMS[a] && isLMS[b];\n\t\t\t\t}\n\
    \t\t\t\ta++;\n\t\t\t\tb++;\n\t\t\t}\n\t\t};\n\t\tint rank = 0;\n\t\tret[n - 1]\
    \ = 0;\n\t\tfor(int i = 0; ++i < m;) {\n\t\t\tif(!same.test(newLMS.get(i - 1),\
    \ newLMS.get(i))) {\n\t\t\t\t++rank;\n\t\t\t}\n\t\t\tret[newLMS.get(i)] = rank;\n\
    \t\t}\n\t\tif(rank + 1 < m) {\n\t\t\tfinal int[] newS = new int[m];\n\t\t\tfor(int\
    \ i = 0; i < m; ++i) {\n\t\t\t\tnewS[i] = ret[lms.get(i)];\n\t\t\t}\n\t\t\tfinal\
    \ var lmsSA = SAIS(newS);\n\t\t\tIntStream.range(0, m).forEach(i -> newLMS.set(i,\
    \ lms.get(lmsSA[i])));\n\t\t}\n\t\tinducedSort.accept(newLMS);\n\t\treturn ret;\n\
    \t}\n\tprivate final boolean ltSubstr(final String t, int si, int ti) {\n\t\t\
    final int sn = vs.length(), tn = t.length();\n\t\twhile(si < sn && ti < tn) {\n\
    \t\t\tif(vs.charAt(si) < t.charAt(ti)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\
    if(vs.charAt(si) > t.charAt(ti)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t++si;\n\
    \t\t\t++ti;\n\t\t}\n\t\treturn si >= sn && ti < tn;\n\t}\n\tfinal int lowerBound(final\
    \ String t) {\n\t\tint ok = this.size(), ng = 0;\n\t\twhile(ok - ng > 1) {\n\t\
    \t\tfinal int mid = (ok + ng) / 2;\n\t\t\tif(ltSubstr(t, this.get(mid), 0)) {\n\
    \t\t\t\tng = mid;\n\t\t\t} else {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ ok;\n\t}\n\tfinal Pair<Integer, Integer> equalRange(final String t) {\n\t\t\
    final int low = lowerBound(t);\n\t\tint ng = low - 1, ok = this.size();\n\t\t\
    final StringBuilder sb = new StringBuilder(t);\n\t\tsb.setCharAt(t.length() -\
    \ 1, (char)(sb.charAt(sb.length() - 1) - 1));\n\t\tfinal String u = sb.toString();\n\
    \t\twhile(ok - ng > 1) {\n\t\t\tfinal int mid = (ok + ng) / 2;\n\t\t\tif(ltSubstr(u,\
    \ this.get(mid), 0)) {\n\t\t\t\tng = mid;\n\t\t\t} else {\n\t\t\t\tok = mid;\n\
    \t\t\t}\n\t\t}\n\t\tfinal int end = this.size() - 1;\n\t\tthis.add(end, this.get(end)\
    \ - 1);\n\t\treturn Pair.of(low, ok);\n\t}\n\tfinal int[] lcpArray() {\n\t\tfinal\
    \ int n = this.size() - 1;\n\t\tfinal int[] lcp = new int[n + 1], rank = new int[n\
    \ + 1];\n\t\tfor(int i = 0; i <= n; ++i) {\n\t\t\trank[this.get(i)] = i;\n\t\t\
    }\n\t\tint h = 0;\n\t\tfor(int i = 0; i <= n; ++i) {\n\t\t\tif(rank[i] < n) {\n\
    \t\t\t\tfinal int j = this.get(rank[i] + 1);\n\t\t\t\tfor(; j + h < n && i + h\
    \ < n; ++h) {\n\t\t\t\t\tif(vs.charAt(j + h) != vs.charAt(i + h)) {\n\t\t\t\t\t\
    \tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlcp[rank[i] + 1] = h;\n\t\t\t\tif(h\
    \ > 0) {\n\t\t\t\t\th--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lcp;\n\t}\n\t\
    @Override\n\tpublic final String toString() { \n\t\tfinal StringBuilder sb = new\
    \ StringBuilder();\n\t\tfor(int i = 0; i < this.size(); ++i) {\n\t\t\tsb.append(i\
    \ + \":[\" + this.get(i) + \"]\");\n\t\t\tfor(int j = this.get(i); j < vs.length();\
    \ ++j) {\n\t\t\t\tsb.append(\" \" + vs.charAt(j));\n\t\t\t}\n\t\t\tif(i + 1 !=\
    \ this.size()) {\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\
    \t}\n}\n\nfinal class Deque<T> implements Iterable<T> {\n\tprivate int n, head,\
    \ tail;\n\tprivate Object[] buf;\n\tDeque(){ this(1 << 17); }\n\tprivate Deque(final\
    \ int n) {\n\t\tthis.n = n;\n\t\thead = tail = 0;\n\t\tbuf = new Object[n];\n\t\
    }\n\tDeque(final T[] a) {\n\t\tthis(a.length);\n\t\tArrays.stream(a).forEach(i\
    \ -> add(i));\n\t}\n\tprivate final int next(final int index) {\n\t\tfinal int\
    \ next = index + 1;\n\t\treturn next == n ? 0 : next;\n\t}\n\tprivate final int\
    \ prev(final int index) {\n\t\tfinal int prev = index - 1;\n\t\treturn prev ==\
    \ -1 ? n - 1 : prev;\n\t}\n\tprivate final int index(final int i) {\n\t\tfinal\
    \ int size = size();\n\t\tassert i < size;\n\t\tfinal int id = head + i;\n\t\t\
    return n <= id ? id - n : id;\n\t}\n\tprivate final void arraycopy(final int fromId,\
    \ final T[] a, final int from, final int len) {\n\t\tassert fromId + len <= size();\n\
    \t\tfinal int h = index(fromId);\n\t\tif(h + len < n) {\n\t\t\tSystem.arraycopy(buf,\
    \ h, a, from, len);\n\t\t} else {\n\t\t\tfinal int back = n - h;\n\t\t\tSystem.arraycopy(buf,\
    \ h, a, from, back);\n\t\t\tSystem.arraycopy(buf, 0, a, from + back, len - back);\n\
    \t\t}\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tprivate final void extend()\
    \ {\n\t\tfinal Object[] tmp = new Object[n << 1];\n\t\tarraycopy(0, (T[]) tmp,\
    \ 0, size());\n\t\tbuf = tmp;\n\t\tn = buf.length;\n\t}\n\tfinal boolean isEmpty(){\
    \ return size() == 0; }\n\tfinal int size() {\n\t\tfinal int size = tail - head;\n\
    \t\treturn size < 0 ? size + n : size;\n\t}\n\tfinal void addFirst(final T x)\
    \ {\n\t\tif(prev(head) == tail) {\n\t\t\textend();\n\t\t}\n\t\thead = prev(head);\n\
    \t\tbuf[head] = x;\n\t}\n\tfinal void addLast(final T x) {\n\t\tif(next(tail)\
    \ == head) {\n\t\t\textend();\n\t\t}\n\t\tbuf[tail] = x;\n\t\ttail = next(tail);\n\
    \t}\n\tfinal void removeFirst() {\n\t\tif(head == tail) {\n\t\t\tthrow new NoSuchElementException(\"\
    Deque is empty\");\n\t\t}\n\t\thead = next(head);\n\t}\n\tfinal void removeLast()\
    \ {\n\t\tif(head == tail) {\n\t\t\tthrow new NoSuchElementException(\"Deque is\
    \ empty\");\n\t\t}\n\t\ttail = prev(tail);\n\t}\n\t@SuppressWarnings(\"unchecked\"\
    )\n\tfinal T pollFirst() {\n\t\tif(head == tail) {\n\t\t\tthrow new NoSuchElementException(\"\
    Deque is empty\");\n\t\t}\n\t\tfinal T ans = (T) buf[head];\n\t\thead = next(head);\n\
    \t\treturn ans;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T pollLast()\
    \ {\n\t\tif(head == tail) {\n\t\t\tthrow new NoSuchElementException(\"Deque is\
    \ empty\");\n\t\t}\n\t\ttail = prev(tail);\n\t\treturn (T) buf[tail];\n\t}\n\t\
    final T peekFirst(){ return get(0); }\n\tfinal T peekLast(){ return get(n - 1);\
    \ }\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T get(final int i){ return (T)\
    \ buf[index(i)]; }\n\tfinal void set(final int i, final T x){ buf[index(i)] =\
    \ x; }\n\tfinal void add(final T x){ addLast(x); }\n\tfinal T poll(){ return pollFirst();\
    \ }\n\tfinal T peek(){ return peekFirst(); }\n\t@SuppressWarnings(\"unchecked\"\
    )\n\tfinal void swap(final int a, final int b) {\n\t\tfinal int i = index(a),\
    \ j = index(b);\n\t\tfinal T num = (T) buf[i];\n\t\tbuf[i] = buf[j];\n\t\tbuf[j]\
    \ = num;\n\t}\n\tfinal void clear(){ head = tail = 0; }\n\t@SuppressWarnings(\"\
    unchecked\")\n\tfinal T[] toArray() {\n\t\tfinal Object[] array = new Object[size()];\n\
    \t\tarraycopy(0, (T[]) array, 0, size());\n\t\treturn (T[]) array;\n\t}\n\t@Override\n\
    \tpublic final String toString(){ return Arrays.toString(toArray()); }\n\t@Override\n\
    \tpublic final Iterator<T> iterator(){ return new DequeIterator(); }\n\tprivate\
    \ class DequeIterator implements Iterator<T> {\n\t\tprivate int now = head;\n\t\
    \tprivate int rem = size();\n\t\t@Override\n\t\tpublic boolean hasNext(){ return\
    \ rem > 0; }\n\t\t@Override\n\t\tpublic final T next() {\n\t\t\tif(!hasNext())\
    \ {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\t@SuppressWarnings(\"\
    unchecked\")\n\t\t\tfinal T res = (T) buf[now];\n\t\t\tnow = (now + 1) % n;\n\t\
    \t\trem--;\n\t\t\treturn res;\n\t\t}\n\t\t@Override\n\t\tpublic final void remove()\
    \ {\n\t\t\tif(isEmpty()) {\n\t\t\t\tthrow new IllegalStateException();\n\t\t\t\
    }\n\t\t\tnow = (now - 1 + n) % n;\n\t\t\tbuf[now] = null;\n\t\t\thead = (head\
    \ + 1) % n;\n\t\t\trem++;\n\t\t}\n\t}\n}\nfinal class IntDeque {\n\tprivate int\
    \ n, head, tail;\n\tprivate long[] buf;\n\tIntDeque(){ this(1 << 17); }\n\tprivate\
    \ IntDeque(final int n) {\n\t\tthis.n = n;\n\t\thead = tail = 0;\n\t\tbuf = new\
    \ long[n];\n\t}\n\tIntDeque(final int[] a) {\n\t\tthis(a.length);\n\t\tArrays.stream(a).forEach(i\
    \ -> add(i));\n\t}\n\tIntDeque(final long[] a) {\n\t\tthis(a.length);\n\t\tArrays.stream(a).forEach(i\
    \ -> add(i));\n\t}\n\tprivate final int next(final int index) {\n\t\tfinal int\
    \ next = index + 1;\n\t\treturn next == n ? 0 : next;\n\t}\n\tprivate final int\
    \ prev(final int index) {\n\t\tfinal int prev = index - 1;\n\t\treturn prev ==\
    \ -1 ? n - 1 : prev;\n\t}\n\tprivate final int index(final int i) {\n\t\tfinal\
    \ int size = size();\n\t\tassert i < size;\n\t\tfinal int id = head + i;\n\t\t\
    return n <= id ? id - n : id;\n\t}\n\tprivate final void arraycopy(final int fromId,\
    \ final long[] a, final int from, final int len) {\n\t\tassert fromId + len <=\
    \ size();\n\t\tfinal int h = index(fromId);\n\t\tif(h + len < n) {\n\t\t\tSystem.arraycopy(buf,\
    \ h, a, from, len);\n\t\t} else {\n\t\t\tfinal int back = n - h;\n\t\t\tSystem.arraycopy(buf,\
    \ h, a, from, back);\n\t\t\tSystem.arraycopy(buf, 0, a, from + back, len - back);\n\
    \t\t}\n\t}\n\tprivate final void extend() {\n\t\tfinal long[] tmp = new long[n\
    \ << 1];\n\t\tarraycopy(0, tmp, 0, size());\n\t\tbuf = tmp;\n\t\tn = buf.length;\n\
    \t}\n\tfinal boolean isEmpty(){ return size() == 0; }\n\tfinal int size() {\n\t\
    \tfinal int size = tail - head;\n\t\treturn size < 0 ? size + n : size;\n\t}\n\
    \tfinal void addFirst(final long x) {\n\t\thead = prev(head);\n\t\tif(head ==\
    \ tail) {\n\t\t\textend();\n\t\t}\n\t\tbuf[head] = x;\n\t}\n\tfinal void addLast(final\
    \ long x) {\n\t\tif(next(tail) == head) {\n\t\t\textend();\n\t\t}\n\t\tbuf[tail]\
    \ = x;\n\t\ttail = next(tail);\n\t}\n\tfinal void removeFirst() {\n\t\tif(head\
    \ == tail) {\n\t\t\tthrow new NoSuchElementException(\"Deque is empty\");\n\t\t\
    }\n\t\thead = next(head);\n\t}\n\tfinal void removeLast() {\n\t\tif(head == tail)\
    \ {\n\t\t\tthrow new NoSuchElementException(\"Deque is empty\");\n\t\t}\n\t\t\
    tail = prev(tail);\n\t}\n\tfinal long pollFirst() {\n\t\tif(head == tail) {\n\t\
    \t\tthrow new NoSuchElementException(\"Deque is empty\");\n\t\t}\n\t\tfinal long\
    \ ans = buf[head];\n\t\thead = next(head);\n\t\treturn ans;\n\t}\n\tfinal long\
    \ pollLast() {\n\t\tif(head == tail) {\n\t\t\tthrow new NoSuchElementException(\"\
    Deque is empty\");\n\t\t}\n\t\ttail = prev(tail);\n\t\treturn buf[tail];\n\t}\n\
    \tfinal long peekFirst(){ return get(0); }\n\tfinal long peekLast(){ return get(n\
    \ - 1); }\n\tfinal long get(final int i){ return buf[index(i)]; }\n\tfinal void\
    \ set(final int i, final long x){ buf[index(i)] = x; }\n\tfinal void add(final\
    \ long x){ addLast(x); }\n\tfinal long poll(){ return pollFirst(); }\n\tfinal\
    \ long peek(){ return peekFirst(); }\n\tfinal void swap(final int a, final int\
    \ b) {\n\t\tfinal int i = index(a);\n\t\tfinal int j = index(b);\n\t\tfinal long\
    \ num = buf[i];\n\t\tbuf[i] = buf[j];\n\t\tbuf[j] = num;\n\t}\n\tfinal void clear(){\
    \ head = tail = 0; }\n\tfinal long[] toArray(){ return Arrays.copyOf(buf, size());\
    \ }\n\t@Override\n\tpublic final String toString(){ return Arrays.toString(toArray());\
    \ }\n}\n\nfinal class AVLTree<T extends Comparable<? super T>> {\n\tstatic final\
    \ class Node<T extends Comparable<? super T>> {\n\t\tT val;\n\t\t@SuppressWarnings(\"\
    unchecked\")\n\t\tNode<T>[] ch = new Node[2];\n\t\tint dep, size;\n\t\tNode(final\
    \ T val, final Node<T> l, final Node<T> r) {\n\t\t\tthis.val = val;\n\t\t\tdep\
    \ = size = 1;\n\t\t\tch[0] = l;\n\t\t\tch[1] = r;\n\t\t}\n\t}\n\tprivate Node<T>\
    \ root;\n\tprivate final int depth(final Node<T> t){ return t == null ? 0 : t.dep;\
    \ }\n\tprivate final int count(final Node<T> t){ return t == null ? 0 : t.size;\
    \ }\n\tprivate final Node<T> update(final Node<T> t) {\n\t\tt.dep = max(depth(t.ch[0]),\
    \ depth(t.ch[1])) + 1;\n\t\tt.size = count(t.ch[0]) + count(t.ch[1]) + 1;\n\t\t\
    return t;\n\t}\n\tprivate final Node<T> rotate(Node<T> t, final int b) {\n\t\t\
    Node<T> s = t.ch[1 - b];\n\t\tt.ch[1 - b] = s.ch[b];\n\t\ts.ch[b] = t;\n\t\tt\
    \ = update(t);\n\t\ts = update(s);\n\t\treturn s;\n\t}\n\tprivate final Node<T>\
    \ fetch(Node<T> t) {\n\t\tif(t == null) {\n\t\t\treturn t;\n\t\t}\n\t\tif(depth(t.ch[0])\
    \ - depth(t.ch[1]) == 2) {\n\t\t\tif(depth(t.ch[0].ch[1]) > depth(t.ch[0].ch[0]))\
    \ {\n\t\t\t\tt.ch[0] = rotate(t.ch[0], 0);\n\t\t\t}\n\t\t\tt = rotate(t, 1);\n\
    \t\t}\n\t\telse if(depth(t.ch[0]) - depth(t.ch[1]) == -2) {\n\t\t\tif (depth(t.ch[1].ch[0])\
    \ > depth(t.ch[1].ch[1])) {\n\t\t\t\tt.ch[1] = rotate(t.ch[1], 1);\n\t\t\t}\n\t\
    \t\tt = rotate(t, 0);\n\t\t}\n\t\treturn t;\n\t}\n\tprivate final Node<T> insert(final\
    \ Node<T> t, final int k, final T v) {\n\t\tif(t == null) {\n\t\t\treturn new\
    \ Node<T>(v, null, null);\n\t\t}\n\t\tfinal int c = count(t.ch[0]), b = (k > c)\
    \ ? 1 : 0;\n\t\tt.ch[b] = insert(t.ch[b], k - (b == 1 ? (c + 1) : 0), v);\n\t\t\
    update(t);\n\t\treturn fetch(t);\n\t}\n\tprivate final Node<T> erase(final Node<T>\
    \ t) {\n\t\tif(t == null || t.ch[0] == null && t.ch[1] == null) {\n\t\t\treturn\
    \ null;\n\t\t}\n\t\tif(t.ch[0] == null || t.ch[1] == null) {\n\t\t\treturn t.ch[t.ch[0]\
    \ == null ? 1 : 0];\n\t\t}\n\t\treturn fetch(update(new Node<T>(find(t.ch[1],\
    \ 0).val, t.ch[0], erase(t.ch[1], 0))));\n\t}\n\tprivate final Node<T> erase(Node<T>\
    \ t, final int k) {\n\t\tif(t == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfinal\
    \ int c = count(t.ch[0]);\n\t\tif(k < c) {\n\t\t\tt.ch[0] = erase(t.ch[0], k);\n\
    \t\t\tt = update(t);\n\t\t}\n\t\telse if(k > c) {\n\t\t\tt.ch[1] = erase(t.ch[1],\
    \ k - (c + 1));\n\t\t\tt = update(t);\n\t\t}\n\t\telse {\n\t\t\tt = erase(t);\n\
    \t\t}\n\t\treturn fetch(t);\n\t}\n\tprivate final Node<T> find(final Node<T> t,\
    \ final int k) {\n\t\tif(t == null) {\n\t\t\treturn t;\n\t\t}\n\t\tfinal int c\
    \ = count(t.ch[0]);\n\t\treturn k < c ? find(t.ch[0], k) : k == c ? t : find(t.ch[1],\
    \ k - (c + 1));\n\t}\n\tprivate final int cnt(final Node<T> t, final T v) {\n\t\
    \tif(t == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tif(t.val.compareTo(v) < 0) {\n\t\
    \t\treturn count(t.ch[0]) + 1 + cnt(t.ch[1], v);\n\t\t}\n\t\tif(t.val.equals(v))\
    \ {\n\t\t\treturn count(t.ch[0]);\n\t\t}\n\t\treturn cnt(t.ch[0], v);\n\t}\n\t\
    AVLTree(){ root = null; }\n\tfinal void add(final T val){ root = insert(root,\
    \ cnt(root, val), val); }\n\tfinal void remove(final int k){ root = erase(root,\
    \ k); }\n\tfinal T get(final int k){ return find(root, k).val; }\n\tfinal int\
    \ count(final T val){ return cnt(root, val); }\n\tfinal int size(){ return root.size;\
    \ }\n\t@Override\n\tpublic final String toString() {\n\t\tfinal StringBuilder\
    \ sb = new StringBuilder();\n\t\tsb.append(get(0));\n\t\tfor(int i = 0; ++i <\
    \ root.size;) {\n\t\t\tsb.append(\" \");\n\t\t\tsb.append(get(i));\n\t\t}\n\t\t\
    return \"[\" + sb.toString() + \"]\";\n\t}\n}\n\nfinal class DoubleEndedPriorityQueue<T\
    \ extends Number> {\n\tprivate final ArrayList<T> d;\n\tDoubleEndedPriorityQueue(final\
    \ ArrayList<T> d) {\n\t\tthis.d = d;\n\t\tmakeHeap();\n\t}\n\tprivate final void\
    \ makeHeap() {\n\t\tfor(int i = d.size(); i-- > 0;) {\n\t\t\tif (i % 2 == 1 &&\
    \ d.get(i - 1).longValue() < d.get(i).longValue()) {\n\t\t\t\tCollections.swap(d,\
    \ i - 1, i);\n\t\t\t}\n\t\t\tup(down(i), i);\n\t\t}\n\t}\n\tprivate final int\
    \ down(int k) {\n\t\tfinal int n = d.size();\n\t\tif(k % 2 == 1) {\n\t\t\twhile(2\
    \ * k + 1 < n) {\n\t\t\t\tint c = 2 * k + 3;\n\t\t\t\tif(n <= c || d.get(c - 2).longValue()\
    \ < d.get(c).longValue()) {\n\t\t\t\t\t c -= 2;\n\t\t\t\t}\n\t\t\t\tif(c < n &&\
    \ d.get(c).longValue() < d.get(k).longValue()) {\n\t\t\t\t\tCollections.swap(d,\
    \ k, c);\n\t\t\t\t\tk = c;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\
    \t}\n\t\t\t}\n\t\t} else {\n\t\t\twhile(2 * k + 2 < n) {\n\t\t\t\tint c = 2 *\
    \ k + 4;\n\t\t\t\tif(n <= c || d.get(c).longValue() < d.get(c - 2).longValue())\
    \ {\n\t\t\t\t\tc -= 2;\n\t\t\t\t}\n\t\t\t\tif(c < n && d.get(k).longValue() <\
    \ d.get(c).longValue()) {\n\t\t\t\t\tCollections.swap(d, k, c);\n\t\t\t\t\tk =\
    \ c;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\treturn k;\n\t}\n\tprivate final int up(int k, final int root) {\n\t\tif((k\
    \ | 1) < d.size() && d.get(k & ~1).longValue() < d.get(k | 1).longValue()) {\n\
    \t\t\tCollections.swap(d, k & ~1, k | 1);\n\t\t\tk ^= 1;\n\t\t}\n\t\tint p;\n\t\
    \twhile(root < k && d.get(p = parent(k)).longValue() < d.get(k).longValue()) {\n\
    \t\t\tCollections.swap(d, p, k);\n\t\t\tk = p;\n\t\t}\n\t\twhile(root < k && d.get(k).longValue()\
    \ < d.get(p = parent(k) | 1).longValue()) {\n\t\t\tCollections.swap(d, p, k);\n\
    \t\t\tk = p;\n\t\t}\n\t\treturn k;\n\t}\n\tprivate final int parent(final int\
    \ k){ return ((k >> 1) - 1) & ~1; }\n\tprivate final void popBack(final ArrayList<T>\
    \ d){ d.remove(d.size() - 1); } \n\tfinal void push(final T x) {\n\t\tfinal int\
    \ k = d.size();\n\t\td.add(x);\n\t\tup(k, 1);\n\t}\n\tfinal T popMin() {\n\t\t\
    final T res = getMin();\n\t\tif(d.size() < 3) {\n\t\t\tpopBack(d); \n\t\t} else\
    \ {\n\t\t\tCollections.swap(d, 1, d.size() - 1);\n\t\t\tpopBack(d);\n\t\t\tup(down(1),\
    \ 1);\n\t\t}\n\t\treturn res;\n\t}\n\tfinal T popMax() {\n\t\tfinal T res = getMax();\n\
    \t\tif(d.size() < 2) { \n\t\t\tpopBack(d);\n\t\t} else {\n\t\t\tCollections.swap(d,\
    \ 0, d.size() - 1);\n\t\t\tpopBack(d);\n\t\t\tup(down(0), 1);\n\t\t}\n\t\treturn\
    \ res;\n\t}\n\tfinal T getMin(){ return d.size() < 2 ? d.get(0) : d.get(1); }\n\
    \tfinal T getMax(){ return d.get(0); }\n\tfinal int size(){ return d.size(); }\n\
    \tfinal boolean isEmpty(){ return d.isEmpty(); }\n}\n\nfinal class FenwickTree\
    \ {\n\tprivate final int n;\n\tprivate final long[] data;\n\tFenwickTree(final\
    \ int n) {\n\t\tthis.n = n + 2;\n\t\tdata = new long[this.n + 1];\n\t}\n\tFenwickTree(final\
    \ int[] a) {\n\t\tthis(a.length);\n\t\tIntStream.range(0, a.length).forEach(i\
    \ -> add(i, a[i]));\n\t}\n\tFenwickTree(final long[] a) {\n\t\tthis(a.length);\n\
    \t\tIntStream.range(0, a.length).forEach(i -> add(i, a[i]));\n\t}\n\tfinal long\
    \ sum(int k) {\n\t\tif(k < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong ret = 0;\n\t\
    \tfor(++k; k > 0; k -= k & -k) {\n\t\t\tret += data[k];\n\t\t}\n\t\treturn ret;\n\
    \t}\n\tfinal long sum(final int l, final int r){ return sum(r) - sum(l - 1); }\n\
    \tfinal long get(final int k){ return sum(k) - sum(k - 1); }\n\tfinal void add(int\
    \ k, final long x) {\n\t\tfor(++k; k < n; k += k & -k) {\n\t\t\tdata[k] += x;\n\
    \t\t}\n\t}\n\tfinal void add(final int l, final int r, final long x) {\n\t\tadd(l,\
    \ x);\n\t\tadd(r + 1, -x);\n\t}\n\tprivate final int lg(final int n){ return 31\
    \ - Integer.numberOfLeadingZeros(n); }\n\tfinal int lowerBound(long w) {\n\t\t\
    if(w <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint x = 0;\n\t\tfor(int k = 1 << lg(n);\
    \ k > 0; k >>= 1) {\n\t\t\tif(x + k <= n - 1 && data[x + k] < w) {\n\t\t\t\tw\
    \ -= data[x + k];\n\t\t\t\tx += k;\n\t\t\t}\n\t\t}\n\t\treturn x;\n\t}\n\tfinal\
    \ int upperBound(long w) {\n\t\tif(w < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint x\
    \ = 0;\n\t\tfor(int k = 1 << lg(n); k > 0; k >>= 1) {\n\t\t\tif(x + k <= n - 1\
    \ && data[x + k] <= w) {\n\t\t\t\tw -= data[x + k];\n\t\t\t\tx += k;\n\t\t\t}\n\
    \t\t}\n\t\treturn x;\n\t}\n\t@Override\n\tpublic final String toString() {\n\t\
    \tfinal StringBuilder sb = new StringBuilder();\n\t\tsb.append(sum(0));\n\t\t\
    for(int i = 0; ++i < n - 2;) {\n\t\t\tsb.append(\" \" + sum(i));\n\t\t}\n\t\t\
    return sb.toString();\n\t}\n}\nfinal class RangeBIT {\n\tprivate final int n;\n\
    \tprivate final FenwickTree a, b;\n\tRangeBIT(final int n) {\n\t\tthis.n = n;\n\
    \t\ta = new FenwickTree(n + 1);\n\t\tb = new FenwickTree(n + 1);\n\t}\n\tRangeBIT(final\
    \ int[] arr) {\n\t\tthis(arr.length);\n\t\tfor(int i = 0; i < arr.length; ++i)\
    \ {\n\t\t\tadd(i, i, arr[i]);\n\t\t}\n\t}\n\tRangeBIT(final long[] arr) {\n\t\t\
    this(arr.length);\n\t\tfor(int i = 0; i < arr.length; ++i) {\n\t\t\tadd(i, i,\
    \ arr[i]);\n\t\t}\n\t}\n\tfinal void add(final int l, final int r, final long\
    \ x) {\n\t\ta.add(l, x);\n\t\ta.add(r, -x);\n\t\tb.add(l, x * (1 - l));\n\t\t\
    b.add(r, x * (r - 1));\n\t}\n\tfinal long get(final int i){ return sum(i, i +\
    \ 1); }\n\tfinal long sum(int l, int r) {\n\t\tl--;\n\t\tr--;\n\t\treturn a.sum(r)\
    \ * r + b.sum(r) - a.sum(l) * l - b.sum(l);\n\t}\n\t@Override\n\tpublic final\
    \ String toString() {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\t\
    sb.append(get(0));\n\t\tfor(int i = 0; ++i < n;) {\n\t\t\tsb.append(\" \" + get(i));\n\
    \t\t}\n\t\treturn sb.toString();\n\t}\n}\n\nfinal class SegmentTree<T> {\n\tprivate\
    \ int n = 1, rank = 0;\n\tprivate final int fini;\n\tprivate final BinaryOperator<T>\
    \ op;\n\tprivate final T e;\n\tprivate final Object[] dat;\n\tSegmentTree(final\
    \ int fini, final BinaryOperator<T> op, final T e) {\n\t\tthis.fini = fini;\n\t\
    \tthis.op = op;\n\t\tthis.e = e;\n\t\twhile(this.fini > n) {\n\t\t\tn <<= 1;\n\
    \t\t\trank++;\n\t\t}\n\t\tdat = new Object[2 * n];\n\t\tArrays.fill(dat, e);\n\
    \t}\n\tSegmentTree(final T[] a, final BinaryOperator<T> op, final T e) {\n\t\t\
    this(a.length, op, e);\n\t\tIntStream.range(0, a.length).forEach(i -> update(i,\
    \ a[i]));\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal void update(int i,\
    \ final T x) {\n\t\ti += n;\n\t\tdat[i] = x;\n\t\tdo {\n\t\t\ti >>= 1;\n\t\t\t\
    dat[i] = op.apply((T) dat[2 * i], (T) dat[2 * i + 1]);\n\t\t} while(i > 0);\n\t\
    }\n\tfinal T get(final int i){ return query(i, i + 1); }\n\t@SuppressWarnings(\"\
    unchecked\")\n\tfinal T query(int a, int b) {\n\t\tT l = e, r = e;\n\t\tfor(a\
    \ += n, b += n; a < b; a >>= 1, b >>= 1) {\n\t\t\tif(a % 2 == 1) {\n\t\t\t\tl\
    \ = op.apply(l, (T) dat[a++]);\n\t\t\t}\n\t\t\tif(b % 2 == 1) {\n\t\t\t\tr = op.apply((T)\
    \ dat[--b], r);\n\t\t\t}\n\t\t}\n\t\treturn op.apply(l, r);\n\t}\n\t@SuppressWarnings(\"\
    unchecked\")\n\tfinal T all(){ return (T) dat[1]; }\n\t@SuppressWarnings(\"unchecked\"\
    )\n\tfinal int findLeft(final int r, final Predicate<T> fn) {\n\t\tif(r == 0)\
    \ {\n\t\t\treturn 0;\n\t\t}\n\t\tint h = 0, i = r + n;\n\t\tT val = e;\n\t\tfor(;\
    \ h <= rank; h++) {\n\t\t\tif(i >> (h & 1) > 0) {\n\t\t\t\tfinal T val2 = op.apply(val,\
    \ (T) dat[i >> (h ^ 1)]);\n\t\t\t\tif(fn.test(val2)){\n\t\t\t\t\ti -= 1 << h;\n\
    \t\t\t\t\tif(i == n) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tval = val2;\n\
    \t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(;\
    \ h-- > 0;) {\n\t\t\tfinal T val2 = op.apply(val, (T) dat[(i >> h) - 1]);\n\t\t\
    \tif(fn.test(val2)){\n\t\t\t\ti -= 1 << h;\n\t\t\t\tif(i == n) {\n\t\t\t\t\treturn\
    \ 0;\n\t\t\t\t}\n\t\t\t\tval = val2;\n\t\t\t}\n\t\t}\n\t\treturn i - n;\n\t}\n\
    \t@SuppressWarnings(\"unchecked\")\n\tfinal int findRight(final int l, final Predicate<T>\
    \ fn) {\n\t\tif(l == fini) {\n\t\t\treturn fini;\n\t\t}\n\t\tint h = 0, i = l\
    \ + n;\n\t\tT val = e;\n\t\tfor(; h <= rank; h++) {\n\t\t\tif(i >> (h & 1) > 0){\n\
    \t\t\t\tfinal T val2 = op.apply(val, (T) dat[i >> h]);\n\t\t\t\tif(fn.test(val2)){\n\
    \t\t\t\t\ti += 1 << h;\n\t\t\t\t\tif(i == n * 2) {\n\t\t\t\t\t\treturn fini;\n\
    \t\t\t\t\t}\n\t\t\t\t\tval = val2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(; h-- > 0;) {\n\t\t\tfinal T val2 = op.apply(val,\
    \ (T) dat[i >> h]);\n\t\t\tif(fn.test(val2)) {\n\t\t\t\ti += 1 << h;\n\t\t\t\t\
    if(i == n * 2) {\n\t\t\t\t\treturn fini;\n\t\t\t\t}\n\t\t\t\tval = val2;\n\t\t\
    \t}\n\t\t}\n\t\treturn min(i - n, fini);\n\t}\n\t@Override\n\tpublic final String\
    \ toString() {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tsb.append(get(0));\n\
    \t\tfor(int i = 0; ++i < fini;) {\n\t\t\tsb.append(\" \" + get(i));\n\t\t}\n\t\
    \treturn sb.toString();\n\t}\n}\n\nclass LazySegmentTree<T, U extends Comparable<?\
    \ super U>> {\n\tprivate final int n;\n\tprivate int sz, h;\n\tprivate final Object[]\
    \ data, lazy;\n\tprivate final BinaryOperator<T> f;\n\tprivate final BiFunction<T,\
    \ U, T> map;\n\tprivate final BinaryOperator<U> comp;\n\tprivate final T e;\n\t\
    private final U id;\n\t@SuppressWarnings(\"unchecked\")\n\tprivate final void\
    \ update(final int k){ data[k] = f.apply((T) data[2 * k], (T) data[2 * k + 1]);\
    \ }\n\t@SuppressWarnings(\"unchecked\")\n\tprivate final void allApply(final int\
    \ k, final U x) {\n\t\tdata[k] = map.apply((T) data[k], x);\n\t\tif(k < sz) {\n\
    \t\t\tlazy[k] = comp.apply((U) lazy[k], x);\n\t\t}\n\t}\n\t@SuppressWarnings(\"\
    unchecked\")\n\tprivate final void propagate(final int k) {\n\t\tif(!lazy[k].equals(id))\
    \ {\n\t\t\tallApply(2 * k, (U) lazy[k]);\n\t\t\tallApply(2 * k + 1, (U) lazy[k]);\n\
    \t\t\tlazy[k] = id;\n\t\t}\n\t}\n\tLazySegmentTree(final int n, final BinaryOperator<T>\
    \ f, final BiFunction<T, U, T> map, final BinaryOperator<U> comp, final T e, final\
    \ U id) {\n\t\tthis.n = n;\n\t\tthis.f = f;\n\t\tthis.map = map;\n\t\tthis.comp\
    \ = comp;\n\t\tthis.e = e;\n\t\tthis.id = id;\n\t\tsz = 1;\n\t\th = 0;\n\t\twhile(sz\
    \ < n) {\n\t\t\tsz <<= 1;\n\t\t\th++;\n\t\t}\n\t\tdata = new Object[2 * sz];\n\
    \t\tArrays.fill(data, e);\n\t\tlazy = new Object[2 * sz];\n\t\tArrays.fill(lazy,\
    \ id);\n\t}\n\tLazySegmentTree(final T[] a, final BinaryOperator<T> f, final BiFunction<T,\
    \ U, T> map, final BinaryOperator<U> comp, final T e, final U id) {\n\t\tthis(a.length,\
    \ f, map, comp, e, id);\n\t\tbuild(a);\n\t}\n\tfinal void build(final T[] a) {\n\
    \t\tassert n == a.length;\n\t\tfor(int k = 0; k < n; ++k) {\n\t\t\tdata[k + sz]\
    \ = a[k];\n\t\t}\n\t\tfor(int k = sz; --k > 0;) {\n\t\t\tupdate(k);\n\t\t}\n\t\
    }\n\tfinal void set(int k, final T x) {\n\t\tk += sz;\n\t\tfor(int i = h; i >\
    \ 0; i--) {\n\t\t\tpropagate(k >> i);\n\t\t}\n\t\tdata[k] = x;\n\t\tfor(int i\
    \ = 0; ++i <= h;) {\n\t\t\tupdate(k >> i);\n\t\t}\n\t}\n\t@SuppressWarnings(\"\
    unchecked\")\n\tfinal T get(int k) {\n\t\tk += sz;\n\t\tfor(int i = h; i > 0;\
    \ i--) {\n\t\t\tpropagate(k >> i);\n\t\t}\n\t\treturn (T) data[k];\n\t}\n\t@SuppressWarnings(\"\
    unchecked\")\n\tfinal T query(int l, int r) {\n\t\tif(l >= r) {\n\t\t\treturn\
    \ e;\n\t\t}\n\t\tl += sz;\n\t\tr += sz;\n\t\tfor(int i = h; i > 0; i--) {\n\t\t\
    \tif(((l >> i) << i) != l) {\n\t\t\t\tpropagate(l >> i);\n\t\t\t}\n\t\t\tif(((r\
    \ >> i) << i) != r) {\n\t\t\t\tpropagate((r - 1) >> i);\n\t\t\t}\n\t\t}\n\t\t\
    T l2 = e, r2 = e;\n\t\tfor(; l < r; l >>= 1, r >>= 1) {\n\t\t\tif(l % 2 == 1)\
    \ {\n\t\t\t\tl2 = f.apply(l2, (T) data[l++]);\n\t\t\t}\n\t\t\tif(r % 2 == 1) {\n\
    \t\t\t\tr2 = f.apply((T) data[--r], r2);\n\t\t\t}\n\t\t}\n\t\treturn f.apply(l2,\
    \ r2);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T all(){ return (T) data[1];\
    \ }\n\t@SuppressWarnings(\"unchecked\")\n\tfinal void apply(int k, final U x)\
    \ {\n\t\tk += sz;\n\t\tfor(int i = h; i > 0; i--) {\n\t\t\tpropagate(k >> i);\n\
    \t\t}\n\t\tdata[k] = map.apply((T) data[k], x);\n\t\tfor(int i = 0; ++i <= h;)\
    \ {\n\t\t\tupdate(k >> i);\n\t\t}\n\t}\n\tfinal void apply(int l, int r, final\
    \ U x) {\n\t\tif(l >= r) {\n\t\t\treturn;\n\t\t}\n\t\tl += sz;\n\t\tr += sz;\n\
    \t\tfor(int i = h; i > 0; i--) {\n\t\t\tif(((l >> i) << i) != l) {\n\t\t\t\tpropagate(l\
    \ >> i);\n\t\t\t}\n\t\t\tif(((r >> i) << i) != r) {\n\t\t\t\tpropagate((r - 1)\
    \ >> i);\n\t\t\t}\n\t\t}\n\t\tint l2 = l, r2 = r;\n\t\tfor(; l < r; l >>= 1, r\
    \ >>= 1) {\n\t\t\tif(l % 2 == 1) {\n\t\t\t\tallApply(l++, x);\n\t\t\t}\n\t\t\t\
    if(r % 2 == 1) {\n\t\t\t\tallApply(--r, x);\n\t\t\t}\n\t\t}\n\t\tl = l2;\n\t\t\
    r = r2;\n\t\tfor(int i = 0; ++i <= h;) {\n\t\t\tif(((l >> i) << i) != l) {\n\t\
    \t\t\tupdate(l >> i);\n\t\t\t}\n\t\t\tif(((r >> i) << i) != r) {\n\t\t\t\tupdate((r\
    \ - 1) >> i);\n\t\t\t}\n\t\t}\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal\
    \ int findFirst(int l, final Predicate<T> fn) {\n\t\tif(l >= n) {\n\t\t\treturn\
    \ n;\n\t\t}\n\t\tl += sz;\n\t\tfor(int i = h; i > 0; i--) {\n\t\t\tpropagate(l\
    \ >> i);\n\t\t}\n\t\tT sum = e;\n\t\tdo {\n\t\t\twhile((l & 1) == 0) {\n\t\t\t\
    \tl >>= 1;\n\t\t\t}\n\t\t\tif(fn.test(f.apply(sum, (T) data[l]))) {\n\t\t\t\t\
    while(l < sz) {\n\t\t\t\t\tpropagate(l);\n\t\t\t\t\tl <<= 1;\n\t\t\t\t\tfinal\
    \ T nxt = f.apply(sum, (T) data[l]);\n\t\t\t\t\tif(!fn.test(nxt)) {\n\t\t\t\t\t\
    \tsum = nxt;\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn l + 1 -\
    \ sz;\n\t\t\t}\n\t\t\tsum = f.apply(sum, (T) data[l++]);\n\t\t} while((l & -l)\
    \ != l);\n\t\treturn n;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal int\
    \ findLast(int r, final Predicate<T> fn) {\n\t\tif(r <= 0) {\n\t\t\treturn -1;\n\
    \t\t}\n\t\tr += sz;\n\t\tfor(int i = h; i > 0; i--) {\n\t\t\tpropagate((r - 1)\
    \ >> i);\n\t\t}\n\t\tT sum = e;\n\t\tdo {\n\t\t\tr--;\n\t\t\twhile(r > 1 && r\
    \ % 2 == 1) {\n\t\t\t\tr >>= 1;\n\t\t\t}\n\t\t\tif(fn.test(f.apply((T) data[r],\
    \ sum))) {\n\t\t\t\twhile(r < sz) {\n\t\t\t\t\tpropagate(r);\n\t\t\t\t\tr = (r\
    \ << 1) + 1;\n\t\t\t\t\tfinal T nxt = f.apply((T) data[r], sum);\n\t\t\t\t\tif(!fn.test(nxt))\
    \ {\n\t\t\t\t\t\tsum = nxt;\n\t\t\t\t\t\tr--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\
    return r - sz;\n\t\t\t}\n\t\t\tsum = f.apply((T) data[r], sum);\n\t\t} while((r\
    \ & -r) != r);\n\t\treturn -1;\n\t}\n\tfinal void clear(){ Arrays.fill(data, e);\
    \ }\n\t@Override\n\tpublic final String toString() {\n\t\tfinal StringBuilder\
    \ sb = new StringBuilder();\n\t\tsb.append(get(0));\n\t\tfor(int i = 0; ++i <\
    \ n;) {\n\t\t\tsb.append(\" \" + get(i));\n\t\t}\n\t\treturn sb.toString();\n\t\
    }\n}\nfinal class Zwei<T> implements Cloneable {\n\tpublic T first, second;\n\t\
    private Zwei(final T first, final T second) {\n\t\tthis.first = first;\n\t\tthis.second\
    \ = second;\n\t}\n\tstatic final <T> Zwei<T> of(final T f, final T s){ return\
    \ new Zwei<>(f, s); }\n\t@Override\n\tpublic final boolean equals(final Object\
    \ o) {\n\t\tif(this == o) {\n\t\t\treturn true;\n\t\t}\n\t\tif(o == null || getClass()\
    \ != o.getClass()) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal Zwei<?> z = (Zwei<?>)\
    \ o;\n\t\treturn first.equals(z.first) && second.equals(z.second);\n\t}\n\t@Override\n\
    \tpublic final int hashCode(){ return Objects.hash(first, second); }\n\t@Override\n\
    \tpublic final String toString(){ return String.valueOf(first); }\n\t@SuppressWarnings(\"\
    unchecked\")\n\t@Override\n\tpublic final Zwei<T> clone() {\n\t\ttry {\n\t\t\t\
    return (Zwei<T>) super.clone();\n\t\t} catch(final CloneNotSupportedException\
    \ e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tthrow new Error();\n\t}\n}\nfinal\
    \ class RAMX extends LazySegmentTree<Long, Long> {\n\tRAMX(final int[] a){ super(Arrays.stream(a).boxed().toArray(Long[]::new),\
    \ Long::max, Long::sum, Long::sum, Long.valueOf(Long.MIN_VALUE), Long.valueOf(0));\
    \ }\n\tRAMX(final long[] a){ super(Arrays.stream(a).boxed().toArray(Long[]::new),\
    \ Long::max, Long::sum, Long::sum, Long.valueOf(Long.MIN_VALUE), Long.valueOf(0));\
    \ }\n}\nfinal class RAMN extends LazySegmentTree<Long, Long> {\n\tRAMN(final int[]\
    \ a){ super(Arrays.stream(a).boxed().toArray(Long[]::new), Long::min, Long::sum,\
    \ Long::sum, Long.valueOf(Long.MAX_VALUE), Long.valueOf(0)); }\n\tRAMN(final long[]\
    \ a){ super(Arrays.stream(a).boxed().toArray(Long[]::new), Long::min, Long::sum,\
    \ Long::sum, Long.valueOf(Long.MAX_VALUE), Long.valueOf(0)); }\n}\nfinal class\
    \ RASM extends LazySegmentTree<Zwei<Long>, Long> {\n\tprivate final int n;\n\t\
    private final Zwei<Long>[] b;\n\t@SuppressWarnings(\"unchecked\")\n\tRASM(final\
    \ int[] a) {\n\t\tsuper(a.length, (x, y) -> Zwei.of(x.first.longValue() + y.first.longValue(),\
    \ x.second.longValue() + y.second.longValue()), (x, y) -> Zwei.of(x.first.longValue()\
    \ + x.second.longValue() * y.longValue(), x.second.longValue()), Long::sum, Zwei.of(0L,\
    \ 0L), Long.valueOf(0));\n\t\tn = a.length;\n\t\tb = new Zwei[n];\n\t\tfor(int\
    \ i = 0; i < n; ++i) {\n\t\t\tb[i] = Zwei.of((long) a[i], 1L);\n\t\t}\n\t\tbuild(b);\n\
    \t}\n\t@SuppressWarnings(\"unchecked\")\n\tRASM(final long[] a) {\n\t\tsuper(a.length,\
    \ (x, y) -> Zwei.of(x.first.longValue() + y.first.longValue(), x.second.longValue()\
    \ + y.second.longValue()), (x, y) -> Zwei.of(x.first.longValue() + x.second.longValue()\
    \ * y.longValue(), x.second.longValue()), Long::sum, Zwei.of(0L, 0L), Long.valueOf(0));\n\
    \t\tn = a.length;\n\t\tb = new Zwei[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\
    \tb[i] = Zwei.of(a[i], 1L);\n\t\t}\n\t\tbuild(b);\n\t}\n}\nfinal class RUMX extends\
    \ LazySegmentTree<Long, Long> {\n\tRUMX(final int[] a){ super(Arrays.stream(a).boxed().toArray(Long[]::new),\
    \ Long::max, (x, y) -> y, (x, y) -> y, Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MIN_VALUE));\
    \ }\n\tRUMX(final long[] a){ super(Arrays.stream(a).boxed().toArray(Long[]::new),\
    \ Long::max, (x, y) -> y, (x, y) -> y, Long.valueOf(Long.MIN_VALUE), Long.valueOf(Long.MIN_VALUE));\
    \ }\n}\nfinal class RUMN extends LazySegmentTree<Long, Long> {\n\tRUMN(final int[]\
    \ a){ super(Arrays.stream(a).boxed().toArray(Long[]::new), Long::min, (x, y) ->\
    \ y, (x, y) -> y, Long.valueOf(Long.MAX_VALUE), Long.valueOf(Long.MAX_VALUE));\
    \ }\n\tRUMN(final long[] a){ super(Arrays.stream(a).boxed().toArray(Long[]::new),\
    \ Long::min, (x, y) -> y, (x, y) -> y, Long.valueOf(Long.MAX_VALUE), Long.valueOf(Long.MAX_VALUE));\
    \ }\n}\nfinal class RUSM extends LazySegmentTree<Zwei<Long>, Long> {\n\tprivate\
    \ final int n;\n\tprivate final Zwei<Long>[] b;\n\t@SuppressWarnings(\"unchecked\"\
    )\n\tRUSM(final int[] a) {\n\t\tsuper(a.length, (x, y) -> Zwei.of(x.first.longValue()\
    \ + y.first.longValue(), x.second.longValue() + y.second.longValue()), (x, y)\
    \ -> Zwei.of(x.second.longValue() * y.longValue(), x.second.longValue()), (x,\
    \ y) -> y, Zwei.of(0L, 0L), Long.valueOf(Long.MIN_VALUE));\n\t\tn = a.length;\n\
    \t\tb = new Zwei[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tb[i] = Zwei.of((long)\
    \ a[i], 1L);\n\t\t}\n\t\tbuild(b);\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\t\
    RUSM(final long[] a) {\n\t\tsuper(a.length, (x, y) -> Zwei.of(x.first.longValue()\
    \ + y.first.longValue(), x.second.longValue() + y.second.longValue()), (x, y)\
    \ -> Zwei.of(x.second.longValue() * y.longValue(), x.second.longValue()), (x,\
    \ y) -> y, Zwei.of(0L, 0L), Long.valueOf(Long.MIN_VALUE));\n\t\tn = a.length;\n\
    \t\tb = new Zwei[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tb[i] = Zwei.of(a[i],\
    \ 1L);\n\t\t}\n\t\tbuild(b);\n\t}\n}\n\nfinal class DualSegmentTree<T> {\n\tprivate\
    \ final int n;\n\tprivate int sz, h;\n\tprivate final Object[] lazy;\n\tprivate\
    \ final T id;\n\tprivate final BinaryOperator<T> ap;\n\t@SuppressWarnings(\"unchecked\"\
    )\n\tprivate final void propagate(final int k) {\n\t\tif(lazy[k] != id) {\n\t\t\
    \tlazy[2 * k] = ap.apply((T) lazy[2 * k], (T) lazy[k]);\n\t\t\tlazy[2 * k + 1]\
    \ = ap.apply((T) lazy[2 * k + 1], (T) lazy[k]);\n\t\t\tlazy[k] = id;\n\t\t}\n\t\
    }\n\tprivate final void thrust(final int k) {\n\t\tfor(int i = h; i > 0; i--)\
    \ {\n\t\t\tpropagate(k >> i);\n\t\t}\n\t}\n\tDualSegmentTree(final int n, final\
    \ BinaryOperator<T> ap, final T id) {\n\t\tthis.n = n;\n\t\tthis.ap = ap;\n\t\t\
    this.id = id;\n\t\tsz = 1;\n\t\th = 0;\n\t\twhile(sz < n) {\n\t\t\tsz <<= 1;\n\
    \t\t\th++;\n\t\t}\n\t\tlazy = new Object[2 * sz];\n\t\tArrays.fill(lazy, id);\n\
    \t}\n\t@SuppressWarnings(\"unchecked\")\n\tfinal void apply(int a, int b, final\
    \ T x) {\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor(int l = a, r\
    \ = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif(l % 2 == 1) {\n\t\t\t\tlazy[l]\
    \ = ap.apply((T) lazy[l], x);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(r % 2 == 1) {\n\
    \t\t\t\tr--;\n\t\t\t\tlazy[r] = ap.apply((T) lazy[r], x);\n\t\t\t}\n\t\t}\n\t\
    }\n\t@SuppressWarnings(\"unchecked\")\n\tfinal T get(int k) {\n\t\tthrust(k +=\
    \ sz);\n\t\treturn (T) lazy[k];\n\t}\n\t@Override\n\tpublic final String toString()\
    \ {\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tsb.append(get(0));\n\
    \t\tfor(int i = 0; ++i < n;) {\n\t\t\tsb.append(\" \" + get(i));\n\t\t}\n\t\t\
    return sb.toString();\n\t}\n}\n\nfinal class SparseTable {\n\tprivate final long[][]\
    \ st;\n\tprivate final int[] lookup;\n\tprivate final LongBinaryOperator op;\n\
    \tSparseTable(final int[] a, final LongBinaryOperator op) {\n\t\tthis.op = op;\n\
    \t\tint b = 0;\n\t\twhile((1 << b) <= a.length) {\n\t\t\t++b;\n\t\t}\n\t\tst =\
    \ new long[b][1 << b];\n\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\tst[0][i]\
    \ = a[i];\n\t\t}\n\t\tfor(int i = 1; i < b; i++) {\n\t\t\tfor(int j = 0; j + (1\
    \ << i) <= (1 << b); j++) {\n\t\t\t\tst[i][j] = op.applyAsLong(st[i - 1][j], st[i\
    \ - 1][j + (1 << (i - 1))]);\n\t\t\t}\n\t\t}\n\t\tlookup = new int[a.length +\
    \ 1];\n\t\tfor(int i = 2; i < lookup.length; i++) {\n\t\t\tlookup[i] = lookup[i\
    \ >> 1] + 1;\n\t\t}\n\t}\n\tSparseTable(final long[] a, final LongBinaryOperator\
    \ op) {\n\t\tthis.op = op;\n\t\tint b = 0;\n\t\twhile((1 << b) <= a.length) {\n\
    \t\t\t++b;\n\t\t}\n\t\tst = new long[b][1 << b];\n\t\tfor(int i = 0; i < a.length;\
    \ i++) {\n\t\t\tst[0][i] = a[i];\n\t\t}\n\t\tfor(int i = 1; i < b; i++) {\n\t\t\
    \tfor(int j = 0; j + (1 << i) <= (1 << b); j++) {\n\t\t\t\tst[i][j] = op.applyAsLong(st[i\
    \ - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\t\t}\n\t\t}\n\t\tlookup = new int[a.length\
    \ + 1];\n\t\tfor(int i = 2; i < lookup.length; i++) {\n\t\t\tlookup[i] = lookup[i\
    \ >> 1] + 1;\n\t\t}\n\t}\n\tfinal long query(final int l, final int r) {\n\t\t\
    final int b = lookup[r - l];\n\t\treturn op.applyAsLong(st[b][l], st[b][r - (1\
    \ << b)]);\n\t}\n\tfinal int minLeft(final int x, final LongPredicate fn) {\n\t\
    \tif(x == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint ok = x, ng = -1;\n\t\twhile(abs(ok\
    \ - ng) > 1) {\n\t\t\tfinal int mid = (ok + ng) / 2;\n\t\t\tif(fn.test(query(mid,\
    \ x) - 1)) {\n\t\t\t\tok = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\
    \t}\n\t\t}\n\t\treturn ok;\n\t}\n\tfinal int maxRight(final int x, final LongPredicate\
    \ fn) {\n\t\tif(x == lookup.length - 1) {\n\t\t\treturn lookup.length - 1;\n\t\
    \t}\n\t\tint ok = x, ng = lookup.length;\n\t\twhile(abs(ok - ng) > 1) {\n\t\t\t\
    final int mid = (ok + ng) / 2;\n\t\t\tif(fn.test(query(x, mid))) {\n\t\t\t\tok\
    \ = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tng = mid;\n\t\t\t}\n\t\t}\n\t\treturn\
    \ ok;\n\t}\n}\n\nfinal class WaveletMatrix {\n\tprivate final WaveletMatrixBeta\
    \ mat;\n\tprivate final long[] ys;\n\tWaveletMatrix(final int[] arr){ this(arr,\
    \ 20); }\n\tWaveletMatrix(final long[] arr){ this(arr, 20); }\n\tWaveletMatrix(final\
    \ int[] arr, final int log) {\n\t\tys = Arrays.stream(arr).asLongStream().sorted().distinct().toArray();\n\
    \t\tfinal long[] t = new long[arr.length];\n\t\tArrays.setAll(t, i -> index(arr[i]));\n\
    \t\tmat = new WaveletMatrixBeta(t, log);\n\t}\n\tWaveletMatrix(final long[] arr,\
    \ final int log) {\n\t\tys = Arrays.stream(arr).sorted().distinct().toArray();\n\
    \t\tfinal long[] t = new long[arr.length];\n\t\tArrays.setAll(t, i -> index(arr[i]));\n\
    \t\tmat = new WaveletMatrixBeta(t, log);\n\t}\n\tprivate final int index(final\
    \ long x){ return Utility.lowerBound(ys, x); }\n\tfinal long get(final int k){\
    \ return ys[(int) mat.access(k)]; }\n\tfinal int rank(final int r, final long\
    \ x) {\n\t\tfinal int pos = index(x);\n\t\tif(pos == ys.length || ys[pos] != x)\
    \ {\n\t\t\treturn 0;\n\t\t}\n\t\treturn mat.rank(pos, r);\n\t}\n\tfinal int rank(final\
    \ int l, final int r, final long x){ return rank(r, x) - rank(l, x); }\n\tfinal\
    \ long kthMin(final int l, final int r, final int k){ return ys[(int) mat.kthMin(l,\
    \ r, k)]; }\n\tfinal long kthMax(final int l, final int r, final int k){ return\
    \ ys[(int) mat.kthMax(l, r, k)]; }\n\tfinal int rangeFreq(final int l, final int\
    \ r, final long upper){ return mat.rangeFreq(l, r, index(upper)); }\n\tfinal int\
    \ rangeFreq(final int l, final int r, final long lower, final long upper){ return\
    \ mat.rangeFreq(l, r, index(lower), index(upper)); }\n\tfinal long prev(final\
    \ int l, final int r, final long upper) {\n\t\tfinal long ret = mat.prev(l, r,\
    \ index(upper));\n\t\treturn ret == -1 ? -1 : ys[(int) ret];\n\t}\n\tfinal long\
    \ next(final int l, final int r, final long lower) {\n\t\tfinal long ret = mat.next(l,\
    \ r, index(lower));\n\t\treturn ret == -1 ? -1 : ys[(int) ret];\n\t}\n\tprivate\
    \ final class WaveletMatrixBeta {\n\t\tprivate final int log;\n\t\tprivate final\
    \ SuccinctIndexableDictionary[] matrix;\n\t\tprivate final int[] mid;\n\t\tWaveletMatrixBeta(final\
    \ long[] arr, final int log) {\n\t\t\tfinal int len = arr.length;\n\t\t\tthis.log\
    \ = log;\n\t\t\tmatrix = new SuccinctIndexableDictionary[log];\n\t\t\tmid = new\
    \ int[log];\n\t\t\tfinal long[] l = new long[len], r = new long[len];\n\t\t\t\
    for(int level = log; --level >= 0;) {\n\t\t\t\tmatrix[level] = new SuccinctIndexableDictionary(len\
    \ + 1);\n\t\t\t\tint left = 0, right = 0;\n\t\t\t\tfor(int i = 0; i < len; ++i)\
    \ {\n\t\t\t\t\tif(((arr[i] >> level) & 1) == 1) {\n\t\t\t\t\t\tmatrix[level].set(i);\n\
    \t\t\t\t\t\tr[right++] = arr[i];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl[left++] =\
    \ arr[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmid[level] = left;\n\t\t\t\tmatrix[level].build();\n\
    \t\t\t\tfinal long[] tmp = new long[len];\n\t\t\t\tSystem.arraycopy(arr, 0, tmp,\
    \ 0, len);\n\t\t\t\tSystem.arraycopy(l, 0, arr, 0, len);\n\t\t\t\tSystem.arraycopy(tmp,\
    \ 0, l, 0, len);\n\t\t\t\tfor(int i = 0; i < right; ++i) {\n\t\t\t\t\tarr[left\
    \ + i] = r[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate final IntPair succ(final\
    \ boolean f, final int l, final int r, final int level){ return IntPair.of(matrix[level].rank(f,\
    \ l) + mid[level] * (f ? 1 : 0), matrix[level].rank(f, r) + mid[level] * (f ?\
    \ 1 : 0)); }\n\t\tfinal long access(int k) {\n\t\t\tlong ret = 0;\n\t\t\tfor(int\
    \ level = log; --level >= 0;) {\n\t\t\t\tfinal boolean f = matrix[level].get(k);\n\
    \t\t\t\tif(f) {\n\t\t\t\t\tret |= 1L << level;\n\t\t\t\t}\n\t\t\t\tk = matrix[level].rank(f,\
    \ k) + mid[level] * (f ? 1 : 0);\n\t\t\t}\t\n\t\t\treturn ret;\n\t\t}\n\t\tfinal\
    \ int rank(final long x, int r) {\n\t\t\tint l = 0;\n\t\t\tfor(int level = log;\
    \ --level >= 0;) {\n\t\t\t\tfinal IntPair p = succ(((x >> level) & 1) == 1, l,\
    \ r, level);\n\t\t\t\tl = p.first.intValue();\n\t\t\t\tr = p.second.intValue();\n\
    \t\t\t}\n\t\t\treturn r - l;\n\t\t}\n\t\tfinal long kthMin(int l, int r, int k)\
    \ {\n\t\t\tif(!Utility.scope(0, k, r - l - 1)) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\
    \t\t\t}\n\t\t\tlong ret = 0;\n\t\t\tfor(int level = log; --level >= 0;) {\n\t\t\
    \t\tfinal int cnt = matrix[level].rank(false, r) - matrix[level].rank(false, l);\n\
    \t\t\t\tfinal boolean f = cnt <= k;\n\t\t\t\tif(f) {\n\t\t\t\t\tret |= 1 << level;\n\
    \t\t\t\t\tk -= cnt;\n\t\t\t\t}\n\t\t\t\tfinal IntPair p = succ(f, l, r, level);\n\
    \t\t\t\tl = p.first.intValue();\n\t\t\t\tr = p.second.intValue();\n\t\t\t}\n\t\
    \t\treturn ret;\n\t\t}\n\t\tfinal long kthMax(final int l, final int r, final\
    \ int k){ return kthMin(l, r, r - l - k - 1); }\n\t\tfinal int rangeFreq(int l,\
    \ int r, final long upper) {\n\t\t\tint ret = 0;\n\t\t\tfor(int level = log; --level\
    \ >= 0;) {\n\t\t\t\tfinal boolean f = ((upper >> level) & 1) == 1;\n\t\t\t\tif(f)\
    \ {\n\t\t\t\t\tret += matrix[level].rank(false, r) - matrix[level].rank(false,\
    \ l);\n\t\t\t\t}\n\t\t\t\tfinal IntPair p = succ(f, l, r, level); \n\t\t\t\tl\
    \ = p.first.intValue();\n\t\t\t\tr = p.second.intValue();\n\t\t\t}\n\t\t\treturn\
    \ ret;\n\t\t}\n\t\tfinal int rangeFreq(final int l, final int r, final long lower,\
    \ final long upper){ return rangeFreq(l, r, upper) - rangeFreq(l, r, lower); }\n\
    \t\tfinal long prev(final int l, final int r, final long upper) {\n\t\t\tfinal\
    \ int cnt = rangeFreq(l, r, upper);\n\t\t\treturn cnt == 0 ? -1 : kthMin(l, r,\
    \ cnt - 1);\n\t\t}\n\t\tfinal long next(final int l, final int r, final long lower)\
    \ {\n\t\t\tfinal int cnt = rangeFreq(l, r, lower);\n\t\t\treturn cnt == r - l\
    \ ? -1 : kthMin(l, r, cnt);\n\t\t}\n\t\tprivate final class SuccinctIndexableDictionary\
    \ {\n\t\t\tprivate final int blk;\n\t\t\tprivate final int[] bit, sum;\n\t\t\t\
    SuccinctIndexableDictionary(final int len) {\n\t\t\t\tblk = (len + 31) >> 5;\n\
    \t\t\t\tbit = new int[blk];\n\t\t\t\tsum = new int[blk];\n\t\t\t}\n\t\t\tfinal\
    \ void set(final int k){ bit[k >> 5] |= 1 << (k & 31); }\n\t\t\tfinal void build()\
    \ {\n\t\t\t\tsum[0] = 0;\n\t\t\t\tfor(int i = 0; i + 1 < blk; ++i) {\n\t\t\t\t\
    \tsum[i + 1] = sum[i] + Integer.bitCount(bit[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    final boolean get(final int k){ return ((bit[k >> 5] >> (k & 31)) & 1) == 1; }\n\
    \t\t\tfinal int rank(final int k){ return (sum[k >> 5] + Integer.bitCount(bit[k\
    \ >> 5] & ((1 << (k & 31)) - 1))); }\n\t\t\tfinal int rank(final boolean val,\
    \ final int k){ return val ? rank(k) : k - rank(k); }\n\t\t}\n\t}\n}"
  dependsOn:
  - Java/AOJ.java
  - Java/library/ds/lazysegmenttree/RASM.java
  - Java/library/ds/lazysegmenttree/RUMN.java
  - Java/library/ds/lazysegmenttree/RUMX.java
  - Java/library/ds/lazysegmenttree/RAMX.java
  - Java/library/ds/lazysegmenttree/LazySegmentTree.java
  - Java/library/ds/lazysegmenttree/RAMN.java
  - Java/library/ds/lazysegmenttree/RUSM.java
  - Java/library/ds/pair/IntPair.java
  - Java/library/ds/pair/FloatPair.java
  - Java/library/ds/pair/Zwei.java
  - Java/library/ds/pair/Pair.java
  - Java/library/ds/deque/MyDeque.java
  - Java/library/ds/deque/IntDeque.java
  - Java/library/ds/ConvexHullTrick.java
  - Java/library/ds/SegmentTree.java
  - Java/library/ds/SparseTable.java
  - Java/library/ds/DualSegmentTree.java
  - Java/library/ds/unionfind/WeightedUnionFind.java
  - Java/library/ds/unionfind/UndoUnionFind.java
  - Java/library/ds/unionfind/MergeUnionFind.java
  - Java/library/ds/unionfind/UnionFind.java
  - Java/library/ds/AVLTree.java
  - Java/library/ds/DoubleEndedPriorityQueue.java
  - Java/library/ds/waveletmatrix/SuccinctIndexableDictionary.java
  - Java/library/ds/waveletmatrix/WaveletMatrix.java
  - Java/library/ds/waveletmatrix/WaveletMatrixBeta.java
  - Java/library/ds/fenwicktree/RangeBIT.java
  - Java/library/ds/fenwicktree/FenwickTree.java
  - Java/library/core/VvyLw.java
  - Java/library/core/interfaces/DSU.java
  - Java/library/core/interfaces/lambda/RecursiveLongUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoublePredicate.java
  - Java/library/core/interfaces/lambda/RecursiveBiConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveLongPredicate.java
  - Java/library/core/interfaces/lambda/RecursiveTriConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveIntFunction.java
  - Java/library/core/interfaces/lambda/RecursiveLongFunction.java
  - Java/library/core/interfaces/lambda/RecursiveLongConsumer.java
  - Java/library/core/interfaces/lambda/TriConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveIntConsumer.java
  - Java/library/core/interfaces/lambda/RecursivePredicate.java
  - Java/library/core/interfaces/lambda/RecursiveIntBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveBiPredicate.java
  - Java/library/core/interfaces/lambda/TriFunction.java
  - Java/library/core/interfaces/lambda/RecursiveLongBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveFunction.java
  - Java/library/core/interfaces/lambda/QuadFunction.java
  - Java/library/core/interfaces/lambda/RecursiveUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveIntUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleFunction.java
  - Java/library/core/interfaces/lambda/RecursiveBiFunction.java
  - Java/library/core/interfaces/lambda/RecursiveTriPredicate.java
  - Java/library/core/interfaces/lambda/TriPredicate.java
  - Java/library/core/interfaces/lambda/RecursiveIntPredicate.java
  - Java/library/core/interfaces/lambda/RecursiveTriFunction.java
  - Java/library/core/Utility.java
  - Java/library/core/io/IO.java
  - Java/library/core/io/MyScanner.java
  - Java/library/core/io/MyPrinter.java
  - Java/library/core/Main.java
  - Java/library/math/PrimeFactor.java
  - Java/library/math/Matrix.java
  - Java/library/math/largeprime/LongPrime.java
  - Java/library/math/largeprime/BigPrime.java
  - Java/library/math/EulerPhiTable.java
  - Java/library/math/ModPrime.java
  - Java/library/math/prefixsum/PrefixSum2D.java
  - Java/library/math/prefixsum/PrefixSum.java
  - Java/library/math/PrimeCounter.java
  - Java/library/math/PrimeTable.java
  - Java/library/other/SuffixArray.java
  - Java/library/other/InclusiveScan.java
  - Java/library/other/SkewHeap.java
  - Java/library/other/Why.java
  - Java/library/other/DP.java
  - Java/library/graph/LowestCommonAncestor.java
  - Java/library/graph/Graph.java
  - Java/library/graph/SCC.java
  - Java/library/graph/Edge.java
  - Java/library/graph/ShortestPath.java
  - Java/library/graph/WeightedGraph.java
  - Java/library/graph/MST.java
  - Java/yukicoder.java
  - Java/CodeForces.java
  isVerificationFile: false
  path: Java/All.java
  requiredBy:
  - Java/AOJ.java
  - Java/library/ds/lazysegmenttree/RASM.java
  - Java/library/ds/lazysegmenttree/RUMN.java
  - Java/library/ds/lazysegmenttree/RUMX.java
  - Java/library/ds/lazysegmenttree/RAMX.java
  - Java/library/ds/lazysegmenttree/LazySegmentTree.java
  - Java/library/ds/lazysegmenttree/RAMN.java
  - Java/library/ds/lazysegmenttree/RUSM.java
  - Java/library/ds/pair/IntPair.java
  - Java/library/ds/pair/FloatPair.java
  - Java/library/ds/pair/Zwei.java
  - Java/library/ds/pair/Pair.java
  - Java/library/ds/deque/MyDeque.java
  - Java/library/ds/deque/IntDeque.java
  - Java/library/ds/ConvexHullTrick.java
  - Java/library/ds/SegmentTree.java
  - Java/library/ds/SparseTable.java
  - Java/library/ds/DualSegmentTree.java
  - Java/library/ds/unionfind/WeightedUnionFind.java
  - Java/library/ds/unionfind/UndoUnionFind.java
  - Java/library/ds/unionfind/MergeUnionFind.java
  - Java/library/ds/unionfind/UnionFind.java
  - Java/library/ds/AVLTree.java
  - Java/library/ds/DoubleEndedPriorityQueue.java
  - Java/library/ds/waveletmatrix/SuccinctIndexableDictionary.java
  - Java/library/ds/waveletmatrix/WaveletMatrix.java
  - Java/library/ds/waveletmatrix/WaveletMatrixBeta.java
  - Java/library/ds/fenwicktree/RangeBIT.java
  - Java/library/ds/fenwicktree/FenwickTree.java
  - Java/library/core/VvyLw.java
  - Java/library/core/interfaces/DSU.java
  - Java/library/core/interfaces/lambda/RecursiveLongUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoublePredicate.java
  - Java/library/core/interfaces/lambda/RecursiveBiConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveLongPredicate.java
  - Java/library/core/interfaces/lambda/RecursiveTriConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveIntFunction.java
  - Java/library/core/interfaces/lambda/RecursiveLongFunction.java
  - Java/library/core/interfaces/lambda/RecursiveLongConsumer.java
  - Java/library/core/interfaces/lambda/TriConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveConsumer.java
  - Java/library/core/interfaces/lambda/RecursiveIntConsumer.java
  - Java/library/core/interfaces/lambda/RecursivePredicate.java
  - Java/library/core/interfaces/lambda/RecursiveIntBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveBiPredicate.java
  - Java/library/core/interfaces/lambda/TriFunction.java
  - Java/library/core/interfaces/lambda/RecursiveLongBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveFunction.java
  - Java/library/core/interfaces/lambda/QuadFunction.java
  - Java/library/core/interfaces/lambda/RecursiveUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveIntUnaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveBinaryOperator.java
  - Java/library/core/interfaces/lambda/RecursiveDoubleFunction.java
  - Java/library/core/interfaces/lambda/RecursiveBiFunction.java
  - Java/library/core/interfaces/lambda/RecursiveTriPredicate.java
  - Java/library/core/interfaces/lambda/TriPredicate.java
  - Java/library/core/interfaces/lambda/RecursiveIntPredicate.java
  - Java/library/core/interfaces/lambda/RecursiveTriFunction.java
  - Java/library/core/Utility.java
  - Java/library/core/io/IO.java
  - Java/library/core/io/MyScanner.java
  - Java/library/core/io/MyPrinter.java
  - Java/library/core/Main.java
  - Java/library/math/PrimeFactor.java
  - Java/library/math/Matrix.java
  - Java/library/math/largeprime/LongPrime.java
  - Java/library/math/largeprime/BigPrime.java
  - Java/library/math/EulerPhiTable.java
  - Java/library/math/ModPrime.java
  - Java/library/math/prefixsum/PrefixSum2D.java
  - Java/library/math/prefixsum/PrefixSum.java
  - Java/library/math/PrimeCounter.java
  - Java/library/math/PrimeTable.java
  - Java/library/other/SuffixArray.java
  - Java/library/other/InclusiveScan.java
  - Java/library/other/SkewHeap.java
  - Java/library/other/Why.java
  - Java/library/other/DP.java
  - Java/library/graph/LowestCommonAncestor.java
  - Java/library/graph/Graph.java
  - Java/library/graph/SCC.java
  - Java/library/graph/Edge.java
  - Java/library/graph/ShortestPath.java
  - Java/library/graph/WeightedGraph.java
  - Java/library/graph/MST.java
  - Java/yukicoder.java
  - Java/CodeForces.java
  timestamp: '2024-03-18 14:00:40+09:00'
  verificationStatus: LIBRARY_NO_TESTS
  verifiedWith: []
documentation_of: Java/All.java
layout: document
redirect_from:
- /library/Java/All.java
- /library/Java/All.java.html
title: Java/All.java
---
